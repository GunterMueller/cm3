(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org/).
 * Version: 1.3.20
 *
 * Do not make changes to this file unless you know what you are doing --
 * modify the SWIG interface file instead.
 *******************************************************************************)

UNSAFE MODULE PLPlot;

IMPORT LongRealBasic AS R;
IMPORT LongRealVector AS V;
IMPORT NADefinitions AS NA;
IMPORT PLPlotRaw;
IMPORT M3toC;
IMPORT LongRealMatrix AS M;
IMPORT Ctypes AS C;


TYPE
  CallbackM3Data = RECORD
                     callback    : CallbackM3Proc;
                     callbackData: REFANY;
                   END;

PROCEDURE CallbackM3 () =
  BEGIN
  END CallbackM3;

CONST
  tileToChar = ARRAY DirTile OF
                 CHAR{'a', 'b', 'c', 'f', 'g', 'h', 'i', 'l', 'm', 'n',
                      's', 't'};

PROCEDURE SetContLabelFormat (lexp, sigdig: INTEGER; ) =
  BEGIN
    PLPlotRaw.pl_setcontlabelformat(lexp, sigdig);
  END SetContLabelFormat;

PROCEDURE SetContLabelParam (offset, size, spacing: R.T; active: INTEGER; ) =
  BEGIN
    PLPlotRaw.pl_setcontlabelparam(offset, size, spacing, active);
  END SetContLabelParam;

PROCEDURE Advance (page: INTEGER; ) =
  BEGIN
    PLPlotRaw.pladv(page);
  END Advance;

PROCEDURE DrawAxes (x0, y0: R.T;
                    xopt  : DirTileSet;
                    xtick : R.T;
                    nxsub : INTEGER;
                    yopt  : DirTileSet;
                    ytick : R.T;
                    nysub : INTEGER;    ) =
  VAR
    arg3 : ARRAY [0 .. ORD(LAST(Tile)) + 1] OF CHAR;
    arg3i: CARDINAL                                 := 0;
    arg6 : ARRAY [0 .. ORD(LAST(Tile)) + 1] OF CHAR;
    arg6i: CARDINAL                                 := 0;
  BEGIN
    FOR t := FIRST(DirTile) TO LAST(DirTile) DO
      IF t IN xopt THEN arg3[arg3i] := tileToChar[t]; INC(arg3i); END;
    END;
    arg3[arg3i] := '\000';

    FOR t := FIRST(DirTile) TO LAST(DirTile) DO
      IF t IN yopt THEN arg6[arg6i] := tileToChar[t]; INC(arg6i); END;
    END;
    arg6[arg6i] := '\000';

    PLPlotRaw.plaxes(x0, y0, arg3[0], xtick, nxsub, arg6[0], ytick, nysub);


  END DrawAxes;

PROCEDURE PlotBins (READONLY x, y: V.TBody; center: INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plbin(n, x[0], y[0], center);
  END PlotBins;

PROCEDURE StartPage () =
  BEGIN
    PLPlotRaw.plbop();
  END StartPage;

PROCEDURE DrawBox (xopt : DirTileSet;
                   xtick: R.T;
                   nxsub: INTEGER;
                   yopt : DirTileSet;
                   ytick: R.T;
                   nysub: INTEGER;    ) =
  VAR
    arg1 : ARRAY [0 .. ORD(LAST(Tile)) + 1] OF CHAR;
    arg1i: CARDINAL                                 := 0;
    arg4 : ARRAY [0 .. ORD(LAST(Tile)) + 1] OF CHAR;
    arg4i: CARDINAL                                 := 0;
  BEGIN
    FOR t := FIRST(DirTile) TO LAST(DirTile) DO
      IF t IN xopt THEN arg1[arg1i] := tileToChar[t]; INC(arg1i); END;
    END;
    arg1[arg1i] := '\000';

    FOR t := FIRST(DirTile) TO LAST(DirTile) DO
      IF t IN yopt THEN arg4[arg4i] := tileToChar[t]; INC(arg4i); END;
    END;
    arg4[arg4i] := '\000';

    PLPlotRaw.plbox(arg1[0], xtick, nxsub, arg4[0], ytick, nysub);


  END DrawBox;

PROCEDURE DrawBox3D (xopt  : DirTileSet;
                     xlabel: TEXT;
                     xtick : R.T;
                     nsubx : INTEGER;
                     yopt  : DirTileSet;
                     ylabel: TEXT;
                     ytick : R.T;
                     nsuby : INTEGER;
                     zopt  : DirTileSet;
                     zlabel: TEXT;
                     ztick : R.T;
                     nsubz : INTEGER;    ) =
  VAR
    arg1 : ARRAY [0 .. ORD(LAST(Tile)) + 1] OF CHAR;
    arg1i: CARDINAL                                 := 0;
    arg2 : C.char_star;
    arg5 : ARRAY [0 .. ORD(LAST(Tile)) + 1] OF CHAR;
    arg5i: CARDINAL                                 := 0;
    arg6 : C.char_star;
    arg9 : ARRAY [0 .. ORD(LAST(Tile)) + 1] OF CHAR;
    arg9i: CARDINAL                                 := 0;
    arg10: C.char_star;
  BEGIN
    FOR t := FIRST(DirTile) TO LAST(DirTile) DO
      IF t IN xopt THEN arg1[arg1i] := tileToChar[t]; INC(arg1i); END;
    END;
    arg1[arg1i] := '\000';

    arg2 := M3toC.SharedTtoS(xlabel);
    FOR t := FIRST(DirTile) TO LAST(DirTile) DO
      IF t IN yopt THEN arg5[arg5i] := tileToChar[t]; INC(arg5i); END;
    END;
    arg5[arg5i] := '\000';

    arg6 := M3toC.SharedTtoS(ylabel);
    FOR t := FIRST(DirTile) TO LAST(DirTile) DO
      IF t IN zopt THEN arg9[arg9i] := tileToChar[t]; INC(arg9i); END;
    END;
    arg9[arg9i] := '\000';

    arg10 := M3toC.SharedTtoS(zlabel);
    PLPlotRaw.plbox3(arg1[0], arg2, xtick, nsubx, arg5[0], arg6, ytick,
                     nsuby, arg9[0], arg10, ztick, nsubz);

    M3toC.FreeSharedS(xlabel, arg2);

    M3toC.FreeSharedS(ylabel, arg6);

    M3toC.FreeSharedS(zlabel, arg10);
  END DrawBox3D;

PROCEDURE CalcWorld (rx, ry: R.T; ): CalcWorldResult =
  VAR
    result: CalcWorldResult;
    arg5  : C.int;
  BEGIN
    PLPlotRaw.plcalc_world(rx, ry, result.wx, result.wy, arg5);
    result.window := arg5;
    RETURN result;
  END CalcWorld;

PROCEDURE Clear () =
  BEGIN
    PLPlotRaw.plclear();
  END Clear;

PROCEDURE SetFGColorDiscr (icol0: INTEGER; ) =
  BEGIN
    PLPlotRaw.plcol0(icol0);
  END SetFGColorDiscr;

PROCEDURE SetFGColorCont (col1: R.T; ) =
  BEGIN
    PLPlotRaw.plcol1(col1);
  END SetFGColorCont;

PROCEDURE PlotContour (READONLY z             : M.TBody;
                                kx, lx, ky, ly: INTEGER;
                       READONLY x             : V.TBody;
                                pltr          : CallbackM3Proc;
                                OBJECT_DATA   : REFANY;         ) =
  VAR
    arg1: REF ARRAY OF ADDRESS;
    nx                         := NUMBER(z);
    ny                         := NUMBER(z[0]);
    n                          := NUMBER(x);
  BEGIN
    arg1 := NEW(REF ARRAY OF ADDRESS, NUMBER(z));
    FOR i := 0 TO LAST(z) DO arg1[i] := ADR(z[i, 0]) END;
    PLPlotRaw.plcont(arg1[0], nx, ny, kx, lx, ky, ly, x[0], n, CallbackM3,
                     NEW(REF CallbackM3Data, callback := pltr,
                         callbackData := OBJECT_DATA));
  END PlotContour;

PROCEDURE CopyStateFrom (iplsr, flags: INTEGER; ) =
  BEGIN
    PLPlotRaw.plcpstrm(iplsr, flags);
  END CopyStateFrom;

PROCEDURE ExitAll () =
  BEGIN
    PLPlotRaw.plend();
  END ExitAll;

PROCEDURE Exit () =
  BEGIN
    PLPlotRaw.plend1();
  END Exit;

PROCEDURE SetEnvironment (xmin, xmax, ymin, ymax: R.T;
                          just: AxesScaling := AxesScaling.independent;
                          axis: TileSet := TileSet{Tile.box, Tile.ticks}; ) =
  VAR arg6: C.int;
  BEGIN
    IF axis = TileSet{} THEN
      arg6 := -2;
    ELSIF axis = TileSet{Tile.box} THEN
      arg6 := -1;
    ELSE
      arg6 := 0;
      IF Tile.xTicksLog IN axis THEN INC(arg6, 10); END;
      IF Tile.yTicksLog IN axis THEN INC(arg6, 20); END;
      axis := axis - TileSet{Tile.xTicksLog, Tile.yTicksLog};
      IF axis = TileSet{Tile.box, Tile.ticks} THEN
        INC(arg6, 0);
      ELSIF axis = TileSet{Tile.box, Tile.ticks, Tile.axes} THEN
        INC(arg6, 1);
      ELSIF axis = TileSet{Tile.box, Tile.ticks, Tile.axes, Tile.gridMajor} THEN
        INC(arg6, 2);
      ELSIF axis = TileSet{Tile.box, Tile.ticks, Tile.axes, Tile.gridMajor,
                           Tile.gridMinor} THEN
        INC(arg6, 3);
      ELSE
        <*ASSERT FALSE*>(*combination not supported by PLPlot :-( *)
      END;
    END;
    PLPlotRaw.plenv(xmin, xmax, ymin, ymax, ORD(just) - 1, arg6);
  END SetEnvironment;

PROCEDURE StopPage () =
  BEGIN
    PLPlotRaw.pleop();
  END StopPage;

PROCEDURE PlotErrorX (READONLY xmin, xmax, y: V.TBody; )
  RAISES {NA.Error} =
  VAR n := NUMBER(xmin);
  BEGIN
    IF NUMBER(xmax) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plerrx(n, xmin[0], xmax[0], y[0]);
  END PlotErrorX;

PROCEDURE PlotErrorY (READONLY x, ymin, ymax: V.TBody; )
  RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(ymin) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(ymax) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plerry(n, x[0], ymin[0], ymax[0]);
  END PlotErrorY;

PROCEDURE AdvanceFamily () =
  BEGIN
    PLPlotRaw.plfamadv();
  END AdvanceFamily;

PROCEDURE FillPolygon (READONLY x, y: V.TBody; ) RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plfill(n, x[0], y[0]);
  END FillPolygon;

PROCEDURE FillPolygon3D (READONLY x, y, z: V.TBody; ) RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plfill3(n, x[0], y[0], z[0]);
  END FillPolygon3D;

PROCEDURE Flush () =
  BEGIN
    PLPlotRaw.plflush();
  END Flush;

PROCEDURE SetFont (ifont: INTEGER; ) =
  BEGIN
    PLPlotRaw.plfont(ifont);
  END SetFont;

PROCEDURE LoadFont (fnt: INTEGER; ) =
  BEGIN
    PLPlotRaw.plfontld(fnt);
  END LoadFont;

PROCEDURE GetCharacterHeight (): GetCharacterHeightResult =
  VAR result: GetCharacterHeightResult;
  BEGIN
    PLPlotRaw.plgchr(result.def, result.ht);
    RETURN result;
  END GetCharacterHeight;

PROCEDURE GetFGColorDiscrRGB (icol0: INTEGER; ): GetFGColorDiscrRGBResult =
  VAR
    result: GetFGColorDiscrRGBResult;
    arg2  : C.int;
    arg3  : C.int;
    arg4  : C.int;
  BEGIN
    PLPlotRaw.plgcol0(icol0, arg2, arg3, arg4);
    result.r := arg2;
    result.g := arg3;
    result.b := arg4;
    RETURN result;
  END GetFGColorDiscrRGB;

PROCEDURE GetBGColorDiscrRGB (): GetBGColorDiscrRGBResult =
  VAR
    result: GetBGColorDiscrRGBResult;
    arg1  : C.int;
    arg2  : C.int;
    arg3  : C.int;
  BEGIN
    PLPlotRaw.plgcolbg(arg1, arg2, arg3);
    result.r := arg1;
    result.g := arg2;
    result.b := arg3;
    RETURN result;
  END GetBGColorDiscrRGB;

PROCEDURE GetCompression (): INTEGER =
  VAR
    compression: INTEGER;
    arg1       : C.int;
  BEGIN
    PLPlotRaw.plgcompression(arg1);
    compression := arg1;
    RETURN compression;
  END GetCompression;

PROCEDURE GetWindowDevice (): GetWindowDeviceResult =
  VAR result: GetWindowDeviceResult;
  BEGIN
    PLPlotRaw.plgdidev(result.mar, result.aspect, result.jx, result.jy);
    RETURN result;
  END GetWindowDevice;

PROCEDURE GetOrientation (): R.T =
  VAR rot: R.T;
  BEGIN
    PLPlotRaw.plgdiori(rot);
    RETURN rot;
  END GetOrientation;

PROCEDURE GetWindowPlot (): GetWindowPlotResult =
  VAR result: GetWindowPlotResult;
  BEGIN
    PLPlotRaw.plgdiplt(result.xmin, result.ymin, result.xmax, result.ymax);
    RETURN result;
  END GetWindowPlot;

PROCEDURE GetFamilyFile (): GetFamilyFileResult =
  VAR
    result: GetFamilyFileResult;
    arg1  : C.int;
    arg2  : C.int;
    arg3  : C.int;
  BEGIN
    PLPlotRaw.plgfam(arg1, arg2, arg3);
    result.fam := arg1;
    result.num := arg2;
    result.bmax := arg3;
    RETURN result;
  END GetFamilyFile;

PROCEDURE GetRunLevel (): INTEGER =
  VAR
    level: INTEGER;
    arg1 : C.int;
  BEGIN
    PLPlotRaw.plglevel(arg1);
    level := arg1;
    RETURN level;
  END GetRunLevel;

PROCEDURE GetOutputDeviceParam (): GetOutputDeviceParamResult =
  VAR
    result: GetOutputDeviceParamResult;
    arg3  : C.int;
    arg4  : C.int;
    arg5  : C.int;
    arg6  : C.int;
  BEGIN
    PLPlotRaw.plgpage(result.xp, result.yp, arg3, arg4, arg5, arg6);
    result.xleng := arg3;
    result.yleng := arg4;
    result.xoff := arg5;
    result.yoff := arg6;
    RETURN result;
  END GetOutputDeviceParam;

PROCEDURE ShowGraphicScreen () =
  BEGIN
    PLPlotRaw.plgra();
  END ShowGraphicScreen;

PROCEDURE GetBoundaries (): GetBoundariesResult =
  VAR result: GetBoundariesResult;
  BEGIN
    PLPlotRaw.plgspa(result.xmin, result.xmax, result.ymin, result.ymax);
    RETURN result;
  END GetBoundaries;

PROCEDURE GetStream (): INTEGER =
  VAR
    strm: INTEGER;
    arg1: C.int;
  BEGIN
    PLPlotRaw.plgstrm(arg1);
    strm := arg1;
    RETURN strm;
  END GetStream;

PROCEDURE GetVPBoundDev (): GetVPBoundDevResult =
  VAR result: GetVPBoundDevResult;
  BEGIN
    PLPlotRaw.plgvpd(result.xmin, result.xmax, result.ymin, result.ymax);
    RETURN result;
  END GetVPBoundDev;

PROCEDURE GetVPBoundWorld (): GetVPBoundWorldResult =
  VAR result: GetVPBoundWorldResult;
  BEGIN
    PLPlotRaw.plgvpw(result.xmin, result.xmax, result.ymin, result.ymax);
    RETURN result;
  END GetVPBoundWorld;

PROCEDURE GetXLabelParam (): GetXLabelParamResult =
  VAR
    result: GetXLabelParamResult;
    arg1  : C.int;
    arg2  : C.int;
  BEGIN
    PLPlotRaw.plgxax(arg1, arg2);
    result.digmax := arg1;
    result.digits := arg2;
    RETURN result;
  END GetXLabelParam;

PROCEDURE GetYLabelParam (): GetYLabelParamResult =
  VAR
    result: GetYLabelParamResult;
    arg1  : C.int;
    arg2  : C.int;
  BEGIN
    PLPlotRaw.plgyax(arg1, arg2);
    result.digmax := arg1;
    result.digits := arg2;
    RETURN result;
  END GetYLabelParam;

PROCEDURE GetZLabelParam (): GetZLabelParamResult =
  VAR
    result: GetZLabelParamResult;
    arg1  : C.int;
    arg2  : C.int;
  BEGIN
    PLPlotRaw.plgzax(arg1, arg2);
    result.digmax := arg1;
    result.digits := arg2;
    RETURN result;
  END GetZLabelParam;

PROCEDURE PlotHistogram (READONLY x             : V.TBody;
                                  datmin, datmax: R.T;
                                  nbin          : INTEGER;
                                  oldwin        : INTEGER   := 0; ) =
  VAR n := NUMBER(x);
  BEGIN
    PLPlotRaw.plhist(n, x[0], datmin, datmax, nbin, oldwin);
  END PlotHistogram;

PROCEDURE SetColorHLS (h, l, s: R.T; ) =
  BEGIN
    PLPlotRaw.plhls(h, l, s);
  END SetColorHLS;

PROCEDURE Init () =
  BEGIN
    PLPlotRaw.plinit();
  END Init;

PROCEDURE PlotLineSegment (x1, y1, x2, y2: R.T; ) =
  BEGIN
    PLPlotRaw.pljoin(x1, y1, x2, y2);
  END PlotLineSegment;

PROCEDURE SetLabels (xlabel, ylabel, tlabel: TEXT; ) =
  VAR
    arg1: C.char_star;
    arg2: C.char_star;
    arg3: C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(xlabel);
    arg2 := M3toC.SharedTtoS(ylabel);
    arg3 := M3toC.SharedTtoS(tlabel);
    PLPlotRaw.pllab(arg1, arg2, arg3);
    M3toC.FreeSharedS(xlabel, arg1);
    M3toC.FreeSharedS(ylabel, arg2);
    M3toC.FreeSharedS(tlabel, arg3);
  END SetLabels;

PROCEDURE SetLightPos (x, y, z: R.T; ) =
  BEGIN
    PLPlotRaw.pllightsource(x, y, z);
  END SetLightPos;

PROCEDURE PlotLines (READONLY x, y: V.TBody; ) RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plline(n, x[0], y[0]);
  END PlotLines;

PROCEDURE PlotLines3D (READONLY x, y, z: V.TBody; ) RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plline3(n, x[0], y[0], z[0]);
  END PlotLines3D;

PROCEDURE SetLineStyle (lin: [LineStyle.continuous .. LAST(LineStyle)]; ) =
  BEGIN
    PLPlotRaw.pllsty(ORD(lin));
  END SetLineStyle;

PROCEDURE PlotMesh (READONLY x, y: V.TBody;
                    READONLY z   : M.TBody;
                             opt : INTEGER; ) RAISES {NA.Error} =
  VAR
    nx                         := NUMBER(x);
    ny                         := NUMBER(y);
    arg3: REF ARRAY OF ADDRESS;
  BEGIN
    IF NUMBER(z) # nx THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z[0]) # ny THEN RAISE NA.Error(NA.Err.bad_size) END;
    arg3 := NEW(REF ARRAY OF ADDRESS, NUMBER(z));
    FOR i := 0 TO LAST(z) DO arg3[i] := ADR(z[i, 0]) END;
    PLPlotRaw.plmesh(x[0], y[0], arg3[0], nx, ny, opt);
  END PlotMesh;

PROCEDURE PlotMeshColored (READONLY x, y  : V.TBody;
                           READONLY z     : M.TBody;
                                    opt   : INTEGER;
                           READONLY clevel: V.TBody; ) RAISES {NA.Error} =
  VAR
    nx                         := NUMBER(x);
    ny                         := NUMBER(y);
    arg3: REF ARRAY OF ADDRESS;
    n                          := NUMBER(clevel);
  BEGIN
    IF NUMBER(z) # nx THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z[0]) # ny THEN RAISE NA.Error(NA.Err.bad_size) END;
    arg3 := NEW(REF ARRAY OF ADDRESS, NUMBER(z));
    FOR i := 0 TO LAST(z) DO arg3[i] := ADR(z[i, 0]) END;
    PLPlotRaw.plmeshc(x[0], y[0], arg3[0], nx, ny, opt, clevel[0], n);
  END PlotMeshColored;

PROCEDURE CreateStream (): INTEGER =
  VAR
    strm: INTEGER;
    arg1: C.int;
  BEGIN
    PLPlotRaw.plmkstrm(arg1);
    strm := arg1;
    RETURN strm;
  END CreateStream;

PROCEDURE PrintTextVP (side: TEXT; disp, pos, just: R.T; text: TEXT; ) =
  VAR
    arg1: C.char_star;
    arg5: C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(side);
    arg5 := M3toC.SharedTtoS(text);
    PLPlotRaw.plmtex(arg1, disp, pos, just, arg5);
    M3toC.FreeSharedS(side, arg1);
    M3toC.FreeSharedS(text, arg5);
  END PrintTextVP;

PROCEDURE Plot3D (READONLY x, y     : V.TBody;
                  READONLY z        : M.TBody;
                           opt, side: INTEGER; ) RAISES {NA.Error} =
  VAR
    nx                         := NUMBER(x);
    ny                         := NUMBER(y);
    arg3: REF ARRAY OF ADDRESS;
  BEGIN
    IF NUMBER(z) # nx THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z[0]) # ny THEN RAISE NA.Error(NA.Err.bad_size) END;
    arg3 := NEW(REF ARRAY OF ADDRESS, NUMBER(z));
    FOR i := 0 TO LAST(z) DO arg3[i] := ADR(z[i, 0]) END;
    PLPlotRaw.plot3d(x[0], y[0], arg3[0], nx, ny, opt, side);
  END Plot3D;

PROCEDURE Plot3DC (READONLY x, y  : V.TBody;
                   READONLY z     : M.TBody;
                            opt   : INTEGER;
                   READONLY clevel: V.TBody; ) RAISES {NA.Error} =
  VAR
    nx                         := NUMBER(x);
    ny                         := NUMBER(y);
    arg3: REF ARRAY OF ADDRESS;
    n                          := NUMBER(clevel);
  BEGIN
    IF NUMBER(z) # nx THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z[0]) # ny THEN RAISE NA.Error(NA.Err.bad_size) END;
    arg3 := NEW(REF ARRAY OF ADDRESS, NUMBER(z));
    FOR i := 0 TO LAST(z) DO arg3[i] := ADR(z[i, 0]) END;
    PLPlotRaw.plot3dc(x[0], y[0], arg3[0], nx, ny, opt, clevel[0], n);
  END Plot3DC;

PROCEDURE Surface3D (READONLY x, y  : V.TBody;
                     READONLY z     : M.TBody;
                              opt   : INTEGER;
                     READONLY clevel: V.TBody; ) RAISES {NA.Error} =
  VAR
    nx                         := NUMBER(x);
    ny                         := NUMBER(y);
    arg3: REF ARRAY OF ADDRESS;
    n                          := NUMBER(clevel);
  BEGIN
    IF NUMBER(z) # nx THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z[0]) # ny THEN RAISE NA.Error(NA.Err.bad_size) END;
    arg3 := NEW(REF ARRAY OF ADDRESS, NUMBER(z));
    FOR i := 0 TO LAST(z) DO arg3[i] := ADR(z[i, 0]) END;
    PLPlotRaw.plsurf3d(x[0], y[0], arg3[0], nx, ny, opt, clevel[0], n);
  END Surface3D;

PROCEDURE SetFillPattern (READONLY inc, del: ARRAY OF INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(inc);
  BEGIN
    IF NUMBER(del) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plpat(n, inc[0], del[0]);
  END SetFillPattern;

PROCEDURE PlotPoints (READONLY x, y: V.TBody; code: INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plpoin(n, x[0], y[0], code);
  END PlotPoints;

PROCEDURE PlotPoints3D (READONLY x, y, z: V.TBody; code: INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plpoin3(n, x[0], y[0], z[0], code);
  END PlotPoints3D;

PROCEDURE PlotPolygon3D (READONLY x, y, z: V.TBody;
                         READONLY draw   : ARRAY OF INTEGER;
                                  flag   : INTEGER;          )
  RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(z) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(draw) # n - 1 THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plpoly3(n, x[0], y[0], z[0], draw[0], flag);
  END PlotPolygon3D;

PROCEDURE SetLabelPrecision (setp, prec: INTEGER; ) =
  BEGIN
    PLPlotRaw.plprec(setp, prec);
  END SetLabelPrecision;

PROCEDURE SetFillStyle (patt: INTEGER; ) =
  BEGIN
    PLPlotRaw.plpsty(patt);
  END SetFillStyle;

PROCEDURE PrintTextWorld (x, y, dx, dy, just: R.T; text: TEXT; ) =
  VAR arg6: C.char_star;
  BEGIN
    arg6 := M3toC.SharedTtoS(text);
    PLPlotRaw.plptex(x, y, dx, dy, just, arg6);
    M3toC.FreeSharedS(text, arg6);
  END PrintTextWorld;

PROCEDURE Replot () =
  BEGIN
    PLPlotRaw.plreplot();
  END Replot;

PROCEDURE SetCharacterHeight (def, scale: R.T; ) =
  BEGIN
    PLPlotRaw.plschr(def, scale);
  END SetCharacterHeight;

PROCEDURE SetColorMapDiscr (READONLY r, g, b: ARRAY OF INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(r);
  BEGIN
    IF NUMBER(g) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(b) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plscmap0(r[0], g[0], b[0], n);
  END SetColorMapDiscr;

PROCEDURE SetColorMapDiscrSize (ncol0: INTEGER; ) =
  BEGIN
    PLPlotRaw.plscmap0n(ncol0);
  END SetColorMapDiscrSize;

PROCEDURE SetColorMapCont (READONLY r, g, b: ARRAY OF INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(r);
  BEGIN
    IF NUMBER(g) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(b) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plscmap1(r[0], g[0], b[0], n);
  END SetColorMapCont;

PROCEDURE SetColorCont (         itype                      : INTEGER;
                        READONLY pos, coord1, coord2, coord3: V.TBody;
                        READONLY rev: ARRAY OF INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(pos);
  BEGIN
    IF NUMBER(coord1) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(coord2) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(coord3) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    IF NUMBER(rev) # n - 1 THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plscmap1l(
      itype, n, pos[0], coord1[0], coord2[0], coord3[0], rev[0]);
  END SetColorCont;

PROCEDURE SetColorMapContSize (ncol1: INTEGER; ) =
  BEGIN
    PLPlotRaw.plscmap1n(ncol1);
  END SetColorMapContSize;

PROCEDURE SetColorRGB (icol0, r, g, b: INTEGER; ) =
  BEGIN
    PLPlotRaw.plscol0(icol0, r, g, b);
  END SetColorRGB;

PROCEDURE SetBGColor (r, g, b: INTEGER; ) =
  BEGIN
    PLPlotRaw.plscolbg(r, g, b);
  END SetBGColor;

PROCEDURE ToggleColor (color: INTEGER; ) =
  BEGIN
    PLPlotRaw.plscolor(color);
  END ToggleColor;

PROCEDURE SetCompression (compression: INTEGER; ) =
  BEGIN
    PLPlotRaw.plscompression(compression);
  END SetCompression;

PROCEDURE SetDevice (devname: TEXT; ) =
  VAR arg1: C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(devname);
    PLPlotRaw.plsdev(arg1);
    M3toC.FreeSharedS(devname, arg1);
  END SetDevice;

PROCEDURE SetWindowDevice (mar, aspect, jx, jy: R.T; ) =
  BEGIN
    PLPlotRaw.plsdidev(mar, aspect, jx, jy);
  END SetWindowDevice;

PROCEDURE LoadTransformation (dimxmin, dimxmax, dimymin, dimymax: INTEGER;
                              dimxpmm, dimypmm                  : R.T;     ) =
  BEGIN
    PLPlotRaw.plsdimap(
      dimxmin, dimxmax, dimymin, dimymax, dimxpmm, dimypmm);
  END LoadTransformation;

PROCEDURE SetOrientation (rot: R.T; ) =
  BEGIN
    PLPlotRaw.plsdiori(rot);
  END SetOrientation;

PROCEDURE SetWindowPlot (xmin, ymin, xmax, ymax: R.T; ) =
  BEGIN
    PLPlotRaw.plsdiplt(xmin, ymin, xmax, ymax);
  END SetWindowPlot;

PROCEDURE ZoomWindow (xmin, ymin, xmax, ymax: R.T; ) =
  BEGIN
    PLPlotRaw.plsdiplz(xmin, ymin, xmax, ymax);
  END ZoomWindow;

PROCEDURE SetEscapeChar (esc: CHAR; ) =
  BEGIN
    PLPlotRaw.plsesc(ORD(esc));
  END SetEscapeChar;

PROCEDURE SetOption (opt, optarg: TEXT; ): INTEGER =
  VAR
    arg1  : C.char_star;
    arg2  : C.char_star;
    result: INTEGER;
  BEGIN
    arg1 := M3toC.SharedTtoS(opt);
    arg2 := M3toC.SharedTtoS(optarg);
    result := PLPlotRaw.plsetopt(arg1, arg2);
    M3toC.FreeSharedS(opt, arg1);
    M3toC.FreeSharedS(optarg, arg2);
    RETURN result;
  END SetOption;

PROCEDURE SetFamilyFile (fam, num, bmax: INTEGER; ) =
  BEGIN
    PLPlotRaw.plsfam(fam, num, bmax);
  END SetFamilyFile;

PROCEDURE SetFileName (fnam: TEXT; ) =
  VAR arg1: C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(fnam);
    PLPlotRaw.plsfnam(arg1);
    M3toC.FreeSharedS(fnam, arg1);
  END SetFileName;

PROCEDURE ShadeRegions (READONLY a                     : M.TBody;
                                 xmin, xmax, ymin, ymax: R.T;
                        READONLY x                     : V.TBody;
                        fill_width, cont_color, cont_width, rectangular: INTEGER;
                        pltr       : CallbackM3Proc;
                        OBJECT_DATA: REFANY;         ) =
  VAR
    arg1: REF ARRAY OF ADDRESS;
    nx                         := NUMBER(a);
    ny                         := NUMBER(a[0]);
    n                          := NUMBER(x);
  BEGIN
    arg1 := NEW(REF ARRAY OF ADDRESS, NUMBER(a));
    FOR i := 0 TO LAST(a) DO arg1[i] := ADR(a[i, 0]) END;
    PLPlotRaw.plshades(
      arg1[0], nx, ny, NIL (*not yet supported*), xmin, xmax, ymin, ymax,
      x[0], n, fill_width, cont_color, cont_width,
      NIL (*not yet supported*), rectangular, CallbackM3,
      NEW(
        REF CallbackM3Data, callback := pltr, callbackData := OBJECT_DATA));
  END ShadeRegions;

PROCEDURE ShadeRegion (READONLY a: M.TBody;
                       left, right, bottom, top, shade_min, shade_max: R.T;
                       sh_cmap : INTEGER;
                       sh_color: R.T;
                       sh_width, min_color, min_width, max_color,
                         max_width, rectangular: INTEGER;
                       pltr       : CallbackM3Proc;
                       OBJECT_DATA: REFANY;         ) =
  VAR
    arg1: REF ARRAY OF ADDRESS;
    nx                         := NUMBER(a);
    ny                         := NUMBER(a[0]);
  BEGIN
    arg1 := NEW(REF ARRAY OF ADDRESS, NUMBER(a));
    FOR i := 0 TO LAST(a) DO arg1[i] := ADR(a[i, 0]) END;
    PLPlotRaw.plshade(
      arg1[0], nx, ny, NIL (*not yet supported*), left, right, bottom, top,
      shade_min, shade_max, sh_cmap, sh_color, sh_width, min_color,
      min_width, max_color, max_width, NIL (*not yet supported*),
      rectangular, CallbackM3, NEW(REF CallbackM3Data, callback := pltr,
                                   callbackData := OBJECT_DATA));
  END ShadeRegion;

PROCEDURE SetMajorTickSize (def, scale: R.T; ) =
  BEGIN
    PLPlotRaw.plsmaj(def, scale);
  END SetMajorTickSize;

PROCEDURE SetMinorTickSize (def, scale: R.T; ) =
  BEGIN
    PLPlotRaw.plsmin(def, scale);
  END SetMinorTickSize;

PROCEDURE SetGlobalOrientation (ori: INTEGER; ) =
  BEGIN
    PLPlotRaw.plsori(ori);
  END SetGlobalOrientation;

PROCEDURE SetOutputDeviceParam (xp, yp                  : R.T;
                                xleng, yleng, xoff, yoff: INTEGER; ) =
  BEGIN
    PLPlotRaw.plspage(xp, yp, xleng, yleng, xoff, yoff);
  END SetOutputDeviceParam;

PROCEDURE SetPause (pause: INTEGER; ) =
  BEGIN
    PLPlotRaw.plspause(pause);
  END SetPause;

PROCEDURE SetStream (strm: INTEGER; ) =
  BEGIN
    PLPlotRaw.plsstrm(strm);
  END SetStream;

PROCEDURE SetSubWindows (nx, ny: INTEGER; ) =
  BEGIN
    PLPlotRaw.plssub(nx, ny);
  END SetSubWindows;

PROCEDURE SetSymbolHeight (def, scale: R.T; ) =
  BEGIN
    PLPlotRaw.plssym(def, scale);
  END SetSymbolHeight;

PROCEDURE Start (nx, ny: INTEGER; ) =
  BEGIN
    PLPlotRaw.plstar(nx, ny);
  END Start;

PROCEDURE StartDev (devname: TEXT; nx, ny: INTEGER; ) =
  VAR arg1: C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(devname);
    PLPlotRaw.plstart(arg1, nx, ny);
    M3toC.FreeSharedS(devname, arg1);
  END StartDev;

PROCEDURE AddStripchartPoint (id, pen: INTEGER; x, y: R.T; ) =
  BEGIN
    PLPlotRaw.plstripa(id, pen, x, y);
  END AddStripchartPoint;

PROCEDURE CreateStripchart (xspec, yspec: TEXT;
                            xmin, xmax, xjump, ymin, ymax, xlpos, ylpos: R.T;
                            y_ascl, acc, colbox, collab: INTEGER;
                            READONLY colline, styline: ARRAY OF INTEGER;
                            VAR legline: ARRAY [0 .. 3] OF TEXT;
                            labx, laby, labtop: TEXT; ): INTEGER
  RAISES {NA.Error} =
  VAR
    id   : INTEGER;
    arg1 : C.int;
    arg2 : C.char_star;
    arg3 : C.char_star;
    n                                    := NUMBER(colline);
    arg17: ARRAY [0 .. 3] OF C.char_star;
    arg18: C.char_star;
    arg19: C.char_star;
    arg20: C.char_star;
  BEGIN
    TRY
      IF NUMBER(styline) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
      arg2 := M3toC.SharedTtoS(xspec);
      arg3 := M3toC.SharedTtoS(yspec);
      FOR i := FIRST(legline) TO LAST(legline) DO
        arg17[i] := M3toC.SharedTtoS(legline[i]);
      END;
      arg18 := M3toC.SharedTtoS(labx);
      arg19 := M3toC.SharedTtoS(laby);
      arg20 := M3toC.SharedTtoS(labtop);
      PLPlotRaw.plstripc(
        arg1, arg2, arg3, xmin, xmax, xjump, ymin, ymax, xlpos, ylpos,
        y_ascl, acc, colbox, collab, colline[0], styline[0], arg17, arg18,
        arg19, arg20);
      id := arg1;
    FINALLY
      M3toC.FreeSharedS(xspec, arg2);
      M3toC.FreeSharedS(yspec, arg3);
      FOR i := FIRST(legline) TO LAST(legline) DO
        M3toC.FreeSharedS(legline[i], arg17[i]);
      END;
      M3toC.FreeSharedS(labx, arg18);
      M3toC.FreeSharedS(laby, arg19);
      M3toC.FreeSharedS(labtop, arg20);
    END;
    RETURN id;
  END CreateStripchart;

PROCEDURE DeleteStripchart (id: INTEGER; ) =
  BEGIN
    PLPlotRaw.plstripd(id);
  END DeleteStripchart;

PROCEDURE SetNewLineStyle (READONLY mark, space: ARRAY OF INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(mark);
  BEGIN
    IF NUMBER(space) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plstyl(n, mark[0], space[0]);
  END SetNewLineStyle;

PROCEDURE SetVPAbsolute (xmin, xmax, ymin, ymax: R.T; ) =
  BEGIN
    PLPlotRaw.plsvpa(xmin, xmax, ymin, ymax);
  END SetVPAbsolute;

PROCEDURE SetXLabelParam (digmax, digits: INTEGER; ) =
  BEGIN
    PLPlotRaw.plsxax(digmax, digits);
  END SetXLabelParam;

PROCEDURE SetYLabelParam (digmax, digits: INTEGER; ) =
  BEGIN
    PLPlotRaw.plsyax(digmax, digits);
  END SetYLabelParam;

PROCEDURE PlotSymbols (READONLY x, y: V.TBody; code: INTEGER; )
  RAISES {NA.Error} =
  VAR n := NUMBER(x);
  BEGIN
    IF NUMBER(y) # n THEN RAISE NA.Error(NA.Err.bad_size) END;
    PLPlotRaw.plsym(n, x[0], y[0], code);
  END PlotSymbols;

PROCEDURE SetZLabelParam (digmax, digits: INTEGER; ) =
  BEGIN
    PLPlotRaw.plszax(digmax, digits);
  END SetZLabelParam;

PROCEDURE ShowTextScreen () =
  BEGIN
    PLPlotRaw.pltext();
  END ShowTextScreen;

PROCEDURE SetVPAspect (aspect: R.T; ) =
  BEGIN
    PLPlotRaw.plvasp(aspect);
  END SetVPAspect;

PROCEDURE CreateVPAspect (xmin, xmax, ymin, ymax, aspect: R.T; ) =
  BEGIN
    PLPlotRaw.plvpas(xmin, xmax, ymin, ymax, aspect);
  END CreateVPAspect;

PROCEDURE CreateVP (xmin, xmax, ymin, ymax: R.T; ) =
  BEGIN
    PLPlotRaw.plvpor(xmin, xmax, ymin, ymax);
  END CreateVP;

PROCEDURE SetStandardVP () =
  BEGIN
    PLPlotRaw.plvsta();
  END SetStandardVP;

PROCEDURE Init3DWindow (basex, basey, height, xmin0, xmax0, ymin0, ymax0,
                          zmin0, zmax0, alt, az: R.T; ) =
  BEGIN
    PLPlotRaw.plw3d(basex, basey, height, xmin0, xmax0, ymin0, ymax0,
                    zmin0, zmax0, alt, az);
  END Init3DWindow;

PROCEDURE SetPenWidth (width: INTEGER; ) =
  BEGIN
    PLPlotRaw.plwid(width);
  END SetPenWidth;

PROCEDURE SetWindow (xmin, xmax, ymin, ymax: R.T; ) =
  BEGIN
    PLPlotRaw.plwind(xmin, xmax, ymin, ymax);
  END SetWindow;

PROCEDURE SetXORMode (mode: BOOLEAN; ): BOOLEAN =
  VAR
    status: BOOLEAN;
    arg2  : C.int;
  BEGIN
    PLPlotRaw.plxormod(ORD(mode), arg2);
    status := arg2 # 0;
    RETURN status;
  END SetXORMode;

PROCEDURE ClearOpts () =
  BEGIN
    PLPlotRaw.plClearOpts();
  END ClearOpts;

PROCEDURE ResetOpts () =
  BEGIN
    PLPlotRaw.plResetOpts();
  END ResetOpts;

PROCEDURE SetUsage (program_string, usage_string: TEXT; ) =
  VAR
    arg1: C.char_star;
    arg2: C.char_star;
  BEGIN
    arg1 := M3toC.SharedTtoS(program_string);
    arg2 := M3toC.SharedTtoS(usage_string);
    PLPlotRaw.plSetUsage(arg1, arg2);
    M3toC.FreeSharedS(program_string, arg1);
    M3toC.FreeSharedS(usage_string, arg2);
  END SetUsage;

PROCEDURE OptUsage () =
  BEGIN
    PLPlotRaw.plOptUsage();
  END OptUsage;


BEGIN
END PLPlot.
