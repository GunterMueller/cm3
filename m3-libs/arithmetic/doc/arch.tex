\section{Library Architecture}


conventions:
quake templates, proc parameters
order of generic formals
common abbreviations of module names
module names (fraction of polynomials or polynomials of fractions?)
don't rely on order of field names, e.g. in TexStyle, FmtStyle

directory structure
structure of each module, common functions

\subsection{Directory structure}

\subsubsection{\filename{doc} - Documentation}

The library is documented with an analysis paper for each
implementation module.  Trivial implementations are not
discussed, but significant algorithms and design tradeoffs
are explained in considerable detail.  The idea is to
demonstrate independent development of the {\em code}, when
working from published algorithms which may have associated
copyrighted code in their own right.

A collection of stand-alone PDFs, one for each module,
can be generated with \shell{make sections}.

\subsubsection{\filename{src} - Library sources}

The library is divided into simple mathematical types
(integer, float, \dots)
and composed ones (complex numbers, polynomials, \dots).
Each type has its own directory containing modules
which follow the same guidelines.
Let's have a look to some files from the \filename{vector}
directory to illustrate that:\\
\begin{tabular}{lp{0.7\hsize}}
\filename{VectorBasic.ig}  & general basic routines \\
\filename{VectorBasic.mg}  & \\
\filename{VectorFast.ig}   & basic routines for built-in types \\
\filename{VectorFast.mg}   & \\
\filename{VectorFmtLex.ig} & formatting of vectors \\
\filename{VectorFmtLex.mg} & \\
\filename{m3makefile}      & quake code for this directory \\
\filename{vector.tmpl}     & quake templates for instantiating vectors of arbitrary types
\end{tabular}

The \filename{Fast} versions of some modules
was originally designed as workarounds for the missing
\sourcecode{<*INLINE*>} support of the known Modula 3 compilers.
In fact inlining is hard to implement in a compiler
so this pragma is accepted but ignored by all current
Modula 3 compilers.
Since these modules makes use of the infix operators
plus, minus, and so on,
they are instantiated for floating point types only.
Later they were also extended by specific numerical code.

\subsubsection{\filename{test} - Test suite}

The test suite is composed of a general driver and a
collection of test modules, one for each implementation
module.
Names of test modules are composed from the string \filename{Test}
and the type name, e.g. \filename{TestVector}.


\subsection{Module Templates}

For \filename{m3na/src} there are
\filename{template.i3} and \filename{template.m3} which can be instantiated
by copying to and then replacing \sourcecode{XYZ} with the new module name.

For \filename{m3na/test/src} there is \filename{template.m3}
which can be similarly copied and
edited to make new test modules.
Also, that template has a \sourcecode{PROCEDURE TestABC} template.


\subsection{Algebraic structures}
When considering a set of (mathematical) objects
with operations that can be applied to them
and the characteristics that the operations offer
we talk about an algebraic structure.
Most of the data types that are implemented here
are algebraically rings.
For composed data types it is important to know
the capabilities that are required for the element types.

The most common operations are:\\
\begin{tabular}{lp{0.7\hsize}}
\sourcecode{New}     & make one \\
\sourcecode{Copy}    & given one, make another one \\
\sourcecode{Lex}     & make one by reading a text string (not implemented yet) \\
\sourcecode{Fmt}     & use one to make a text string \\
\sourcecode{Compare} & relational operators (can be provided only by ordered types) \\
\sourcecode{Add},
\sourcecode{Sub},
\sourcecode{Mul}     & basic operations that are supported by most types \\
\sourcecode{DivMod}  & sometimes a division is not possible, but the decomposition into a sum of a product and a remainder is possible in some way in most cases
\end{tabular}

All functions allocate new memory for their results.
This allows for easy functional
without worrying about temporary results.
It requires more allocation and deallocation operations
and more temporary memory consumption
but I hope that the garbage collector
can handle this efficiently.
This technique is more safe
because you can consider most datatypes as immutable,
that is the content of an object is not changed,
which removes the problems with functions with side effects.

In many cases the operations have neutral elements:\\
\begin{tabular}{lp{0.7\hsize}}
\sourcecode{Zero} & such that for all x holds \sourcecode{Add(Zero,x)=x} \\
\sourcecode{One}  & such that for all x holds \sourcecode{Mul(One,x)=x}
\end{tabular}

\subsection{Naming}

Some rules for chosing identifiers:
\begin{enumerate}
\item The main type is called \sourcecode{T} and
the module gets the name of the implemented data type.
Using qualified identifiers like \varid{Module}\sourcecode{.T}
makes clear what \sourcecode{T} actually means.
This follows the conventions of \filename{libm3}
and thus allows for generic templates.
\item Procedure names start with a capital letter.
\item Procedure arguments are mostly named
 \sourcecode{x}, \sourcecode{y} for easy Cut\&Copy.
\item When writing new procedures,
 look for similar ones in other modules
 for adapting argument order and naming.
\end{enumerate}

\subsection{Arrays}
An array is a collection of items, all of the same type,
which can be accessed by an index into the array.
Array types can be distinguished by their cell type.
Further on they could be distinguished by their meaning.
For example, a Vector is not really a general purpose array --
Instead, it has known operations such as dot product.
Similarly, a polynomial might be stored in an array,
but it has specific operations such as evaluation,
or differentation.

We could distinguish these special uses of arrays by
BRANDing them.  (I [HGG] tried that for a while.)
But it is convenient to allow structural type matching,
so that one "Fmt" command works for simple arrays
as well as Vectors and rows of Matrices.
Therefore all these types are being implemented as arrays.
Modula-3 provides several ways to
implement the concept of an array.
We are generally using dynamic arrays.
There is (or may be) some overhead for
dynamic linking, and some for allocation,
but the payoff in readability is high.

In a few cases (e.g., interpolation tables), we can expect
the array to be static or constant.  So the appropriate
formal is an open array.
If a dynamic array happens to be used as the actual parameter,
it can be dereferenced prior to the call:

\begin{tt} \begin{verbatim}
     y:=LongRealInterpolation.Linear(xarr^,yarr^,x);
\end{verbatim} \end{tt}

Modula-3's dynamic arrays only range 0..n-1.
But many matrix notations call for 1..n or
perhaps some offset into the array.
The zero-based indexing has proven to be the most universal.
There is no support for other schemes.
