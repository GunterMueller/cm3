for myself:

todo:
  - separate generic GCD from integer module
  - physical units
  - combinatorics and number theory with bigintegers
    calculating binomial coefficients might be sped up by
    keeping a list of machine size integer factors
  - Bits, SLE (MatrixDecomposition), eigensystem, FFT (FourierTransform), Random/RNG01/RNG02, Root, Stat
  - ODE
  - (overflow check in integer modules)


for Harry:

 What's advantage of using REAL64 instead of LONGREAL and REAL32 instead of REAL?
 Why are there constants like 'Module' and 'ftn' ? Are they for documentation or  debugging purposes?
 truncation errors for div and abs in xCmplx, they cannot be resolved by extracting a factor; the only thing one can prevent are roundings to zero


for comp.lang.modula3 :

PROCEDURE Uniform(self:RandomGen;
                  min:REAL64:=0.0D0;  (*from min*)
                  max:REAL64:=1.0D0   (*up to but not including max*)
                  ):REAL64            (*return uniform deviate*)
                  (* RAISES{xUtils.Error} *)
                  =

METHODS
    uniform(min:REAL64:=Min;  (*from min*)
            max:REAL64:=Max   (*to max*)
              ):REAL64
              (*RAISES{xUtils.Error}*);        (*return uniform deviate*)

match, but if the RAISES statement is also given the compiler seems to see a difference in both declarations and thus outputs "procedure redefined (Uniform)"

may be that xUtils are not imported in one of these modules
 - the compiler complains about type incompabilities before knowing of the identifiers

---------------

It would be of great help, if the compiler tells me with which (implicitly given) declaration the new one conflicts and where it is was done, e.g.

"Rand.m3", line 123: procedure redefined (Uniform), in
"Rand.i3", line 234: defined as Uniform (blabla : TEXT)
exception list differs

When IMPORT is used after the first declaration,
the compiler should give a more precise error diagnostic.

Modula-3 definition says: MOD (x, y: Float) : Float
but cm3 expects: infix    MOD (x, y: Float) : Float

---------------

quake should complain about doubly given 'library' statement

---------------

TYPE
  RowBody    = ARRAY OF B.T;
  MatrixBody = ARRAY OF RowBody;

VAR
  mat : REF ARRAY OF ARRAY OF B.T;

BEGIN
  mat^ := MatrixBody{RowBody{B.Zero,B.One},RowBody{B.One,B.One}};


let the compiler abort without a meaningful error report

---------------

***
*** runtime error:
***    Exception "Convert.Failed" not in RAISES list
***    file "../src/fmtlex/Fmt.m3", line 292
***

this error is raised if one writes '%' instead of '%s'
in the format string of Fmt.FN

---------------

Design question:

Is it better to create a pair interface,module for every set of functions for the same datatype
or is it better to create one interface and multiple modules that export to this interface.
The reason is that I don't want to mix low level computation routines
with high level formatting routines.

---------------

Modules with computations of a different naming scheme:
m3core/fingerprint/Poly: Sum, Product, TimesX, Power
m3core/word/Word: Plus, Minus, Times, Divide
Point: Add, Sub, Mul, Div

---------------

Conventions for names of Array and Reference types?

List of conventions for names for modules, types, variables, constants, record entries, exceptions, order of procedure parameters

---------------

How can I access the name of a module that another module imports?
This is especially useful if you want to find out, with which module
a generic module was instantiated.
