%
% It is necessary to make Uwaitpid available via copying so that
% sysutils can reuse it, without becoming dependent on newer m3core.
% In the future, once bootstrapped, this can be reverted to "normal".
%

%
% This code is derived from Compiler.tmpl.
%

%------------------------------------------------------------------------------

proc WriteArrayToFile(Array, File) is
    %
    % Write to a temporary file first and cp_if, for correct incrementality.
    %
    if defined("_all") % What does this do?
        > File & ".tmp" in
            foreach Line in Array
                write (Line, CR)
            end
        end
        cp_if (File & ".tmp", File)
    end
end

%------------------------------------------------------------------------------

readonly proc MakeUwaitpid(Prefix) is

    readonly Uwaitpid_i3 = [
"(* Copyright (C) 1990, Digital Equipment Corporation           *)",
"(* All rights reserved.                                        *)",
"(* See the file COPYRIGHT for a full description.              *)",
"",
"INTERFACE " & Prefix & "Uwaitpid;",
"",
"FROM Utypes IMPORT pid_t;",
"FROM Ctypes IMPORT int;",
"IMPORT Ctypes;",
"",
"TYPE",
"  uint8_t = Ctypes.unsigned_char;",
"  uint16_t = Ctypes.unsigned_short;",
"",
"(* C waitpid returns a 32 bit integer that is a union",
"of a few forms, containing bit fields, crackable with macros.",
"The Modula-3 representation is historically endian-dependent",
"with regard to the bitfield layout, and system-dependent with",
"regard to the NOHANG flag.",
"",
"Here is a more portable version, implemented via a thin C wrapper.",
"",
"http://www.opengroup.org/onlinepubs/009695399/functions/waitpid.html",
"*)",
"",
"TYPE",
"    waitpid_status_t = RECORD",
"(*",
"    For reference, here is how I think to read bit fields.",
"    I have never seen this documented, but I experimented.",

"    RECORD",
"        a : BITS 1;",
"        b : BITS 29;",
"        c : BITS 2;",
"    END;",

"    --- BIG ENDIAN ---",
"        a: 1",
"        b: 4",
"        c: 0x80000000",
"    ",
"    --- LITTLE ENDIAN ---",
"        c: 1",
"        b: 2",
"        a: 0x80000000",
"",
"    w_A = BITS 32 FOR unsigned",
"",
"    --- BIG ENDIAN ---",
"",
"    terminated process status",
"    w_T = BITS 32 FOR RECORD",
"        w_Filler  : BITS 16 FOR [0..16_FFFF];",
"        w_Retcode : BITS  8 FOR [0..16_FF];  (* exit code if w_termsig == 0 *)",
"        w_Coredump: BITS  1 FOR [0..16_01];  (* core dump indicator *)",
"        w_Termsig : BITS  7 FOR [0..16_7F];  (* termination signal *)",
"    END;",
"",
"    stopped process status",
"    nobody uses this",
"    w_S = BITS 32 FOR RECORD",
"        w_Filler  : BITS 16 FOR [0..16_FFFF];",
"        w_Stopsig : BITS  8 FOR [0..16_FF];  (* signal that stopped us *)",
"        w_Stopval : BITS  8 FOR [0..16_FF];  (* == W_STOPPED if stopped *)",
"    END;",

"    (* M3 view of return code *)",
"    w_M3 = RECORD",
"        w_Filler  : BITS 16 FOR [0..16_FFFF];",
"        w_Coredump: BITS  1 FOR [0..16_01];  (* core dump indicator *)",
"        w_Termsig : BITS  7 FOR [0..16_7F];  (* termination signal *)",
"        w_Retcode : BITS  8 FOR [0..16_FF];  (* exit code if w_termsig == 0 *)",
"    END;",
"",
"    --- LITTLE ENDIAN ---",
"",
"    (* terminated process status *)",
"    w_T = RECORD",
"        w_Termsig : BITS  7 FOR [0..16_7F];  (* termination signal *)",
"        w_Coredump: BITS  1 FOR [0..16_01];  (* core dump indicator *)",
"        w_Retcode : BITS  8 FOR [0..16_FF];  (* exit code if w_termsig == 0 *)",
"        w_Filler  : BITS 16 FOR [0..16_FFFF];",
"    END;",
"",
"    (* M3 view of return code *)",
"    w_M3 = RECORD",
"        w_Retcode : BITS  8 FOR [0..16_FF];  (* exit code if w_termsig == 0 *)",
"        w_Termsig : BITS  7 FOR [0..16_7F];  (* termination signal *)",
"        w_Coredump: BITS  1 FOR [0..16_01];  (* core dump indicator *)",
"        w_Filler  : BITS 16 FOR [0..16_FFFF];",
"    END;",
"",
"    (* stopped process status *)",
"    w_S = RECORD",
"        w_Stopval : BITS  8 FOR [0..16_FF];  (* == W_STOPPED if stopped *)",
"        w_Stopsig : BITS  8 FOR [0..16_FF];  (* signal that stopped us *)",
"        w_Filler  : BITS 16 FOR [0..16_FFFF];",
"    END;",
"",
"    The layout is such that w_Filler is the most significant bits.",
"    w_Retcode is the least significant bits.",
"",
"    There is code that treats the M3 view as a 32bit integer,",
"    which is handled below with w_Loophole.",
"*)",
"        (* sort by size and then by name *)",

"        (* w_Coredump << 15 | w_Termsig << 8 | w_Retcode",
"         to replace the form LOOPHOLE(m3status, w_A) *)",
"        w_Loophole : uint16_t := 0;",
"",
"        (* boolean: WIFCONTINUED *) (* not used *)",
"        w_Continued : uint8_t := 0;",
"",
"        (* boolean: core dump indicator *)",
"        w_Coredump: uint8_t := 0;",
"",
"        (* boolean: WIFEXITED *) (* not used *)",
"        w_Exited  : uint8_t := 0;",
"",
"        (* exit code if w_termsig == 0 *)",
"        w_Retcode : uint8_t := 0;",
"",
"        (* These are not used. *)",
"        w_Signaled: uint8_t := 0; (* boolean: WIFSIGNALED *) (* not used *)",
"        w_Stopped : uint8_t := 0; (* boolean: WIFSTOPPED (aka Stopval aka W_STOPPED) *) (* not used *)",
"        w_Stopsig : uint8_t := 0; (* signal that stopped us *) (* not used *)",
"",
"        w_Termsig : uint8_t := 0; (* termination signal *)",
"  END;",
"",
"CONST",
"    WNOHANG = 1; (* flag to waitpid, can be defined arbitrarily, system-independent, C wrapper translates *)",
"",
"<*EXTERNAL " & Prefix & "m3_waitpid*>",
"PROCEDURE waitpid (pid: pid_t; (*out*) VAR status: waitpid_status_t; options: int := 0): pid_t;",
"",
"END " & Prefix & "Uwaitpid.",
    ]

%------------------------------------------------------------------------------

    readonly Uwaitpid_C = [
"",
"/* Copyright (C) 1990, Digital Equipment Corporation           */",
"/* All rights reserved.                                        */",
"/* See the file COPYRIGHT for a full description.              */",
"",

%
% Workaround Modula-3 lameness.
%
%"#include \"m3unix.h\"",
%
%h_source(ROOT & SL & "m3-libs" & SL & "m3core" & SL & "src" & SL & "unix" & SL & "Common" & SL & "m3unix")
%Fatal Error: duplicate unit: \cm3\pkg\m3core\src/unix/Common\m3unix.h C:\dev2\cm3.2\m3-libs\m3core\src\unix\Common\m3unix.h
%
"#include \"" & escape(ROOT & SL & "m3-libs" & SL & "m3core" & SL & "src" & SL & "unix" & SL & "Common" & SL & "m3unix.h") & "\"",

"#include <unistd.h>",
"#include <sys/wait.h>",
"#include <assert.h>",
"",
"typedef struct _m3_waitpid_status_t {",
"/* sort by size and then by name */",
"    UINT16 w_Loophole;",
"    UINT8  w_Continued;",
"    UINT8  w_Coredump;",
"    UINT8  w_Exited;",
"    UINT8  w_Retcode;",
"    UINT8  w_Signaled;",
"    UINT8  w_Stopped;",
"    UINT8  w_Stopsig;",
"    UINT8  w_Termsig;",
"} m3_waitpid_status_t;",
"",
"#define m3_WNOHANG 1",
"",
"pid_t",
Prefix & "m3_waitpid(",
"    pid_t pid,",
"    m3_waitpid_status_t* out_m3_status,",
"    int m3_options)",
"{",
"    pid_t pid_result = { 0 };",
"    unsigned status = { 0 };",
"    int options = { 0 };",
"    m3_waitpid_status_t m3_status = { 0 };",
"",
"    if (out_m3_status != NULL)",
"    {",
"       *out_m3_status = m3_status;",
"    }",
"",
"    if ((m3_options & m3_WNOHANG) != 0)",
"    {",
"        m3_options |= WNOHANG;",
"    }",
"",
"    pid_result = waitpid(pid, &status, options);",
"    if ((pid_result == 0) || (pid_result == -1) || (out_m3_status == NULL))",
"    {",
"        goto Exit;",
"    }",
"",
"/* Again, see http://www.opengroup.org/onlinepubs/009695399/functions/waitpid.html */",
"/* Or search the web for 'opengroup waitpid'. */",
"",
"    if (WIFEXITED(status))",
"    {",
"        assert(WEXITSTATUS(status) <= 0xFF);",
"        m3_status.w_Retcode = WEXITSTATUS(status);",
"        m3_status.w_Exited = 1;",
"    }",
"    else if (WIFSIGNALED(status))",
"    {",
"        assert(WTERMSIG(status) <= 0x7F);",
"        m3_status.w_Termsig = WTERMSIG(status);",
"        m3_status.w_Signaled = 1;",
"    }",
"    else if (WIFSTOPPED(status))",
"    {",
"        assert(WSTOPSIG(status) <= 0xFF);",
"        m3_status.w_Stopsig = WSTOPSIG(status);",
"        m3_status.w_Stopped = 1;",
"    }",
"#ifdef WIFCONTINUED /* Not all implementations support this */",
"    else if (WIFCONTINUED(status))",
"    {",
"        m3_status.w_Continued = 1;",
"    }",
"#endif",
"",
"#ifdef WCOREDUMP",
"    m3_status.w_Coredump = WCOREDUMP(status);",
"#endif",
"",
"    m3_status.w_Loophole = ((((UINT16) m3_status.w_Coredump) << 15) | (((UINT16) m3_status.w_Termsig) << 8) | ((UINT16) m3_status.w_Retcode));",
"",
"Exit:",
"    if (out_m3_status != NULL)",
"    {",
"       *out_m3_status = m3_status;",
"    }",
"    return pid_result;",
"}",
    ]

%------------------------------------------------------------------------------

    WriteArrayToFile(Uwaitpid_i3, Prefix & "Uwaitpid.i3")
    WriteArrayToFile(Uwaitpid_C, Prefix & "Uwaitpid.c")

    if Prefix
        derived_interface (Prefix & "Uwaitpid", HIDDEN)
        %
        %h_source(ROOT & SL & "m3-libs" & SL & "m3core" & SL & "src" & SL & "unix" & SL & "Common" & SL & "m3unix")
        %Fatal Error: duplicate unit: \cm3\pkg\m3core\src/unix/Common\m3unix.h C:\dev2\cm3.2\m3-libs\m3core\src\unix\Common\m3unix.h
        % lame. Therefore we fiddle with the #include in the source.
    else
        derived_interface (Prefix & "Uwaitpid", VISIBLE)
    end
    derived_c (Prefix & "Uwaitpid")
end

%------------------------------------------------------------------------------
