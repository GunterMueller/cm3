
SYNOPSIS

  prjm <option> <action> [ <pkgname>* ]

  <option> ::= [-v] [-q] [-qc] [-d] [-k] [-f] [-quietcache]
               [-m   | -md | -modifieddeps]
               [-o   | -od | -outofdatedeps]
               [-nd  | -nodep]
               [-noc | -nocache]
               [-novr]
               [-noivc | -nointernalvc | -nointernalversioncontrol]
               [-novc  | -noversioncontrol]     
               [-fr    | -forcerelease]
               [-lazy]
               [-dep]
               [-p <PrjDescFile>] 
               [-sd <snapshot dir>] 
               [-snapdir <snapshot dir>] 
               [-D name=value ]*
               [ (-message | -msg) <commit message>]
               [-file <commit message file>]
               [-t <tag1> [-t <tag2>]]
               [-changeset <changeset> | -cs <changeset>]
               [-relevancelevel <i> | -importlevel <i> | -irl <i>]
               [-nosort  | -byname  | -bydate ]
               [-reverse | -down ]
               [-saveprereleases | -saveall]

  <action> ::= -buildlocal              | -localbuild
            |  -buildproject            | -projectbuild
            |  -buildglobal             | -globalbuild
            |  -shiplocal               | -localship
            |  -shipproject             | -projectship
            |  -shipglobal              | -globalship
            |  -clean      
            |  -realclean
            |  -saveimports <n>         | -saveimps <n>     | -pkgovr <n>
            |  -diff
            |  -cdiff
            |  -udiff
            |  -check
            |  -check -label <regex> <n>*
            |  -newstatecache           | -newcache
            |  -purgeunsureversioninfo  | -purgeunsureinfo  | -pui
            |  -purgebuildinfo          | -purgebi          | -pbi
            |  -showpackages            | -showpkgs
            |  -showpackagekinds        | -showkinds        | -kinds
            |  -showsnapshots           | -showsnaps        | -snaps
            |  -showreleases            | -showrels         | -rels
            |  -showsnapshot [-l] <n>*  | -showsnap <n>*    | -ssnap <n>*
            |  -editsnapshot <n>        | -editsnap <n>     | -esnap <n>
            |  -snapshotlog [-mtime]    | -snaplog          | -ssl
            |  -showrelease [-l] <n>*   | -showrel <n>*     | -srel <n>*
            |  -editrelease <n>         | -editrel <n>      | -erel <n>
            |  -releaselog  [-mtime]    | -rellog           | -rl
            |  -export <name> <fn>      | -exp <name> <fn>
            |  -import <fn> <name>      | -imp <fn> <name>
            |  -showpackagepaths        | -showpkgpaths     | -spp
            |  -showstatecache          | -showcache        | -sc
            |  -showshortstatus         | -shortstatus      | -sstat
            |  -showlongstatus          | -longstatus       | -lstat
            |  -showchangesets          | -showcs           | -scs
            |  -changesetlog            | -cslog            | -csl
            |  -editchangeset           | -editcs           | -ecs
            |  -mergechangeset          | -mergecs          | -mcs
            |  -dependencies            | -showdeps         | -deps
            |  -updatesequence          | -upseq            | -tsort
            |  -builtokay               | -builtok          | -bok
            |  -isrelease               | -isrel            | -rel
            |  -ismodified              | -ismod            | -mod
            |  -showmodified            | -showmod          | -smod
            |  -isoutofdate             | -isood            | -ood
            |  -showoutofdate           | -showood          | -sood
            |  -hasconflicts            | -hascfl           | -cfl
            |  -showconflicts           | -showcfl          | -scfl
            |  -checkout                | -get              | -co
            |  -update                  | -upd              | -up
            |  -commit <t>              | -ci <t>
            |  -commitrelease <t>       | -commitrel <t>    | -cirel
            |  -commitlocal <t>         | -ciloc <t>        | -cil <t>
            |  -makesnapshot <n>        | -snapshot <n>     | -snap <n>
            |  -makerelease <n>         | -makerel <n>      | -release <n>
            |  -newrelease <t> <n>      | -newrel <t> <n>
            |  -applyaction <a>+        | -action <a>
            |  -orderedapplyaction <a>+ | -ordaction <a>
            |  -apply <cmd>             | -app <cmd>
            |  -ordapply <cmd>          | -oapp <cmd>
            |  -selectby <cmd>          | -sel <cmd>
            |  -ordselectby <cmd>       | -osel <cmd>
            |  -stablerelease <n> [<n>] | -makestable <n> [<n>] 
            |  -makestablerelease <n> [<n>] 
            |  -listpkgkinds            | -listkinds
            |  -dumppkgkinds            | -dumpkinds

  <t> ::= [ patch | minor | major ]
     type of commit: patch should be used if only bugs or misfeatures
     are corrected, minor if minor additions and extensions are committed,
     and major if any interface change or semantical change in exported
     functionality occured

  <n> ::= <token>
     name of release or snapshot

  <a> ::= <token> | <string>
     one symbolic action name from the backend configuration file

  <cmd> ::= <token> | <string> 
     one or more commands understood by the internal command interpreter
     or the external shell that is used

  -v  :    be verbose
  -q  :    be quiet
  -qc :    quiet cache (no `scanning...' messages)
  -k  :    do not stop on errors
  -f  :    do not stop on failures of external programs
  -m  :    use only locally modified packages
  -md :    use only locally modified packages and those depending
           on them (needed for selective builds)
  -o  :    use only out-of-date (elsewhere modified) packages
  -od :    use only out-of-date (elsewhere modified) packages and those
           depending on them (needed for selective builds)
  -nd :    do not recompute dependencies, if possible; use old
           dependency graph dump
  -dep:    consider all dependend packages, too
  -p  :    explicitly specify a project description file (default: PrjDesc)
  -sd :    explicitly specify a snapshot directory (default: snaps)
  -noc:    don't use any state cached in checkpoint files 
           (default: .checkpoint)
  -noivc:  don't use internal access to version control backend, exlusively
           rely on external programs defined in PkgBase.DefaultData
  -novc:   don't use version control for project and snapshot files
  -msg:    specify local commit message
  -file:   read local commit message from file
  -fr:     force release for all packages in -newrelease command
  -irl:    set the relevance level for generated import directives in
           PkgOvr files (0-3, deault: 2)
  -nosort: do not sort lists of snapshots, releases, or change sets
  -byname: sort lists of snapshots, releases, or change sets by name
  -bydate: sort lists of snapshots, releases, or change sets by date
  -down:   reverese the sort order of snapshots, releases, or change sets

  -snapdir       = -sd
  -nodep         = -nd
  -modifieddeps  = -md
  -outofdatedeps = -od
  -nocache       = -noc
  -nointernalvc  = -noivc
  -message       = -msg
  -forcerelease  = -fr
  -importlevel   = -irl
  -reverse       = -down

  -D name=value: define the value of the named variable. These values are
                 passed on to the execution of actions from 
                 PkgBase.DefaultData and are substituted if matching names
                 are found.

SEMANTICS

  Prjm is the project management tool of ComPact, a set of
  Comprehensive Package Management Tools, that are designed to
  facilitate the tasks of software development and software
  configuration management.

  Projects in ComPact are sets of `packages' that are contained in
  `collections' and may individually be built, shipped to different
  `pools' of packages, from where others may use (import) them,
  cleaned, committed to a version repository, and released. The task of
  complete package management for C/C++/Java is taken care of by `pkgm'. 
  The program `pkgvm' is a standalone version manager for C, C++, Modula-3,
  and other kinds of packages. Both pkgm and pkgvm work locally on one 
  package (like m3build and m3ship of the M3 build system). 

  Prjm is the program that applies actions to whole or partial
  projects. It is not concerned directly with any building, cleaning, or
  version control action, it rather relies on other tools to perform
  these tasks. Prjm controls the building, releasing, and
  reconstructing of potentially big sets of packages. To be able to
  perform these tasks, it has a configurable `front end' and `back
  end'. The `front end' is a `project description file', usually
  called PrjDesc, which contains simple declarations of the
  collections and packages of the project. The `back end' is a mapping
  from symbolic actions that prjm issues to concrete program
  invocations like the checkout of a package by pkgvm or building of a
  package via m3build or pkgm -build.

  Obviously, the project description file must be written and
  maintained by the user (the project manager), while the back end
  only needs to be extended or adapted to special uses if the default
  definitions are not sufficient. We will look at the front end, the
  back end, and the actions performed by prjm in turn.


  THE PROJECT DESCRIPTION FILE

  Here is the current project description file of prjm itself, which 
  is a program that consists of some Modula-3 packages:

    # The root where collections of packages are kept
    collectionroot ${PRJ_ROOT}
    # We use the variable PRJ_ROOT to keep the project description
    # flexible, so that every user can keep his package collections
    # whereever she/he likes.

    # Two package collections definitions, each consisting of a
    # symbolic name (e.g. libs) and a pathname (e.g. m3libs) under
    # which the collection can be found in the file system and the
    # version control repository:
    collection libs at m3libs
    collection progs at m3progs

    # Seventeen package definitions describe the complete project:
    package  pkg_base           in libs
    package  pkgversions        in libs
    package  prjbase            in libs
    package  miscutils          in libs
    package  depgraph           in libs
    package  m3tkutils          in libs
    package  fileinfo           in libs
    package  pkgconf            in libs
    package  regex              in libs
    package  tuple              in libs
    package  compactrc          in libs
    package  compact-copyright  in libs
    package  m3fix              in libs
    package  filepool           in libs
    package  miniscan           in libs
    package  pkg_vc             in libs
    package  prjm               in progs

  Please notice that each collection has a name and a location which
  is relative to the collection root, while each package has a name
  and a location that is relative to a collection.
  The declaration of collectionroot may contain the environment
  variables HOME, USER, and PRJ_ROOT, which are expanded according to
  their current value in the environment when prjm is run.

  A project description file may also contain `snapshot' and `release'
  declarations. Here are two examples:
  
    snapshot snap_prjm_0_5_FirstCompleteVersionWithProjectStateCache
      prjbase devel_prjbase_d11_0_0
      regex devel_regex_d2_0_0
      miscutils devel_miscutils_d16_0_0
      depgraph devel_depgraph_d2_0_2
      tuple devel_tuple_d0_1_2
      pkgversions devel_pkgversions_d4_0_0
      compactrc devel_compactrc_d8_1_1
      m3fix devel_m3fix_d3_0_2
      prjm devel_prjm_d9_1_1
      pkgconf devel_pkgconf_d16_2_0
      pkg_base devel_pkg=base_d21_0_0
      fileinfo devel_fileinfo_d2_0_0
      pkg_vc devel_pkg=vc_d25_0_12
      filepool devel_filepool_d1_0_3
      miniscan devel_miniscan_d2_0_1
      compact-copyright devel_compact-copyright_d1_1_1
      m3tkutils devel_m3tkutils_d0_0_2
    end

    release FirstWorkingPrjmRelease
      prjbase    release_prjbase_2_0_0
      miscutils  release_miscutils_3_4_0
      depgraph   release_depgraph_1_2_0
      pkg_config release_pkg=config_3_0_6
      prjm       release_prjm_2_4_1
      pkg_base   release_pkg=base_1_8_5
      fileinfo   release_fileinfo_0_0_0
      pkg_vc     release_pkg=vc_4_0_3
      m3tkutils  release_m3tkutils_0_0_0
    end

  Each snapshot and release delcaration contains a complete mapping
  from package names to `tags' which are like labels stuck to certain
  versions of packages and can be used to reconstruct the state of the
  package at a certain state of development. The release `FirstWorking-
  PrjmRelease' was done at an early time during the development and
  thus contains only nine packages.

  Usually snapshot and release delcarations are not entered manually
  into the project desription file PrjDesc, but are automatically
  generated by prjm. To be able to differentiate between user defined
  and generated declarations, there is a sub directory `snaps', in 
  which complete project descriptions with automatically generated
  snapshots reside.
  This sub directory is automagically updated by prjm each time a
  new snapshot or release is created. The project description file
  PrjDesc itself is never touched by prjm.


  BACK END CONFIGURATION

  The project manager reads the same global `compactrc' configuration
  resources as the package manager `pkgm', which are located using the
  bundled resources, the ComPact remote resource service, and local
  file resources. To learn more about the process of locating and
  evaluating these resources, type `pkgm -man'. 

  The most important resource for the project manager is called
  `PkgBase.DefaultData'. Like most other resources, first the bundled
  version is evaluated, then the project manager tries to retrieve a
  more recent version from the ComPact remote resource service, and
  last of all it is searched in the local file system using the
  directories defined in the `configpath'.

  The configuration consists of a list of `package kind' declarations
  which describe the structure of a software package and the actions
  associated with it. Here is the declaration that was used in release
  1.1 for DEC SRC Modula-3 packages:

  # DEC SRC Modula-3 packages
  pkgkind DEC_SRC_M3
    ostype "bsd|unix|linux" has file "src/m3makefile" and dir "src"
    action build       "m3build {?OPT} {?M3BUILDOPT} 2> .errors && m3err .errors"
    action buildlocal  "m3build {?OPT} {?M3BUILDOPT} -O  2> .errors && m3err .errors"
    action shipglobal  "m3ship {?OPT} {?M3SHIPOPT} 2> .errors && m3err .errors"
    action shipproject "m3ship {?OPT} {?M3SHIPOPT} 2> .errors && m3err .errors"
    action shiplocal   "echo no shipping needed"
    action clean       "m3build {?OPT} {?M3BUILDOPT} clean 2> .errors && m3err .errors"
    action realclean   "rm {?OPT} {?RMOPT} -f PkgDep PkgCDT PkgCRT .errors ; m3build clean"
    action mkdep       "m3dep {?OPT} > PkgDep ; m3ovr -v {:LOCATIONS} > src/m3overrides 2> /dev/null"
    action isrelease   "pkgvm {?OPT} {?PKGVMOPT} -isrelease > /dev/null"
    action conflicts   "pkgvm {?OPT} {?PKGVMOPT} -conflicts > /dev/null"
    action uptodate    "pkgvm {?OPT} {?PKGVMOPT} -uptodate > /dev/null"
    action modified    "pkgvm {?OPT} {?PKGVMOPT} -modified > /dev/null"

    action checkrelease         "pkgvm {?OPT} {?PKGVMOPT} -isrelease"
    action checkconflicts       "pkgvm {?OPT} {?PKGVMOPT} -conflicts"
    action checkuptodate        "pkgvm {?OPT} {?PKGVMOPT} -uptodate"
    action checkmodified        "pkgvm {?OPT} {?PKGVMOPT} -modified"
    action currentdeveltag      "pkgvm {?OPT} {?PKGVMOPT} -cdt > PkgCDT"
    action currentreleasetag    "pkgvm {?OPT} {?PKGVMOPT} -crt > PkgCRT"
    action currenttag           "pkgvm {?OPT} {?PKGVMOPT} -ct > PkgCT"
    action commitdevelmajor     "pkgvm {?OPT} {?PKGVMOPT} -commit major"
    action commitdevelminor     "pkgvm {?OPT} {?PKGVMOPT} -commit minor"
    action commitdevelpatch     "pkgvm {?OPT} {?PKGVMOPT} -commit patch"
    action commitreleasemajor   "pkgvm {?OPT} {?PKGVMOPT} -release major"
    action commitreleaseminor   "pkgvm {?OPT} {?PKGVMOPT} -release minor"
    action commitreleasepatch   "pkgvm {?OPT} {?PKGVMOPT} -release patch"
    action update               "pkgvm {?OPT} {?PKGVMOPT} -update {:TAG}"
    action checkout             "pkgvm {?OPT} {?PKGVMOPT} -c {!LOCATION} -checkout {!TAG} {!PKG}"
    action getlabel             "pkgvm {?OPT} {?PKGVMOPT} -getlabel {:TAG} > .label"
    action currentlabel         "pkgvm {?OPT} {?PKGVMOPT} -getlabel > .label"
    action setlabel             "pkgvm {?OPT} {?PKGVMOPT} -setlabel {!TAG} {!LABEL}"
    action listlabels           "pkgvm {?OPT} {?PKGVMOPT} -listlabels > .labels"


  This declaration introduces the package kind `DEC_SRC_M3', which can
  be identified by having a directory `src' that contains the file
  `m3makefile'. It then lists actions that may be applied to a package
  of this kind. Each action declaration must include a symbolic name
  and a list of commands that are appropriate to perform the
  action. Some actions may need parameters, which are enclosed in
  braces. Of course, the symbolic names of actions and parameters
  are those that are used by prjm and are hard-coded into its
  implementation. The corresponding command list can be configured as
  needed though. If no special shell is named for its execution (via
  the -sh option), prjm uses a simple internal command interpreter
  that just knows about redirection and serialization.

  Since early in the development of ComPact release 1.2, package kind
  definitions also support inheritance of predicates (single
  inheritance) and actions (multiple inheritance). This is
  accomplished with the keywords `inherit predicates' and `inherit
  actions' as in the following examples:

    pkgkind ComPacT_CC_UNIX
      ostype "bsd|unix|linux|sunos5" has dir "src" and dir "inc" and 
      dir "doc" and file "PkgDesc"
      inherit actions COMPACT_VC_UNIX_OVERRIDES
      inherit actions COMPACT_VC
      inherit actions COMPACT_BUILD

    pkgkind COMPACT_SIMPLE_UNIX
      ostype "bsd|unix|linux|sunos5"
      inherit predicates COMPACT_SIMPLE
      inherit actions COMPACT_VC_UNIX_OVERRIDES
      inherit actions COMPACT_SIMPLE

  Go on and list all the package kinds defined in the
  PkgBase.DefaultData resource by using the `-listkinds' command
  option.

  You should also have a look at the complete resource. Just type 
  `prjm -dumpkinds'. You will easily understand the package kind
  definitions and be able to construct your own. You can start by
  copying an existing definitions into a PkgBase.DefaultData file in
  the local resource path (`configpath'), renaming it and trying some
  changes. The project manager will pick up local file resources last
  and their definitions will override those contained in bundled or
  remote resources.

  There's just one more peculiarity that should be mentioned here: If
  you want to add a comment line, make sure it starts with a `#' and a
  blank ` '. Otherwise the parser won't recognize it as a comment.

  ACTIONS OF PROJECT MANAGEMENT

  Prjm can be used to check the current state of all packages that are
  part of a project, to freeze the current development state as a
  snapshot, to use the current development state for a release of the
  software, to build the complete project by building and shipping
  every package in the correct order defined by the import-relation of
  packages (which of course must not be cyclic), to checkout and
  rebuild a snapshot or release from the PrjDesc or the snapshot set, to
  apply user defined command sequences to all or some packages of a
  project, and to select packages of the project by internal or user
  defined command sequences.

  For some of these tasks, prjm needs to know about the dependencies
  of the packages and maintain a dependency graph (which is, once
  computed, saved in the file PrjDepGraph and may be reused), for
  other actions (like checkout or update) the order is irrelevant.

  -- CHECKING PROJECTS --

  Let's have a closer look at some of the actions:

  Once the project description file is written, you can check the
  existence, completeness, and homogeneity of the project by running
  `prjm -check'. This will tell you if all the packages are found, are
  of the same package kind, try to construct a dependency graph and
  finally report all packages that are used and found, and those that 
  are used (imported) but not listed in the project. (This may be
  completely okay, since they may be globally installed and never changed
  libraries and so outside the realm of ComPact's configuration
  management. Or, you may just have forgotten some :-)

  There are two more useful options: `prjm -showpackages' lists
  all the packages and the locations where they were found.

  `prjm -dependencies pkg_1 .. pkg_n' lists all the packages 
   that depend on packages pkg_1 to pkg_n.
  `prjm -dependencies' lists all packages and their dependencies.
  `prjm -updatesequence' lists the order by which the packages
   are processed (packages topologically sorted by dependencies).

  -- BUILDING --

  If everything is okay, you may then proceed to `build' your
  project. ComPact uses a three level hierarchy of compiled and
  installed packages: a `global pool', a `project pool', and a `local
  pool'. Packages installed in the global pool are for use by
  everybody, project pools are dedicated to certain projects, and each
  developer has her/his own private pool. The DEC SRC Modula-3 build
  system on the other hand uses only one global pool (though more
  sophisticated build systems are available). ComPact uses versioned
  installations of packages, that is, any pool may contain different
  compiled versions at the same time which may be referenced by their
  version in the `import'-statement, while the default DEC SRC pool
  can just contain one version at a time. Luckily, prjm may abstract
  from these differences and do its jobs (with some simplifications)
  for DEC SRC Modula-3 packages, ComPact's C and C++ (and soon Java)
  packages and probably for many more package kinds. For those who use
  the default SRC build system for Modula-3 (m3build and m3ship),
  ComPact's global and project pools are mapped to the system package
  pool (usually /usr/local/lib/m3/pkg), and the local pool is just the
  developers work space (no shipping needed). 

  According to the three level hierarchy, prjm knows the actions
  `buildlocal', `buildproject', and `buildglobal', which means compile
  all the packages locally and ship them to the local, project, or
  global package pool respectively. (For local builds with Modula-3,
  you need to write `m3override' files for each package.) If you build
  a project, you can use the following options to vary the behaviour: 

   -k   keeps prjm going if any build action exited with an error
        (exit code # 0)
   -f   keeps prjm going even if serious exceptions are encountered
   -v   lets prjm run more verbosely (it tells you exactly what it is
        doing)
   -m   directs prjm to consider only packages that are locally modified
   -md  tells prjm to consider all locally modified packages and those
        that depend on them (which may be quite a few more than you
        thought) 
   -o   directs prjm to consider only packages that are elsewhere modified,
        e.g. out-of-date after an appropriate update
   -od  tells prjm to consider all out-of-date packages and those
        that depend on them (which may be quite a few more than you
        thought) after an appropriate update
   -nd  tells prjm to use a previously saved dependency graph and not
        to recompute the package dependencies at each run (which is the
        default)
   -dep consider the packages named on the command line and those
        dependend on them for the build
   -noc don't use the state cached in checkpoint files

  You may also explicitly state the packages that are to be considered
  for the build on the command line, as you may do with every other
  action. 

  If prjm is used together with the ComPact Package Manager pkgm,
  it will be useful to not that the commands

    prjm -saveimports <snapshotname> <pkgs>*
    prjm -pkgovr <snapshotname> <pkgs>*

  will create PkgOvr files in the root of all (or all explicitly
  named) packages with import directives corresponding to the given
  snapshot or release name. These files include a statement of the
  form

    import(pkg, version)

  for every package dependency. Version is a ComPact version range
  denotation (allowing `x' for undefined elements) with three
  levels. How wide the range is is defined by the import relevance
  level, which can be set with the option -irl 0|1|2|3, and defaults
  to 2, which means that major and minor version number parts are
  relevant, but not patch levels.

  To be able to check if a previous built run has been successful, the
  following command has been introduced:

    prjm -builtokay

  -- CLEANING --

  To delete all derived files in your local workspace, use `prjm
  -clean'. To delete even more, use `prjm -realclean'.

  -- STATUS INFORMATION --

  You may want some information about the version control state of
  each package. To check what packages are locally modified, use `prjm
  -ismodified' which lists the modified packages. To check which
  packages are checked out as release, try `prjm -isrelease'. To show
  the locally modified files of each package, type `prjm
  -showmodified'. You may of course use the abbreviations listed in
  the synopsis section above for each command.

  To list all modifications of all the packages in your workspace as a
  (context or unified context) diff listing, use one of the following
  commands: 

    prjm -k -diff 
    prjm -k -cdiff 
    prjm -k -udiff 

  To list differences between the current version and some other
  named snapshot or release, you may use the -t option:

    prjm -k -diff  -t <snapshot1>
    prjm -k -cdiff -t <snapshot1>
    prjm -k -udiff -t <snapshot1>

  To list differences between two named snapshots or releases, just
  specify two -t options:

    prjm -k -diff  -t <snapshot1> -t <snapshot2>
    prjm -k -cdiff -t <snapshot1> -t <snapshot2>
    prjm -k -udiff -t <snapshot1> -t <snapshot2>

  You must be aware of the fact that different snapshots and releases
  may contain different sets of packages, and that the set of packages
  compared is always based of the contents of the current workspace.
  All packages that are not either in the current workspace or in one
  of the snapshots stated on the command line are not compared;
  instead prjm issues a message that some diffs may be missing.

  If you want to generate a diff listing of all the changes
  contained in a named change set, use one of the following commands:

    prjm -k -diff  -cs <changeset>
    prjm -k -cdiff -cs <changeset>
    prjm -k -udiff -cs <changeset>

  You may also obtain information about all snapshots or releases of a
  project by the commands

    prjm -showsnapshots
    prjm -showsrleases

  which list the names of all defined snapshots and releases. If you
  want you have a look at the actual configuration of a snapshot or a
  release, use

    prjm -showsnapshot snapshotname [ snapshotname2 [ ... ] ]
    prjm -showsrlease  releasename  [ releasename2  [ ... ] ]

  If you also specify the -l option, you will get yet more information
  from these commands.
  
  To view a complete log of all available information of snapshots or
  releases, use

    prjm -snapshotlog
    prjm -releaselog

  -- CHANGING CONFIGURATIONS, IMPORT AND EXPORT --

  It is also possible to change a snapshot or release description
  after its creation, though you should generally avoid this and
  rather create a new configuration, since the old information will be
  lost. Anyway, if you feel to extend the description of one of your
  snapshots or releases, you may use

    prjm -editsnapshot snapshotname
    prjm -editrelease  releasename

  Currently snapshot and release descriptions are stored in the
  `snaps' subdirectory of the project package in files with random
  names. Future versions will probably store all configuration meta
  information in a relational database. Anyway, snapshot descriptions
  can be exported into an oridnary text file with 

    prjm -export snapshot-or-release-name filename

  and imported from an ordinary text file with

    prjm -import filename snapshot-or-release-project-configuration

  -- SAVING LOCAL CHANGES --

  Currently the project directory with its snaps sub-directory
  is treated by ComPact as a special kind of package in order to
  save the changes made to the project description file and all
  snapshots. This information is version-control meta-data;
  there is only one ongoing line of development without any
  branches. The current version always contains all the information
  to create all former snapshots and releases.

  To commit local changes made to the project description file
  or other files that you may have chosen to keep next to your
  project description, use the command

    prjm -commitlocal major|minor|patch

  of course choosing only one of major, minor, or patch as the
  argument.

  -- GENERAL COMMAND APPLICATION --

  You may even want to apply some more complicated actions to the
  packages of your project, which may be done by `prjm -apply
  <action>', `prjm -ordapply <action>', `prjm -selectby <predicate
  action>', and `prjm -ordselectby <predicate action>'. The
  `apply'-commands are used if you are interested in the effects of
  your action to the packages, the `select'-options are used if you
  want prjm to apply some commands in order to select and list a
  number of packages. Here is an example:

    prjm -m -k -nodep -apply "cvs diff -bc"

  gives you a complete context diff of the changes you have made
  locally to your packages (if CVS is the version control back end,
  which currently is the only supported option for pkgvm and pkgm :-)

  To get some statistics about your project, you might want to use
  something like

    prjm -sh /bin/sh -k -apply "wc src/*.m3 src/*.i3"

  If you want to explicitly apply some of the actions defined in 
  the backend configuration file by their symbolic names, you can
  do this with the options `prjm -applyaction <symbolic name>' and
  `prjm -orderedapplyaction <symbolic name>'.

  -- COMMITTING CHANGES, CHANGE SETS --

  To commit all local modifications to your project to the version
  control repository, use 

    prjm -commit <commit type>

  where commit type can be `major', `minor', or `patch'. Usually, you
  would issue this action from inside a package while you are
  developing. All modifications will be checked in and automatically
  tagged, so your changes can be reproduced as a whole every time.

  To commit all your changes and mark the state as release, use 

    prjm -commitrelease <commit type>

  This changes the kind of tags that are supplied to release tags and
  automatically creates a `release branch' for every package. The
  release branches are used to maintain released code that is already
  shipped to vendors and to add patches to old revisions of your
  product.  Be careful with this option; it is likely that what you
  wanted to do was creating new releases for some packages and using
  old release branches for others.

  After `commitrelase' all the affected packages are updated to the
  corresponding release branch.

  With every commit action you may create a named `change set'. This
  is initiated by simply adding the intended change set name to the
  command after the -cs option:

    prjm -cs feature-foo -m -commit <commit type>

  This would check-in all modified packages and create a change set
  named `feature-foo'. A change set is defined as a set of packages
  with the state labels from before and after the change, together
  with an (optional) log message and a date. A named change set can be
  applied to other branches or states of a project. Change sets can be
  merged into the current workspace with the command

    prjm -mergechangeset <changeset>

  Change sets live in the snapshot directory next to snapshot and
  release definitions. They may also be edited manually with the
  command 

    prjm -editchangeset <changeset>

  To list all available change sets use

    prjm -showchangesets

  To view a complete log of all change sets use

    prjm -changesetlog

  Change set descriptions can be exported into an oridnary text file with 

    prjm -export change-set-name filename

  and imported from an ordinary text file with

    prjm -import filename change-set-name

  -- CREATING SNAPSHOTS AND RELEASES --

  If you want to freeze the current development state of your project
  into a snapshot, you can do so by issuing the command

    prjm -snapshot <snapshot name>

  Prjm will check if any package is locally modified (which must not
  be as all changes need to be checked in to be reproducible) and then
  record all the packages and the associated versions as a snapshot
  declaration in the `snaps' directory.

  Likewise, releases are produced by 

    prjm -release <release name>

  The difference to a snapshot is that every package must be checked
  out as a released version as a necessary precondition.

  If you want a release and haven't got released all of your packages,
  you can combine the -commitrelease and -release options by using
  
    prjm -newrelease <commit type> <release name>

  This command will by default create release branches for all packages
  that are not checked out on a release branch, and use existing release
  branches for others.

  If you additionally specify the -forcerelease option, prjm will
  create new release branches for all your packages.  Be careful with
  this option; it is likely that what you wanted to do was creating
  new releases for some packages and using old release branches for
  others.

  Unless -novr is specified, in every package root directory a
  PkgOvr file is created, which lists all the package imports with the
  corresponding versions. See the description of -saveimports above
  for further details. These files are created and then
  automatically added to version control and committed to the relevant
  branches. If these commits fail, no release configuration is saved.
  (At this point, prjm has already created an internal pre-release
  configuration, which will only be written to disk if you also
  specify -saveprereleases or -saveall.)

  The current version of prjm auto-commits all newly created
  snapshots and releases, unless the -noversioncontrol option is
  specified. That is, the project directory is considered as a
  package, the new snapshot description is added, and the changes
  are committed. 

  If you have a release you can create a named `stable release' based
  on it, that is, a mapping from package names to stable branch tags
  based on the frozen release. As an example let us suppose that you
  have created a release name my_release_1_0. You would now proceed
  with the command

    prjm -stablerelease my_release_1_0

  Prjm would now create a new release description named 
  my_release_1_0_stable, which would contain all the packages and
  tags from the base release, except that all patch levels of
  the release tags would be replaced by `stable'. You can think of
  stable releases as equivalent to the `head' tag: a stable release
  enables you to check out the latest versions of all packages
  of a project on stable branches.

  If you create a release, the project manager first checks if
  everything has been built successfully in your workspace. This is
  done via the builtok command specified in PkgBase.DefaultData for
  the corresponding package kind. If anything is found missing, the
  creation of the release is aborted. The check is not performed if
  the -force option is present.

  -- REPRODUCING SNAPSHOTS AND RELEASES --

  Every snapshot and release recorded in the PrjDesc file or the
  `snaps' directory may be reproduced at any time. You first need to 
  check out the complete snapshot or release from the vesion repository by

    prjm -checkout <release or snapshot name>
    prjm -checkout head

  Prjm will try to create all the collections and packages listed in
  your project file and defined by the snapshot or release
  declaration. If any version of the packages already exists, prjm will
  try to update it to the desired version. To test your release, you
  should of course start with an empty workspace (for exmaple by
  changing the `collectionroot' definition in the project file or
  altering the PRJ_ROOT variable, if it is included). If the special 
  name `head' is given, the current development versions from the main
  trunk will be checked out.

  If the checkout command is issued with more than one parameter,
  the first is considered to be version control tag name (in contrast
  to a snapshot name, which is a mapping from packages to version
  control tags), and all following parameters are treated as package
  names, which are then checked out with the given tag.

  You may then build the project for example by

    prjm -v -buildlocal

  if the build tools are configured for local building.

  -- PROJECT STATE CACHES --

  In order to speed up the building of projects and displaying
  information about the version control status of packages, prjm
  keeps a state cache (usually in the file .checkpoint). This
  cache contains `fingerprints' for all the packages (which are
  used to determine if anything in the package directory has
  changed since the last inspection) and a set of attributes
  which (when set) may be used to omit several time-consuming 
  operations. The setting of these attributes is carefully 
  controlled, and always chosen to be `on the safe side' for all
  attributes except those indicating `up-to-date' and
  `no conflicts'. To clean these cached attributes, you can use

    prjm -purgeunsureversioninfo

  This action will be executed by prjm anyway if you want to
  check for out-of-date and conflicting packages, unless the
  `-lazy' option is specified, too. (This is different from
  the behaviour of ComPactHTTPd.)

  Nonetheless, if you don't trust the cached information, you 
  can 

   o use the option -noc (-nocache) to forbid prjm to use the 
     cache,
   o execute

       prjm -newcache

     to clear the cache, or
   o just remove the .checkpoint file (prjm will create a fresh one).

  If you want to see the cache contents, you can either list or
  edit the file directly (it is plain ASCII text), or use the command

    prjm -showcache

  which also recomputes the saved fingerprints.

  If you want to see the status of all packages in a format
  that is easier to read, use

    prjm -shortstatus

  which displays a short status description for every package, which
  is essentially the information from the cache. If you specify
  the option `-longstatus', many more status attributes will be shown
  for every package.

  If you do not specify the -noc or -nocache option, the checkpoint
  file is read and evaluated prior to every action of prjm, and a new
  checkpoint is written after the completion of the action.

  You can use the options `-checkpointfile <fn>' and `-cpf <fn>'
  to specify a different name for the checkpoint file to be used.

  In combination with the verbose option `-v', prjm will tell
  you which actions are actually performed and which are ommitted
  due to cached information.

BUGS

 o Timestamps should be added to snapshots and releases as well as
   textual descriptions.

 o The internal command interpreter does not know about pipes and
   wildcard expansion. (External shells may be used instead.)

 o Many more useful and interesting commands can be thought of.

