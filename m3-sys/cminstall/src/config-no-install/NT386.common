%
% Copyright 1996-2000 Critical Mass, Inc. All rights reserved.
% See file COPYRIGHT-CMASS for details.
%
% Common parameterized configuration file for an x86 machine running Windows NT or perhaps Windows 95,

%-------------------------------------------------------------------
% defined by cm3, but not the other MxConfig users
if not defined("CR") CR = "\n" end
if not defined("EOL") EOL = "\n" end
if not defined("M3_PROFILING") M3_PROFILING = FALSE end
if not defined("SL") SL = "/" end

%-------------------------------------------------- compilation environment ---

readonly TARGET = "NT386"   % code generation target
readonly TARGET_ENDIAN = "LITTLE"   % { "BIG" OR "LITTLE" }
readonly TARGET_ARCH = "I386"
readonly WORD_SIZE = "32BITS"       % { "32BITS" or "64BITS" }

%------------------------------------------------------------------------------

include("cm3cfg.common")

%------------------------------------------------------------------------------

proc Path_GetLastElement (a) is
  local b = pos (a, "/")
  if equal (b, "-1")
    b = pos (a, "\\")
  end
  if not equal (b, "-1")
    a = sub (a, b, len (a))
    a = sub (a, 1, len (a))
    return Path_GetLastElement (a)
  end
  return a
end

proc Path_GetBase (a) is
  a = Path_GetLastElement (a)
  local b = pos (a, ".")
  if not equal (b, "-1")
    a = sub (a, 0, b)
  end
  return a
end

%------------------------------------------------------------------------------

% SYSTEM_LIBS provides a mapping from Modula-3 names for the common
% external libraries to site-dependent information about how they
% are accessed. If SYSTEM_LIBS{x} is defined it should be a list
% of linker arguments that are used when linking against that library.
% If SYSTEM_LIBS{x} is not defined, the Modula-3 system will assume
% that the library is not available.

%
% These are for the .libs that ship with the tools and thus not our choice.
%
readonly LibInPrefix  = { "MS" : "",          "GNU" : "-l"  }{LINKER} % aka TARGET_NAMING or OS_TYPE
readonly LibInSuffix  = { "MS" : ".lib",      "GNU" : ""    }{LINKER} % aka TARGET_NAMING or OS_TYPE
readonly LibPath      = { "MS" : "-libpath:", "GNU" : "-L"  }{LINKER}

if FALSE % If you want a Unixy file names for Cygwin

readonly TARGET_NAMING = {"WIN32" : "2", "POSIX" : "0" }{OS_TYPE}
%                                        object files       libraries
%  0=Unix                          =>  .o   .io    .mo       libXX.a
%  1=Unix with a grumpy C compiler =>  .o   _i.o   _m.o      libXX.a
%  2=Windows NT or Windows 95      =>  .obj .io    .mo       XX.lib

readonly LibOutPrefix = { "WIN32" : "",     "POSIX" : "lib" }{OS_TYPE} % aka TARGET_NAMING
readonly LibOutSuffix = { "WIN32" : ".lib", "POSIX" : ".a"  }{OS_TYPE} % aka TARGET_NAMING
readonly Obj          = { "WIN32" : ".obj", "POSIX" : ".o"  }{OS_TYPE} % aka TARGET_NAMING

FormatExe = { "WIN32" : "%s.exe", "POSIX" : "%s"      }{OS_TYPE} % aka TARGET_NAMING
readonly FormatLib = { "WIN32" : "%s.lib", "POSIX" : "lib%s.a" }{OS_TYPE} % aka TARGET_NAMING
readonly FormatDll = { "WIN32" : "%s.dll", "POSIX" : "lib%s.so"}{OS_TYPE} % aka TARGET_NAMING
% readonly FormatStandaloneLib = { "WIN32" : "%s.lib.sa", "POSIX" : "lib%s.a"}{OS_TYPE} % aka TARGET_NAMING

end

readonly TARGET_NAMING = "2"
%                                        object files       libraries
%  0=Unix                          =>  .o   .io    .mo       libXX.a
%  1=Unix with a grumpy C compiler =>  .o   _i.o   _m.o      libXX.a
%  2=Windows NT or Windows 95      =>  .obj .io    .mo       XX.lib

readonly LibOutPrefix = ""
readonly LibOutSuffix = ".lib"
readonly Obj          = ".obj"

FormatExe = "%s.exe"
readonly FormatLib = "%s.lib"
readonly FormatDll = "%s.dll"
% readonly FormatStandaloneLib = { "WIN32" : "%s.lib.sa", "POSIX" : "lib%s.a"}{OS_TYPE} % aka TARGET_NAMING

%------------------------------------------------------------------------------

local readonly proc LibOut(a) is
    return LibOutPrefix & a & LibOutSuffix
end

%------------------------------------------------------------------------------

local readonly proc LibIn(a) is
    return LibInPrefix & a & LibInSuffix
end

%------------------------------------------------------------------------------

%
% more unification is desirable here
%
SYSTEM_LIBS_MS =
{
    "LIBC" :
    [
        LibIn("winspool"),
        LibIn("comctl32"),
        LibIn("wsock32"),
        LibIn("comdlg32"),
        LibIn("netapi32"),
        LibIn("gdi32"),
        LibIn("user32"),
        LibIn("advapi32"),
        LibIn("kernel32"),
    ],
    "ODBC" : [LibIn("odbc32")],
    "OPENGL" : [LibIn("opengl32"), LibIn("glu32")],
    "TCP" : [ ],
}

%------------------------------------------------------------------------------

SYSTEM_LIBS_GNU =
{
% be sure to see what empty strings do here to fold this down
    "LIBC" :
    [
%       LibIn("winspool"),
        LibIn("comctl32"),
        LibIn("wsock32"),
%       LibIn("comdlg32"),
        LibIn("netapi32"),
        LibIn("gdi32"),
        LibIn("user32"),
%       LibIn("advapi32"),
%       LibIn("kernel32"),
    ],

    "FLEX-BISON" : [ "-lfl" ],

    "ODBC" : [LibIn("odbc32")], %  -lodbccp32 ?
    % for MS Windows
    % "OPENGL" : [LibIn("glu32"), LibIn("opengl32")], % -lglut32 ?
    % for X Windows
    "OPENGL" : [ LibPath & "/usr/X11R6/lib",
                 LibIn("GLU"),
                 LibIn("GL"),
                 LibIn("Xext") ],
    "TCP" : [ ],

    "MOTIF" : [ LibPath & "/usr/X11R6/lib",
                LibIn("Xm"),
                LibIn("Mrm"),
                LibIn("UIl") ],

    "X11" : [ LibPath & "/usr/X11R6/lib",
              LibIn("Xaw"),
              LibIn("Xmu"),
              LibIn("Xext"),
              LibIn("Xt"),
              LibIn("SM"),
              LibIn("ICE"),
              LibIn("X11") ],

   "Z" : [ "-lz" ],
}

SYSTEM_LIBS = { "WIN32" : SYSTEM_LIBS_MS, "POSIX" : SYSTEM_LIBS_GNU }{OS_TYPE}

%------------------------------------------------------------------------------

if equal(OS_TYPE, "WIN32")
%
% We must explicitly specify libcmt.lib or msvcrt.lib
% in our link command because many links contain no C code and
% no /defaultlib directives. The Modula-3 backend should perhaps
% output those directives.
%
% Cutting the C runtime dependency from Modula-3 may be desirable.
%
% The environment variable USE_MSVCRT is 0, 1, or not defined.
% Not defined is treated as 1. This is a safe default for the
% vast majority of toolsets, but not all.
%
    if not equal($USE_MSVCRT, "0")
        if not equal($USE_MSVCRT, "1")
            if not equal($USE_MSVCRT, "")
                error("The environment variable USE_MSVCRT should be 0, 1, or not defined, but it is " & $USE_MSVCRT & "." & EOL)
            end
        end
    end

    if not defined("USE_MSVCRT")
        if equal($USE_MSVCRT, "0")
            USE_MSVCRT = FALSE
        else
            USE_MSVCRT = TRUE
        end
    end

    if USE_MSVCRT
        SYSTEM_LIBS{"LIBC"} += [LibIn("msvcrt")]
    else
        SYSTEM_LIBS{"LIBC"} += [LibIn("libcmt")]
    end
end

% SYSTEM_LIBORDER defines the order in which SYSTEM_LIBS should be
% scanned by the linker.

if equal (WINDOW_LIBRARY, "X")
    SYSTEM_LIBORDER = ["OPENGL", "MOTIF", "X11", "TCP", "ODBC", "LIBC"]
else
    SYSTEM_LIBORDER = ["OPENGL",                 "TCP", "ODBC", "LIBC"]
end

if equal(OS_TYPE, "POSIX")
    SYSTEM_LIBORDER += ["Z", "FLEX-BISON"]
end

%--------------------------------------------------------- Modula-3 backend ---
% For platforms without an integrated backend, "m3_backend" is called to
% translate Modula-3 intermediate code to object code.

m3back_flags = [ ]

%
% always generate information for debugging
%
m3back_flags += "-gstabs+"

%
% -mno-align-double is VERY IMPORTANT
% because the Modula-3 compiler has already computed various
% offsets and the backend should not, must not change them.
%
% If you remove this, the floating point number in RTHeapInfo.m3
% gets aligned and the runtime linking information is then
% not at the expected offset and you crash in startup.
%
m3back_flags += "-mno-align-double"

%
% Don't depend on cygwin1.dll.
%
if equal(OS_TYPE, "WIN32")
    m3back_flags += "-mno-cygwin"
end

m3back_optimize = [ ]
m3back_optimize += "-O"

%
% This requires -O.
%
m3back_optimize += "-Wuninitialized"

%------------------------------------------------------------------------------

proc m3_backend(source, object, optimize, debug) is
    local args = [ "-quiet", "-fno-reorder-blocks", source, "-o", object]
    if optimize
        args += m3back_optimize
    end
    if M3_PROFILING
        args += "-p"
    end
    local m3back = GetM3Back()
    return try_exec(m3back, args)
end

%--------------------------------------------------------------- C compiler ---
% "compile_c" is called to compile C source files. Note that this function
% is only called if your program or library explicitly includes C source
% code, the system distributed by Critical Mass does not.

proc compile_c_ms(source, object, options, optimize, debug) is
    local args =
    [
%
% Be quiet. Remove this if response file are used, since it
% inhibits the compiler dumping the response file, which is useful
% in any log.
%
        "-nologo",
%
% Put type information in .objs/.libs instead of shared in vc80.pdb, etc.
% vc80.pdb can be renamed with /Fd, we'd need the target name.
% This is bigger/slower but has advantages too.
% Debug information does not inhibit optimization so always generate it.
%
% Remove this to "bootstrap backwards" -- build with newer toolsets
% such that you can subsequently build with older toolsets.
        "-Z7",
%
% needed for older headers such as with Visual C++ 2.0
%
        "-DWIN32",
        options
    ]
    if USE_MSVCRT
        %
        % Use msvcrt.lib and define _MT and _DLL.
        %
        args += ["-MD"]
    else
        %
        % Use libcmt.lib and define _MT.
        %
        args += ["-MT"]
    end
    if optimize
        args += "-Ox"
    end
    args += "-Oi"

    % Visual C++ always echos source file names as they are compiled.
    % This runs afoul of the goals of reducing the output of building.
    % Therefore, redirect to a file and only be noisy upon errors.

    local Listing = "_m3.lst"
    if defined("pos")
       Listing = Path_GetBase (source) & ".lst"
    end
    local readonly Command = ["cl.exe", escape(subst_chars(args, "\\", "/")), "-c", escape(source)]
    local ret = try_exec("@" & Command, ">", Listing)
    if not equal (ret, 0)
        write (Command & CR)
        if defined ("xxfs_contents")
            write (fs_contents (Listing))
        else
            exec ("@type", Listing)
        end
    end
    return ret
end

%------------------------------------------------------------------------------

proc compile_c_gnu(source, object, options, optimize, debug) is
    local args = options
    %
    % There's very little C in the system, and dtoa.h is crashing,
    % when compiling m3core Real*, LongReal*, Extended* (not every one).
    %
    %if optimize
    %    args += "-O"
    %end
    %args += "-Os"
    if M3_PROFILING
        args += "-pg"
    end
    return try_exec("@gcc", "-gstabs+", escape(subst_chars(args, "\\", "/")), "-c", subst_chars(source, "\\", "/"), "-o", object)
end

proc compile_c(source, object, options, optimize, debug) is
    if equal(C_COMPILER, "MS")
        return compile_c_ms(source, object, options, optimize, debug)
    end
    return compile_c_gnu(source, object, options, optimize, debug)
end

%---------------------------------------------------------------- assembler ---
% "assemble" is called to assemble .s or .asm files. Note that this function
% is only called if your program or library explicitly includes assembly source
% code, the system distributed by Critical Mass does not.

%
% not used
%
proc assemble_ms(source, object) is
    local args = arglist("@", ["-Ml", "-t", "-z", source & "," & object & ";"])
    return q_exec("masm386", args)
end

proc assemble_gnu(source, object) is
    return q_exec(["as", source, "-o", object])
end

proc assemble(source, object) is
    return assemble_gnu(source, object)
end

%------------------------------------------------------------------------------

%
% Quake can't do math, or generate unique temp files,
% at least not that it cleans up.
%
% Uniqueness is not critical here, it is merely useful
% while debugging to go back and see the temp files.
%
% It is also good to put files in a place where they
% will reliably get deleted -- not TEMP.
%
% It is open question as to if carry over to two digits
% can be implemented in Quake. :)
%

ResponseFileCounter = "0"

readonly proc GetResponseFileName() is
    local readonly Result = "_m3responsefile" & ResponseFileCounter & ".txt"
    ResponseFileCounter =
        { "0":"1","1":"2","2":"3","3":"4","4":"5",
          "5":"6","6":"7","7":"8","8":"9","9":"0", }{ResponseFileCounter}
    return Result
end

%
% mklib wants newlines, so a direct write doesn't work
% I couldn't get anything with write to work, nothing would handle
% plain parameters and lists
%
readonly proc WriteResponseFile(File, Divider, Args) is
    local readonly Temp = arglist("", Args)
    if equal(Temp, Args)
        if equal(Divider, " ")
            return Temp
        end
        %
        % Quake has a fixed size limit on strings, after which it crashes.
        % Hopefully that our parameter list is too short to be in a response
        % file implies it is short enough to fit in a string.
        %
        local Result = ""
        foreach Arg in Args
            if Result
                Result = Result & Divider
            end
            Result = Result & Arg
        end
        return Result
    end
    MoveFile(Temp, File)
    DeleteFile(Temp)
    return "@" & File
end

%------------------------------------------------------------------------------

readonly proc ManifestTool(DllOrExe, ManifestFile, ResourceId) is
    local ret = 0
    %
    % http://msdn2.microsoft.com/en-us/library/ms235591.aspx
    %
    if FileExists(ManifestFile)
        local Command = "@mt /nologo /manifest " & ManifestFile & " /outputresource:" & DllOrExe & ";" & ResourceId
        if equal (SL, "/")
            % Posix exec through sh treats the semicolon as a command delimiter, so quote
            % the whole command and send it to cmd.
            Command = "cmd /c \"" & Command & "\""
        end
        ret = try_exec(Command)
        DeleteFile(ManifestFile)
    end
    return ret
end

%------------------------------------------------------------------------------

%
% Modula-3 has fixed sized buffers and fails assertions if we try
% to give it more than 1k. This is lame.
%
readonly proc EscapeList(List) is
    local Result = [ ]
    foreach Element in List
        Result += escape(Element)
    end
    return Result
end

%------------------------------------------------------------------------------

UseHand = LIB_INSTALL & SL & "hand" & Obj
if not FileExists (UseHand)
  % for bootstrapping
  UseHand = ""
end

UseUconstants = LIB_INSTALL & SL & "Uconstants" & Obj
if not FileExists (UseUconstants)
  % for bootstrapping
  UseUconstants = ""
end

UseWinConstants = LIB_INSTALL & SL & "WinConstants" & Obj
if not FileExists (UseWinConstants)
  % for bootstrapping
  UseWinConstants = ""
end

%--------------------------------------------------------- library creation ---
% "make_lib" is called to combine a collection of object modules into
% a library.

%% NOTE: we should set the "base" load address of the various DLLs
%%  to avoid relocating them every time they are loaded.

%
% make_lib and m3_link need to share code!
%

proc make_dll_ms(options, objects, imported_libs, lib_file, def_file, dll_file, listing, LinkResponseFile) is
    %
    % Noentry cuts out the C runtime startup code,
    % which usually brings in most of our dependency on msvcr*.dll.
    % This leaves most Modula-3 .dlls using very few C runtime functions,
    % mainly setjmp for exception handling, and sometimes memmove, and
    % sometimes a few other functions.
    % This will break some scenarios that mix C and C++ with Modula-3, but
    % should get a link warning. Therefore this probably be configurable,
    % with the default being noentry.
    %
    % We don't use this when using libcmt.lib since that brings in more "real"
    % code that might require the initialization.
    %
    % For .exes a minimal custom entry point could be used, like:
    %  for gui: return WinMain(GetCommandLine(), GetModuleHandle(NULL), GetStartupInfo()...);
    %  for console: getmainargs...
    %
    % It would be nice to reduce the C runtime dependency to zero at some point.
    % On the other hand, it would be nice to get back a backend that generates
    % portable C, in order to get good codegen, on more platforms, without gcc.
    %
    if USE_MSVCRT
        options += "-noentry"
    end

    return try_exec(
        "@link.exe",
        WriteResponseFile(
            LinkResponseFile,
            " ",
            [
                m3_link_flags,
% Put this in to "bootstrap backwards" -- build with newer toolsets
% such that you can subsequently build with older toolsets.
%               "-link50compat",
                "-def:" & def_file,
                "-dll",
                "-out:" & dll_file,
                 options,
                 objects,
                 subst_chars(imported_libs, "/", "\\"),
                 subst_chars(UseHand, "/", "\\"),
                 subst_chars(UseWinConstants, "/", "\\"),
            ]),
        "2>&1",
        ">", listing
        )
end

%------------------------------------------------------------------------------

proc make_dll_gnu(options, objects, imported_libs, lib_file, def_file, dll_file, listing, LinkResponseFile) is
    if M3_PROFILING
        objects += "-pg"
    end

    return try_exec(
            "@gcc",
            "-gstabs+",
            %"-v",
            "-shared", % must be visible to compiler
            "-Wl,"
                & WriteResponseFile(
                    LinkResponseFile,
                    ",",
                    [
                        "--output",
                        dll_file,
                        "--out-implib",
                        lib_file,
                        %"--export-all-symbols",
                        "--enable-auto-image-base",
                        "--warn-duplicate-exports",
                        "--disable-auto-import",
                        "--disable-runtime-pseudo-reloc",
                        "--large-address-aware",
                        objects,
                        EscapeList(imported_libs),
                        escape(UseUconstants),
                        escape(UseWinConstants),
                        %escape(UseHand),
                    ]),
            "2>&1",
            ">", listing
            )
end

%------------------------------------------------------------------------------

proc make_lib(lib, options, objects, imported_libs, shared) is
    local ret_code = 0

    local readonly lib_file = format(FormatLib, lib)
    local readonly lib0_file = lib_file & ".sa"
    local readonly def_file = lib & ".def"
    local readonly dll_file = format(FormatDll, lib)
    local readonly manifest_file  = dll_file & ".manifest"
    local readonly pdb_file = lib & ".pdb"
    local readonly listing  = lib & ".lst"
    local readonly LibResponseFile = GetResponseFileName()
    local LinkResponseFile = LibResponseFile
    local ShipHand = equal (lib, "m3core") and FileExists("hand" & Obj)
    local ShipUconstants = equal (lib, "m3core") and FileExists("Uconstants" & Obj)
    local ShipWinConstants = equal (lib, "m3core") and FileExists("WinConstants" & Obj)

    if ShipHand or not shared
        UseHand = ""
    end

    if ShipUconstants or not shared
        UseUconstants = ""
    end

    if ShipWinConstants or not shared
        UseWinConstants = ""
    end

    if shared
        LinkResponseFile = GetResponseFileName()
    end

    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        def_file,
        listing,
        manifest_file,
        pdb_file,
        LibResponseFile,
        LinkResponseFile,
        lib & ".ilk"]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    local m3_lib_flags = [ ]
    if equal(LINKER, "MS")
        % m3_lib_flags = ["-debugtype:cv", "-machine:i386"]
        m3_lib_flags = ["-ign:__real"]
    end

    % build the static library

    ret_code = try_exec(
        "@mklib",
        WriteResponseFile(
            LibResponseFile,
            " ",
            [
                m3_lib_flags,
                "-out:" & lib_file,
                options,
                objects,
            ]),
        "2>&1",
        ">", listing
        )
    if not equal(ret_code, 0) or not FileExists(lib_file)
        error(
            "library creation failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL)
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end

    if shared

        % build an import library & DLL

        MoveFile(lib_file, lib0_file)

        if equal(LINKER, "MS")
            ret_code =
                make_dll_ms(
                    options,
                    objects,
                    subst_chars(imported_libs, "/", "\\"),
                    lib_file,
                    def_file,
                    dll_file,
                    listing,
                    LinkResponseFile)
        else
            ret_code =
                make_dll_gnu(
                    options,
                    objects,
                    imported_libs,
                    lib_file,
                    def_file,
                    dll_file,
                    listing,
                    LinkResponseFile)
        end

        if not equal(ret_code, 0) or not FileExists(dll_file)
            error(
                "dynamic link library creation failed, see "
                & GetPackageDirectory()
                & BUILD_DIR
                & SL
                & listing
                & " for more information"
                & EOL)
            if not equal(ret_code, 0)
                return ret_code
            end
            return 1
        end

        ret_code = ManifestTool(dll_file, manifest_file, "2")
        if not equal(ret_code, 0)
            return ret_code
        end

        BindExport(dll_file)
        PdbExport(pdb_file)
        install_derived(lib0_file)
        if ShipHand
            LibdExport("hand" & Obj)
        end
        if ShipUconstants
            LibdExport("Uconstants" & Obj)
        end
    end
    return ret_code
end

%-------------------------------------------------------------------
% "skip_lib" is called when the compiler decides it doesn't need to
% call "make_lib", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc skip_lib(lib, shared) is
    local readonly lib_file = format(FormatLib, lib)
    local readonly lib0_file = lib_file & ".sa"
    local def_file  = lib & ".def"
    local readonly dll_file = format(FormatDll, lib)
    local manifest_file  = dll_file & ".manifest"
    local pdb_file  = lib & ".pdb"
    local listing   = lib & ".lst"

    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        def_file,
        listing,
        manifest_file,
        pdb_file,
        lib & ".ilk"]

    % make sure files get cleaned up
    deriveds("", Outputs)

    if shared
        % would have built an import library & DLL
        BindExport(dll_file)
        DeleteFile(manifest_file)
        PdbExport(pdb_file)
        install_derived(lib0_file)
    else
        DeleteFiles([lib0_file, dll_file, manifest_file, pdb_file])
    end

    return 0
end

%------------------------------------------------------------------- linker ---
% "m3_link" is called to produce a final executable.

m3_link_flags =
[
%
% Ignore that some .libs think they want libc.lib.
% This should not needed in a full coherent build, however
% existing distributions, such as 5.2.6, have C code built
% without /MD or /MT and bootstrapping uses their files,
% such as m3core.lib.sa(hand.obj).
%
% Cutting the C runtime dependency from Modula-3 may be desirable.
%
    "-nodefaultlib",
%
% Generate a .pdb for debugging.
%
    "-debug",
%
% Spend a little longer producing a slightly smaller/faster .dll/.exe and
% avoid some warnings.
%
    "-incremental:no",
%
% Remove unused code/data.
%
    "-opt:ref",
%
% With newer linkers, combine identical code/data.
%
%   "-opt:icf",
]

%
% The environment variable USE_DELAYLOAD is 0, 1, or not defined.
% Not defined is treated as 1. This is a safe default for
% linker versions going back a long way, but not infinitely so.
% sysinfo.cmd sets it based on probing the environment.
%
if not equal($USE_DELAYLOAD, "0")
    if not equal($USE_DELAYLOAD, "1")
        if not equal($USE_DELAYLOAD, "")
            error("The environment variable USE_DELAYLOAD should be 0, 1, or not defined, but it is " & $USE_DELAYLOAD & "." & EOL)
        end
    end
end

if not defined("USE_DELAYLOAD")
    if equal($USE_DELAYLOAD, "1")
        USE_DELAYLOAD = TRUE
    else
        USE_DELAYLOAD = FALSE
    end
end

if USE_DELAYLOAD
    m3_link_flags +=
    [
    %
    % The default static dependencies of Modula-3 binaries
    % are larger than they should be. Reduce them sleazily via delayload.
    % This requires a Visual C++ 6.0 or newer linker.
    %
        "-delayload:wsock32.dll",
        "-delayload:advapi32.dll",
        "-delayload:gdi32.dll",
        "-delayload:netapi32.dll",
        "-delayload:user32.dll",
        "-delayload:comctl32.dll",
        "delayimp.lib",
    ]
end

%------------------------------------------------------------------------------

proc m3_link_ms(prog, options, objects, imported_libs, shared, pgm_file, listing, LinkResponseFile) is
    local entry = ["-subsystem:console", "-entry:mainCRTStartup"]
    if defined("M3_WINDOWS_GUI")
        if M3_WINDOWS_GUI
            entry = ["-subsystem:windows", "-entry:WinMainCRTStartup"]
        end
    end

    return try_exec(
        "@link",
        WriteResponseFile(
            LinkResponseFile,
            " ",
            [
                "-out:" & pgm_file,
                entry,
                m3_link_flags,
                options,
                objects,
                subst_chars(imported_libs, "/", "\\"),
                subst_chars(UseHand, "/", "\\"),
                subst_chars(UseWinConstants, "/", "\\"),
            ]),
        "2>&1",
        ">", listing
        )
end

%------------------------------------------------------------------------------

proc m3_link_gnu(prog, options, objects, imported_libs, shared, pgm_file, listing, LinkResponseFile) is
    if not shared
        %options += "-static"
    end
    if M3_PROFILING
        options += "-pg"
    end

    % not tested
    % if not defined("M3_WINDOWS_GUI")
    %   M3_WINDOWS_GUI = FALSE
    % end
    % if M3_WINDOWS_GUI
    %   options += "-mwindows"
    % else
    %   options += "-mconsole"
    % end

    return try_exec(
            "@gcc",
            "-gstabs+",
            %"-v",
            "-Wl,"
                & WriteResponseFile(
                    LinkResponseFile,
                    ",",
                    [
                        "--output",
                        pgm_file,
                        "--disable-auto-import",
                        "--disable-runtime-pseudo-reloc",
                        "--large-address-aware",
                        options,
                        objects,
                        EscapeList(imported_libs),
                        escape(UseUconstants),
                        escape(UseWinConstants),
                        %escape(UseHand),
                    ]),
            "2>&1",
            ">", listing
            )
end

%------------------------------------------------------------------------------

proc m3_link(prog, options, objects, imported_libs, shared) is
    local ret_code = 0
    local readonly pgm_file = format(FormatExe, prog)
    local readonly manifest_file = pgm_file & ".manifest"
    local readonly pdb_file = prog & ".pdb"
    local readonly listing  = prog & ".lst"
    local readonly LinkResponseFile = GetResponseFileName()

    local readonly Outputs = [
        pgm_file,
        listing,
        manifest_file,
        pdb_file,
        LinkResponseFile,
        prog & ".ilk"]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    if not shared
      UseHand = ""
      UseUconstants = ""
      UseWinConstants = ""
    end

    imported_libs = ConvertLibsToStandalone(imported_libs, shared)

    if equal(LINKER, "MS")
        ret_code = m3_link_ms(
            prog,
            options,
            objects,
            imported_libs,
            shared,
            pgm_file,
            listing,
            LinkResponseFile)
    else
        ret_code = m3_link_gnu(
            prog,
            options,
            objects,
            imported_libs,
            shared,
            pgm_file,
            listing,
            LinkResponseFile)
    end

    if not equal(ret_code, 0) or not FileExists(pgm_file)
        error(
            "link failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL)
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end

    ret_code = ManifestTool(pgm_file, manifest_file, "1")
    if not equal(ret_code, 0)
        return ret_code
    end

    PdbExport(pdb_file)

    return ret_code
end

%------------------------------------------------------------ misc. options ---
% Note, most of these options can be set from the command line. Otherwise,
% they can be set "permanently" here in the config file or in as needed
% in user's m3makefiles.

% M3_WINDOWS_GUI = TRUE
% --- generate a Windows GUI subsystem program instead of a console one.

% M3_COVERAGE = TRUE
% --- compile & link with coverage options

M3_COVERAGE_LIB = "report_coverage" & Obj
% --- library linked in programs compiled with "-Z" coverage option

M3_SPLIT_LIBNAMES = FALSE
% --- split library names and pass -L/-l arguments to the linker

% M3_SHARED_LIB_ARG = ""
% --- pass "-R" flags to the linker too.

% M3_MAIN_IN_C = TRUE
% --- generate the Modula-3 main program as C code
