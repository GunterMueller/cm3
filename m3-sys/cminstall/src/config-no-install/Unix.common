% Copyright 1996 Critical Mass, Inc. All rights reserved.
% 
% Standard configuration file for LINUX with ELF object files
%

%-------------------------------------------------- compilation environment ---

%M3_PROFILING = TRUE  % set by cm3 since 5.1.2 (option -profile)
%M3_PROFILING = FALSE

if M3_PROFILING
    readonly PROFILING_P = "p"
else
    readonly PROFILING_P = ""
end

readonly BUILD_DIR    = TARGET & PROFILING_P % directory for results
readonly OS_TYPE      = "POSIX"           % { "WIN32" or "POSIX" }

readonly NAMING_CONVENTIONS = "0"
%                                        object files       libraries
%  0=Unix                          =>  .o   .io    .mo       libXX.a
%  1=Unix with a grumpy C compiler =>  .o   _i.o   _m.o      libXX.a
%  2=Windows NT or Windows 95      =>  .obj .io    .mo       XX.lib
%

%-------------------------------------------------- default compile options ---
% "set_config_options" is called before starting the compilation.  It should
% be used to provide system-wide default options.

proc set_config_options() is
  m3_option("-why")   %-- produce a listing that explains what's happening and why
  m3_debug(TRUE)      %-- produce object code with debugging symbols
  M3_OPTIONS += "-w1"  %-- produce "level 1" warnings
end

%-------------------------------------------------------------------- paths ---

readonly
proc
CM3SetInstallRoot(
    )
is
    if defined("INSTALL_ROOT")
        return
    end
    if not equal($CM3_INSTALL, "")
        INSTALL_ROOT = $CM3_INSTALL
        return
    end
    INSTALL_ROOT = (path() & SL & "..")
end

CM3SetInstallRoot()

readonly BIN_INSTALL    = INSTALL_ROOT & SL & "bin"     % executables
readonly LIB_INSTALL    = INSTALL_ROOT & SL & "lib" & PROFILING_P   % libraries
readonly PKG_INSTALL    = INSTALL_ROOT & SL & "pkg"     % packages
readonly DOC_INSTALL    = INSTALL_ROOT & SL & "doc"     % documents
readonly EMACS_INSTALL  = INSTALL_ROOT & SL & "elisp"   % emacs lisp code
readonly MAN_INSTALL    = INSTALL_ROOT & SL & "man"     % man pages
readonly HTML_INSTALL   = INSTALL_ROOT & SL & "www"     % public hypertext

% On some systems (e.g. AFS) you must install public files in a different
% place from where you use them.  If that is the case for your system,
% specify the "use" location here, otherwise leave them alone.
%
USE_ROOT  = INSTALL_ROOT
BIN_USE   = BIN_INSTALL     % executables
LIB_USE   = LIB_INSTALL     % libraries
PKG_USE   = PKG_INSTALL     % packages

% write("path() is " & path() & CR)
% write("INSTALL_ROOT is " & INSTALL_ROOT & CR)
% write("PKG_USE is " & PKG_USE & CR)

readonly INSTALL_IMPLS = TRUE
% TRUE
%    => save all source files during the install
%    => makes debugging easier and browsing more fruitful
% FALSE
%    => save only the exported interfaces and templates 
%    => makes the installed system slightly smaller.

%------------------------------------------------ external system libraries ---
% SYSTEM_LIBS provides a mapping from Modula-3 names for the common
% external libraries to site-dependent information about how they
% are accessed.  If SYSTEM_LIBS{x} is defined it should be a list
% of linker arguments that are used when linking against that library.
% If SYSTEM_LIBS{x} is not defined, the Modula-3 system will assume
% that the library is not available.

proc exists(x) is
  return not stale(x, x)
end

if not defined ("SYSTEM_LIBS")

SYSTEM_LIBS =
{
    "LIBC"       : [ "-lm", "-lpthread" ],
    "LEX-YACC"   : [ "-ll" ],
    "FLEX-BISON" : [ "-lfl" ],
    "POSTGRES95" : [ "-L/usr/local/pgsql/lib", "-lpq" ],
    "OPENGL"     : [ "-lGLU", "-lGL", "-lXext" ],
    "ODBC"       : [ "-lodbc" ],
    "MOTIF"      : [ "-lXm" ],
    "TCP"        : [ ],
    "X11" :      [  "-L/usr/X11R6/lib", "-lXaw", "-lXmu", "-lXext", 
"-lXt", "-lSM", "-lICE", "-lX11" ]
}

end

% SYSTEM_LIBORDER defines the order in which SYSTEM_LIBS should be
% scanned by the linker.

if not defined ("SYSTEM_LIBORDER")

SYSTEM_LIBORDER =
[
    "OPENGL",
    "DECPEX",
    "MOTIF",
    "X11",
    "TCP",
    "ODBC",
    "POSTGRES95",
    "FLEX-BISON",
    "LEX-YACC",
    "LIBC",
]

end

%---------------------------------------------------------- system programs ---

readonly SYSTEM_AR  = "@ar" % Archiver

%--------------------------------------------------------- Modula-3 backend ---
% For platforms without an integrated backend, "m3_backend" is called to
% translate Modula-3 intermediate code to object code.

proc m3_backend(source, object, optimize, debug) is
  %
  % These flags are local instead of global to avoid the probe when we compile nothing.
  %
  local args = [ GetM3BackFlag ("-fno-reorder-blocks") ]
  if M3_PROFILING args += "-p" end
  if equal (WORD_SIZE, "32BITS")
    args += GetM3BackFlag("-m32")
  else if equal (WORD_SIZE, "64BITS")
    args += "-m64"
  end end
  return try_exec ("@" & m3back, args, source, "-o", object)
end

M3_BACKEND_MODE = "3"
% -- defines how the frontend, backend, and assembler interact
%  "0"  -- don't call m3_backend, M3CG produces object code
%  "1"  -- don't call m3_backend, M3CG produces assembly code
%  "2"  -- call m3_backend, it produces object code
%  "3"  -- call m3_backend, it produces assembly code

%--------------------------------------------------------------- C compiler ---
% "compile_c" is called to compile C source files.  Note that this function
% is only called if your program or library explicitly includes C source
% code, the system distributed by Critical Mass does not.

if not defined ("compile_c")

proc compile_c(source, object, options, optimize, debug) is
  local args = options
  if M3_PROFILING args += "-pg" end
  return try_exec ("@" & SYSTEM_CC, args, "-c", source)
end

end

%---------------------------------------------------------------- assembler ---
% "assemble" is called to assemble .s or .asm files.  Note that this function
% is only called if your program or library explicitly includes assembly source
% code, the system distributed by Critical Mass does not.

if not defined ("assemble")

proc assemble(source, object) is
  return try_exec("@" & SYSTEM_ASM, source, "-o", object)
end

end

%------------------------------------------------------------------------------
%
% GcWrapFlags is needed for older toolsets and this config file
% strives to work with old and new automatically.
% This should go in some "Linux-common" file.
%

GcWrapFlags = ""

if not defined ("GetGcWrapFlags")
	readonly proc GetGcWrapFlags() is
		if not GcWrapFlags
			% write("checking for GcWrapFlags" & CR)
			GcWrapFlags = " "
			local ExitCode = try_exec("@grep -F m3gcdefs " & PKG_USE & "/m3core/" & TARGET & "/.M3EXPORTS > /dev/null")
			if equal(ExitCode, 0)
				GcWrapFlags = "-Wl,--wrap,adjtime,--wrap,getdirentries,--wrap,readv,--wrap,utimes,--wrap,wait3"

				% find libm3gcdefs here
				% GcWrapFlags = GcWrapFlags & " -L" & LIB_USE & " -lm3gcdefs"
				% GcWrapFlags = GcWrapFlags & " " & LIB_USE & "/libm3gcdefs.a"
			end
		end
		return GcWrapFlags
	end
end

% write("exists(/) is " & exists("/") & CR)
% write("exists(/pub/lang/m3/cm3-dist/cm3/lib) is " & exists("/pub/lang/m3/cm3-dist/cm3/lib") & CR)
% write("exists(/bin/sh) is " & exists("/bin/sh") & CR)
% write("exists(/bin/shx) is " & exists("/bin/shx") & CR)
% error("")

%
% The 5.1.8 distribution seems to look for libm3gcdefs
% in a hard-coded place unlikely to be correct. Fix it.
%
% Also old distributions reference errno directly.
% That is bad in multithreaded programs but should be
% ok for bootstrapping. This code should probably
% be gated by if defined("BOOT") or defined("OLD_BOOT")
% or such.
%
% GcWrapFlags does not necessarily coincide with references to errno.
%
if not defined ("FixM3GcDefs")
	readonly proc FixM3GcDefs(Args) is
		local GcWrapFlags = GetGcWrapFlags()
		if equal(GcWrapFlags, " ")
			return Args
		end
		% if equal(LIB_USE, "/pub/lang/m3/cm3-dist/cm3/lib")
		%     return Args
		% end
		% if equal(LIB_USE, "/pub/lang/m3/cm3-dist/cm3/bin/..lib")
		%     return Args
		% end
		% local Result = [ ]
		% Result += "-L" & LIB_USE
		% foreach Arg in Args
		%    write("Arg is " & Arg & CR)
		%    if equal(Arg, "-L/pub/lang/m3/cm3-dist/cm3/lib")
		%        write("changing arg" & CR)
		%        Result += "-L" & LIB_USE
		%    else
		%        Result += Arg
		%    end
		%end
		%Result += "/usr/lib/libc.a"
		%return Result
		%Args += "-L" & LIB_USE
		%Args += "/usr/lib/libc.a"
		return Args
	end
end

%
% Hash of command line option to TRUE or FALSE,
% to avoid probing more than once. 
%
local IsM3BackFlagSupported_Cache = { }

if not defined ("GetM3BackFlag")
	readonly proc IsM3BackFlagSupported(x) is
		local Result = 0
		if IsM3BackFlagSupported_Cache contains x
			Result = IsM3BackFlagSupported_Cache{x}
		else
			% write("probing " & m3back & " for " & x & CR)
			Result = not equal(try_exec(
				m3back & " " & x & " /dev/null 2>&1 "
				& "| grep -F -e \"Invalid option\" -e \"unrecognized command line option\" > /dev/null"), 0)
			IsM3BackFlagSupported_Cache{x} = Result
		end
		return Result
	end

	readonly proc GetM3BackFlag(x) is
		if not IsM3BackFlagSupported(x)
			x = ""
		end
		return x
	end
end

% write("GetGcWrapFlags is " & GetGcWrapFlags() & CR)
% write("GetGcWrapFlags is " & GetGcWrapFlags() & CR)
% write("GetM3BackFlag(-foo) is " & GetM3BackFlag("-foo") & CR)
% write("GetM3BackFlag(-fno-reorder-blocks) is " & GetM3BackFlag("-fno-reorder-blocks") & CR)
% write("GetM3BackFlag(-fno-reorder-blocks) is " & GetM3BackFlag("-fno-reorder-blocks") & CR)
% write("GetM3BackFlag(-g) is " & GetM3BackFlag("-g") & CR)
% write("GetM3BackFlag(-g) is " & GetM3BackFlag("-g") & CR)
% write("GetM3BackFlag(-m32) is " & GetM3BackFlag("-m32") & CR)
% write("GetM3BackFlag(-m32) is " & GetM3BackFlag("-m32") & CR)
% error("")

%--------------------------------------------------------- library creation ---
% "make_lib" is called to combine a collection of object modules into
% a library.

if not defined("make_lib")

proc make_lib(lib, options, objects, imported_libs, shared) is
    local ret_code = 0
    local lib_a    = format("lib%s.a", lib)
    local lib_so   = format("lib%s.so", lib)
    local lib_sox  = format("lib%s.so.5", lib)

    % build the non-shared library
    if defined("AR_AND_RANLIB_ARE_ONE")
        ret_code = try_exec("@ar", "crus", lib_a, objects)
        if not equal(ret_code, 0)
            return ret_code
        end
    else
        ret_code = try_exec("@ar", "cru", lib_a, objects)
        if not equal(ret_code, 0)
            return ret_code
        end
        ret_code = try_exec("@ranlib", lib_a)
        if not equal(ret_code, 0)
            return ret_code
        end
    end

    if not shared
        delete_file(lib_so)
        delete_file(lib_sox)
        return 0
    end

    % build the shared library
    local pg = ""
    if M3_PROFILING
        pg = "-pg"
    end
    ret_code =
        try_exec(
            "@" & SYSTEM_CC,
            GetGcWrapFlags(),
            pg,
            "-shared",
            "-Wl,-soname," & lib_sox,
            "-o", lib_sox,
            objects,
            )
    if not equal(ret_code, 0)
        return ret_code
    end

    % create the version aliases
    link_file(lib_sox, lib_so)

    % make sure the shared library stuff gets installed properly
    install_derived(lib_sox)
    install_derived_link(lib_sox, lib_so)
    install_link_to_derived(lib_sox, LIB_INSTALL)
    install_link_to_derived(lib_so, LIB_INSTALL)

    return 0
end

end

%-------------------------------------------------------------------
% "skip_lib" is called when the compiler decides it doesn't need to
% call "make_lib", but it wants to discover the names of the derived
% files that should be deleted or shipped.

if not defined("skip_lib")

proc skip_lib(lib, shared) is
    local lib_so   = format("lib%s.so", lib)
    local lib_sox  = format("lib%s.so.5", lib)

    if shared
        % make sure the shared library stuff gets installed properly
        install_derived(lib_sox)
        install_derived(lib_so)
        install_link_to_derived(lib_sox, LIB_INSTALL)
        install_link_to_derived(lib_so, LIB_INSTALL)
    else
        delete_file(lib_so)
        delete_file(lib_sox)
    end

    return 0
end

end

%------------------------------------------------------------------- linker ---
% "m3_link" is called to produce a final executable.

if not defined("m3_link")

proc m3_link(prog, options, objects, imported_libs, shared) is
    local args =
    [
        GetGcWrapFlags(),
        "-o", prog,
        options,
        objects,
        FixM3GcDefs(imported_libs),
    ]
    if M3_PROFILING
        args += "-pg"
    end
    return try_exec("@" & SYSTEM_CC, args)
end

end

%-------------------------------------------------------------------
% "skip_link" is called when the compiler decides it doesn't need to
% call "m3_link", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc skip_link(prog, shared) is
    return 0
end

%------------------------------------------------------------ misc. options ---
% Note, most of these options can be set from the command line.  Otherwise,
% they can be set "permanently" here in the config file or in as needed
% in user's m3makefiles.

M3_FRONT_FLAGS = [ ]
% --- internal configuration options passed directly to the Modula-3 front-end

M3_OPTIONS = [ ]
% --- user options passed directly to the Modula-3 front-end

% M3_KEEP_FILES = TRUE
% --- keep intermediate and temporary files

% M3_WINDOWS_GUI = TRUE
% --- generate a Windows GUI subsystem program instead of a console one.

% M3_COVERAGE = TRUE
% --- compile & link with coverage options

M3_COVERAGE_LIB = LIB_USE & "/report_coverage.o"
% --- library linked in programs compiled with "-Z" coverage option

M3_SPLIT_LIBNAMES = TRUE
% --- split library names and pass -L/-l arguments to the linker

M3_SHARED_LIB_ARG = "-Wl,-R"
% --- pass "-R" flags to the linker too...

% M3_BOOTSTRAP = TRUE
% --- generate bootstrap code (assembly) instead of finaly object code

% M3_COMPILE_ONCE = TRUE
% --- don't recompile code to improve opaque object references

% SYS_HAS_LOADER = TRUE
% --- generate a loader info file with objects, libraries and timestamps

% M3_SKIP_LINK = TRUE
% --- skip the final link for programs, presumably to use the loader instead

% M3_MAIN_IN_C = TRUE
% --- generate the Modula-3 main program as C code

X11_WITH_SHARED_MEM = TRUE
% --- X11 libraries include the shared memory extensions (XShm...)

%M3_NEED_STANDALONE_LINKS = TRUE
% --- linker is broken and we need to build a directory of symbolic
%     links pointing to the non-shared libraries.

%-------------------------------------------------------------------- emacs ---
% If you have emacs and want to compile ".el" files to ".elc" files,
% fill in the function below.  Otherwise, comment out or delete the
% entire function.  Note, the distributed code assumes gnuemacs version 19
% or later.

readonly proc emacs_compile(el) is
  exec("emacs -batch -f batch-byte-compile", el)
end
