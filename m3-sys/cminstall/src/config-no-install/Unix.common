% Copyright 1996 Critical Mass, Inc. All rights reserved.
% 
% common configuration file for various platforms
%

include("cm3cfg.common")

%-------------------------------------------------- compilation environment ---

readonly OS_TYPE      = "POSIX"           % { "WIN32" or "POSIX" }

readonly NAMING_CONVENTIONS = "0"
%                                        object files       libraries
%  0=Unix                          =>  .o   .io    .mo       libXX.a
%  1=Unix with a grumpy C compiler =>  .o   _i.o   _m.o      libXX.a
%  2=Windows NT or Windows 95      =>  .obj .io    .mo       XX.lib
%

%------------------------------------------------ external system libraries ---
% SYSTEM_LIBS provides a mapping from Modula-3 names for the common
% external libraries to site-dependent information about how they
% are accessed.  If SYSTEM_LIBS{x} is defined it should be a list
% of linker arguments that are used when linking against that library.
% If SYSTEM_LIBS{x} is not defined, the Modula-3 system will assume
% that the library is not available.

if not defined ("SYSTEM_LIBS")

SYSTEM_LIBS =
{
    "LIBC"       : [ "-lm", "-lpthread" ],
    "LEX-YACC"   : [ "-ll" ],
    "FLEX-BISON" : [ "-lfl" ],
    "POSTGRES95" : [ "-L/usr/local/pgsql/lib", "-lpq" ],
    "OPENGL"     : [ "-lGLU", "-lGL", "-lXext" ],
    "ODBC"       : [ "-lodbc" ],
    "MOTIF"      : [ "-lXm" ],
    "TCP"        : [ ],
    "X11" :      [  "-L/usr/X11R6/lib", "-lXaw", "-lXmu", "-lXext", "-lXt", "-lSM", "-lICE", "-lX11" ]
}

end

% SYSTEM_LIBORDER defines the order in which SYSTEM_LIBS should be
% scanned by the linker.

if not defined ("SYSTEM_LIBORDER")

SYSTEM_LIBORDER = [ "OPENGL", "DECPEX", "MOTIF", "X11", "TCP",
    "ODBC", "POSTGRES95", "FLEX-BISON", "LEX-YACC", "LIBC" ]

end

if not defined("SYSTEM_LD")
  SYSTEM_LD = SYSTEM_CC
end

%--------------------------------------------------------- Modula-3 backend ---
% For platforms without an integrated backend, "m3_backend" is called to
% translate Modula-3 intermediate code to object code.

proc m3_backend(source, object, optimize, debug) is
    %
    % These flags are local instead of global to avoid the probe when we compile nothing.
    %
    local args = [ GetM3BackFlag ("-fno-reorder-blocks") ]
    if optimize and not equal(TARGET, "I386_INTERIX")
        args += "-O3"
    end
    if M3_PROFILING
        args += "-p"
    end
    if equal (WORD_SIZE, "32BITS")
        args += GetM3BackFlag("-m32")
    end
    args += GetM3BackFlag("-funwind-tables")
    local m3back = GetM3Back()
    return try_exec (m3back, args, source, "-o", object)
end

%--------------------------------------------------------------- C compiler ---
% "compile_c" is called to compile C source files.  Note that this function
% is only called if your program or library explicitly includes C source
% code, the system distributed by Critical Mass does not.

if not defined ("compile_c")

proc compile_c(source, object, options, optimize, debug) is
    local args = options
    if M3_PROFILING args += "-pg" end
    return try_exec ("@" & SYSTEM_CC, args, "-c", source)
    end

end

%---------------------------------------------------------------- assembler ---
% "assemble" is called to assemble .s or .asm files.  Note that this function
% is only called if your program or library explicitly includes assembly source
% code, the system distributed by Critical Mass does not.

proc assemble(source, object) is
    if defined("configure_assembler")
        configure_assembler()
    end
    return try_exec("@" & SYSTEM_ASM, source, "-o", object)
end

%------------------------------------------------------------------------------
%
% GcWrapFlags is needed for older toolsets and this config file
% strives to work with old and new automatically.
% This should go in some "Linux-common" file.
%

GcWrapFlags = ""

if not defined ("GetGcWrapFlags")
    readonly proc GetGcWrapFlags() is
        if not GcWrapFlags
            % write("checking for GcWrapFlags" & CR)
            GcWrapFlags = " " % tricky non-false value -- the default
            local ExitCode = try_exec("@fgrep m3gcdefs " & PKG_USE & "/m3core/" & TARGET & "/.M3EXPORTS 2>/dev/null >/dev/null")
            if equal(ExitCode, 0)
                GcWrapFlags = "-Wl,--wrap,adjtime,--wrap,getdirentries,--wrap,readv,--wrap,utimes,--wrap,wait3"
                % find libm3gcdefs here
                % GcWrapFlags = GcWrapFlags & " -L" & LIB_USE & " -lm3gcdefs"
                % GcWrapFlags = GcWrapFlags & " " & LIB_USE & "/libm3gcdefs.a"
            end
        end
        return GcWrapFlags
    end
end

%
% The 5.1.8 distribution seems to look for libm3gcdefs
% in a hard-coded place unlikely to be correct. Fix it.
%
% Also old distributions reference errno directly.
% That is bad in multithreaded programs but should be
% ok for bootstrapping. This code should probably
% be gated by if defined("BOOT") or defined("OLD_BOOT")
% or such.
%
% GcWrapFlags does not necessarily coincide with references to errno.
%
if not defined ("FixM3GcDefs")
    readonly proc FixM3GcDefs(Args) is
        local GcWrapFlags = GetGcWrapFlags()
        if equal(GcWrapFlags, " ")
            return Args
        end
        % if equal(LIB_USE, "/pub/lang/m3/cm3-dist/cm3/lib")
        %     return Args
        % end
        % if equal(LIB_USE, "/pub/lang/m3/cm3-dist/cm3/bin/..lib")
        %     return Args
        % end
        % local Result = [ ]
        % Result += "-L" & LIB_USE
        % foreach Arg in Args
        %    write("Arg is " & Arg & CR)
        %    if equal(Arg, "-L/pub/lang/m3/cm3-dist/cm3/lib")
        %        write("changing arg" & CR)
        %        Result += "-L" & LIB_USE
        %    else
        %        Result += Arg
        %    end
        %end
        %Result += "/usr/lib/libc.a"
        %return Result
        %Args += "-L" & LIB_USE
        %Args += "/usr/lib/libc.a"
        return Args
    end
end

%
% Hash of command line option to TRUE or FALSE,
% to avoid probing more than once. 
%
local IsM3BackFlagSupported_Cache = { }

readonly proc _IsM3BackFlagSupported(x) is
    local Result = 0
    if IsM3BackFlagSupported_Cache contains x
        Result = IsM3BackFlagSupported_Cache{x}
    else
        local m3back = GetM3Back()
        % write("probing " & m3back & " for " & x & CR)
        Result = not equal(try_exec(
            m3back & " " & x & " /dev/null 2>&1 "
            & "| fgrep -i -e \"Invalid option\" -e \"unrecognized command line option\" 2>/dev/null >/dev/null"), 0)
        IsM3BackFlagSupported_Cache{x} = Result
    end
    return Result
end
    
if not defined ("GetM3BackFlag")
    readonly proc IsM3BackFlagSupported(x) is
        return _IsM3BackFlagSupported(x)
    end
        
    readonly proc GetM3BackFlag(x) is
        if not IsM3BackFlagSupported(x)
            x = ""
        end
        return x
    end
end

%------------------------------------------------------------------------------
% A general mechanism for part of m3core to always be statically linked.
% For example data on NT should not be dynamically linked, and the
% libgcc helper functions are small and not worth dynamic linking.
%
% This does not currently work where it is needed.

proc GetM3CoreStaticObjs(lib) is
    local Result = [ ]
    if defined ("M3CoreStaticObjs") and not equal (lib, "m3core")
        foreach a in M3CoreStaticObjs
            local b = LIB_INSTALL & SL & a & ".o"
            if exists (b)
                Result += [ b ]
            end
        end
    end
    return Result
end

proc ShipM3CoreStaticObjs(lib) is
    local Result = [ ]
    if defined ("M3CoreStaticObjs") and equal (lib, "m3core")
        foreach a in M3CoreStaticObjs
            LibdExport(a & ".o")
        end
    end
end

%--------------------------------------------------------- library creation ---
% "make_lib" is called to combine a collection of object modules into
% a library.

if not defined("make_lib")

proc make_lib(lib, options, objects, imported_libs, shared) is
    local suffix = "so"
    local hpux_flags = ""
    local soname_flag = "-soname"
    if equal (TARGET, "PA32_HPUX") or equal (TARGET, "PA64_HPUX")
      suffix = "sl"
      soname_flag = "+h"
    end
    local ret_code = 0
    local lib_a   = format("lib%s.a", lib)
    local lib_so  = format("lib%s.%s", lib, suffix)
    local lib_sox = format("lib%s.%s.5", lib, suffix)

    % first build the non-shared library in the usual ar/ranlib way

    local S = ""

    if defined("AR_AND_RANLIB_ARE_ONE")
        S = "s"
    end

    ret_code = try_exec("@ar", "cru" & S, lib_a, objects)
    if not equal(ret_code, 0)
        return ret_code
    end

    if not defined("AR_AND_RANLIB_ARE_ONE")
        ret_code = try_exec("@ranlib", lib_a)
        if not equal(ret_code, 0)
            return ret_code
        end
    end

    if not shared
        delete_file(lib_so)
        delete_file(lib_sox)
        return 0
    end

    local soname_opt = "-Wl," & soname_flag & "," & lib_sox
    if equal (TARGET, "I386_INTERIX")
        soname_opt = ""
    end

    % build the shared library
    local pg = ""
    if M3_PROFILING
        pg = "-pg"
    end
    ret_code =
        try_exec(
            "@" & SYSTEM_LD,
            GetGcWrapFlags(),
            pg,
            "-shared",
            soname_opt,
            "-o", lib_sox,
            objects,
            GetM3CoreStaticObjs(lib),
            imported_libs)
    if not equal(ret_code, 0)
        return ret_code
    end

    % create the version aliases
    link_file(lib_sox, lib_so)

    % make sure the shared library stuff gets installed properly
    install_derived(lib_sox)
    install_derived_link(lib_sox, lib_so)
    install_hard_link_to_derived(lib_sox, LIB_INSTALL)
    install_link_to_derived(lib_so, LIB_INSTALL)
    ShipM3CoreStaticObjs(lib)

    return 0
end

end

%-------------------------------------------------------------------
% "skip_lib" is called when the compiler decides it doesn't need to
% call "make_lib", but it wants to discover the names of the derived
% files that should be deleted or shipped.

if not defined("skip_lib")

proc skip_lib(lib, shared) is
    local suffix = "so"
    if equal (TARGET, "PA32_HPUX")
      suffix = "sl" 
    end
    local lib_so = format("lib%s.%s", lib, suffix)
    local lib_sox = format("lib%s.%s.5", lib, suffix)

    if shared
        % create the version aliases
        link_file(lib_sox, lib_so)

        % make sure the shared library stuff gets installed properly
        install_derived(lib_sox)
        install_derived_link(lib_sox, lib_so)
        install_hard_link_to_derived(lib_sox, LIB_INSTALL)
        install_link_to_derived(lib_so, LIB_INSTALL)
        ShipM3CoreStaticObjs(lib)
    else
        delete_file(lib_so)
        delete_file(lib_sox)
    end

    return 0
end

end

%------------------------------------------------------------------- linker ---
% "m3_link" is called to produce a final executable.

if not defined("m3_link")

proc m3_link(prog, options, objects, imported_libs, shared) is
    local args =
    [
        GetGcWrapFlags(),
        "-o", prog,
        options,
        objects,
        FixM3GcDefs(imported_libs),
        GetM3CoreStaticObjs(""),
    ]
    if M3_PROFILING
        args += "-pg"
    end
    if defined("POSITION_INDEPENDENT_EXECUTABLE")
        args += POSITION_INDEPENDENT_EXECUTABLE
    end
    return try_exec("@" & SYSTEM_LD, args)
end

end

%------------------------------------------------------------ misc. options ---
% Note, most of these options can be set from the command line.  Otherwise,
% they can be set "permanently" here in the config file or in as needed
% in user's m3makefiles.

M3_COVERAGE_LIB = LIB_USE & "/report_coverage.o"
% --- library linked in programs compiled with "-Z" coverage option

M3_SPLIT_LIBNAMES = TRUE
% --- split library names and pass -L/-l arguments to the linker

if not defined("M3_SHARED_LIB_ARG")
  M3_SHARED_LIB_ARG = "-Wl,-R"
end
% --- pass "-R" flags to the linker too.
