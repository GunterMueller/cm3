%
% $Id: NT386.common,v 1.11 2008-02-04 07:30:18 jkrell Exp $
%
% Copyright 1996-2000 Critical Mass, Inc. All rights reserved.
% See file COPYRIGHT-CMASS for details.
%
% Common parameterized configuration file for an x86 machine running Windows NT or perhaps Windows 95,

%-------------------------------------------------- compilation environment ---

readonly WORD_SIZE    = "32BITS"            % { "32BITS" or "64BITS" }

%
% These are usually NOT needed.
% They enable some unusual tool/runtime combinations that
% may aid debugging. Specifically, they are for using the MS linker
% to target the Cygwin runtime, which in concert with the
% integrated backend, enables debugging using Microsoft debuggers.
%
% for /f %a in ('gcc --print-libgcc') do cygpath --windows %a
%
readonly LIBGCC = "C:\\cygwin\\lib\\gcc\\i686-pc-cygwin\\3.4.4\\libgcc.a"

%-------------------------------------------------- default compile options ---
% "set_config_options" is called before starting the compilation. It should
% be used to provide system-wide default options.

proc
set_config_options(
    )
is
    m3_option("-why")   %-- produce a listing that explains what's happening and why
    m3_debug(TRUE)      %-- produce object code with debugging symbols
    M3_OPTIONS += "-w1"  %-- produce "level 1" warnings
end

%------------------------------------------------------------- export paths ---
% During the installation, destination directories that do not exists
% will be created. You need the necessary permissions to do so; otherwise,
% the installation will fail, but can be restarted after you have
% fixed the permissions.

readonly
proc
CM3SetInstallRoot(
    )
is
    if defined("INSTALL_ROOT")
        return
    end
    if not equal($CM3_INSTALL, "")
        INSTALL_ROOT = $CM3_INSTALL
        return
    end
    if not equal($INSTALLROOT, "")
        INSTALL_ROOT = $INSTALLROOT
        return
    end
    INSTALL_ROOT = (path() & SL & "..")
end

CM3SetInstallRoot()

readonly BIN_INSTALL    = INSTALL_ROOT & SL & "bin"     % executables
readonly LIB_INSTALL    = INSTALL_ROOT & SL & "lib" & PROFILING_P   % libraries
readonly PKG_INSTALL    = INSTALL_ROOT & SL & "pkg"     % packages
readonly DOC_INSTALL    = INSTALL_ROOT & SL & "doc"     % documents
readonly EMACS_INSTALL  = INSTALL_ROOT & SL & "elisp"   % emacs lisp code
readonly MAN_INSTALL    = INSTALL_ROOT & SL & "man"     % man pages
readonly HTML_INSTALL   = INSTALL_ROOT & SL & "www"     % public hypertext

%
% On some systems (e.g. AFS) you must install public files in a different
% place from where you use them. If that is the case for your system,
% specify the "use" location here, otherwise leave them alone.
%
readonly BIN_USE = BIN_INSTALL     % executables
readonly PKG_USE = PKG_INSTALL     % packages

readonly INSTALL_IMPLS = FALSE
% TRUE
%    => save all source files during the install
%    => makes debugging easier and browsing more fruitful
% FALSE
%    => save only the exported interfaces and templates
%    => makes the installed system slightly smaller.

%------------------------------------------------ external system libraries ---
% SYSTEM_LIBS provides a mapping from Modula-3 names for the common
% external libraries to site-dependent information about how they
% are accessed. If SYSTEM_LIBS{x} is defined it should be a list
% of linker arguments that are used when linking against that library.
% If SYSTEM_LIBS{x} is not defined, the Modula-3 system will assume
% that the library is not available.

readonly LibInPrefix  = { "MS" : "",          "GNU" : "-l"  }{LINKER} % aka NAMING_CONVENTIONS
readonly LibInSuffix  = { "MS" : ".lib",      "GNU" : ""    }{LINKER} % aka NAMING_CONVENTIONS
readonly LibPath      = { "MS" : "-libpath:", "GNU" : "-L"  }{LINKER}
readonly LibOutPrefix = { "WIN32" : "",     "POSIX" : "lib" }{OS_TYPE} % aka NAMING_CONVENTIONS
readonly LibOutSuffix = { "WIN32" : ".lib", "POSIX" : ".a"  }{OS_TYPE} % aka NAMING_CONVENTIONS
readonly Obj          = { "WIN32" : ".obj", "POSIX" : ".o"  }{OS_TYPE} % aka NAMING_CONVENTIONS

local
readonly
proc
LibOut(
    a,
    )
is
    return LibOutPrefix & a & LibOutSuffix
end

local
readonly
proc
LibIn(
    a,
    )
is
    return LibInPrefix & a & LibInSuffix
end

SYSTEM_LIBS_MS =
{
    "LIBC" :
    [
        LibIn("winspool"),
        LibIn("comctl32"),
        LibIn("wsock32"),
        LibIn("comdlg32"),
        LibIn("netapi32"),
        LibIn("gdi32"),
        LibIn("user32"),
        LibIn("advapi32"),
        LibIn("kernel32"),
    ],
    "ODBC" : [LibIn("odbc32")],
    "OPENGL" : [LibIn("opengl32"), LibIn("glu32")],
    "TCP" : [ ],
}

SYSTEM_LIBS_GNU =
{
% be sure to see what empty strings do here to fold this down
    "LIBC" :
    [
%       LibIn("winspool"),
        LibIn("comctl32"),
        LibIn("wsock32"),
%       LibIn("comdlg32"),
        LibIn("netapi32"),
        LibIn("gdi32"),
        LibIn("user32"),
%       LibIn("advapi32"),
%       LibIn("kernel32"),
    ],
    "ODBC" : [LibIn("odbc32")], %  -lodbccp32 ?
    "OPENGL" : [LibIn("glu32"), LibIn("opengl32")], % -lglut32 ?
    "TCP" : [ ],
}

SYSTEM_LIBS = { "MS" : SYSTEM_LIBS_MS, "GNU" : SYSTEM_LIBS_GNU }{LINKER}

%
% Need to fill in X Windows for CygwinX
%

if equal(OS_TYPE, "WIN32")

%
% We must explicitly specify libcmt.lib or msvcrt.lib
% in our link command because many links contain no C code and
% no /defaultlib directives. The Modula-3 backend should perhaps
% output those directives.
%
% Cutting the C runtime dependency from Modula-3 may be desirable.
%
% The environment variable USE_MSVCRT is 0, 1, or not defined.
% Not defined is treated as 1. This is a safe default for the
% vast majority of toolsets, but not all.
%
    if not equal($USE_MSVCRT, "0")
        if not equal($USE_MSVCRT, "1")
            if not equal($USE_MSVCRT, "")
                error("The environment variable USE_MSVCRT should be 0, 1, or not defined, but it is " & $USE_MSVCRT & "." & EOL)
            end
        end
    end

    if not defined("USE_MSVCRT")
        if equal($USE_MSVCRT, "0")
            USE_MSVCRT = FALSE
        else
            USE_MSVCRT = TRUE
        end
    end

    if USE_MSVCRT
        SYSTEM_LIBS{"LIBC"} += [LibIn("msvcrt")]
    else
        SYSTEM_LIBS{"LIBC"} += [LibIn("libcmt")]
    end

else
    %
    % This needs work.
    % It is for using the integrated backend and MS linker with Cygwin runtime
    % to enable more debugging scenarios.
    %
    USE_MSVCRT = TRUE
    %USE_DELAYLOAD = FALSE
    if equal(LINKER, "MS")
        % crt0.o requires being linked with ld.
        %SYSTEM_LIBS{"LIBC"} += [LIBGCC, LIBGCC & "/../../../../crt0.o", LIBGCC & "/../../../../libcygwin.a" ]
        SYSTEM_LIBS{"LIBC"} += [LibIn("msvcrt")]
        SYSTEM_LIBS{"LIBC"} += [LIBGCC, LIBGCC & "/../../../../libcygwin.a" ]
    end
end

% SYSTEM_LIBORDER defines the order in which SYSTEM_LIBS should be
% scanned by the linker.

SYSTEM_LIBORDER =
[
    "OPENGL",
    "TCP",
    "ODBC",
    "LIBC",
]

%--------------------------------------------------------- Modula-3 backend ---
% For platforms without an integrated backend, "m3_backend" is called to
% translate Modula-3 intermediate code to object code.

m3back = "@cm3cg"
m3back_options = [ ]

%
% -mno-align-double is VERY IMPORTANT
% because the Modula-3 compiler has already computed various
% offsets and the backend should not, must not change them.
%
% If you remove this, the floating point number in RTHeapInfo.m3
% gets aligned and the runtime linking information is then
% not at the expected offset and you crash in startup.
%
m3back_options += "-mno-align-double"

%
% Don't depend on cygwin1.dll.
%
if equal(OS_TYPE, "WIN32")
    m3back_options += "-mno-cygwin"
end

%
% Don't report timings and such.
%
m3back_options += "-quiet"

m3back_optimize = [ ]
m3back_optimize += "-O"

%
% This requires -O.
%
m3back_optimize += "-Wuninitialized"

proc
m3_backend(
    source,
    object,
    optimize,
    debug,
    )
is
    local args = [source, "-o", object]
    if optimize
        args += m3back_optimize
    end
    %
    % -g provides a little more information than -gstabs
    % -g is the same as -gstabs+
    % -ggdb crashes
    %
    args += "-g"
    args += m3back_options
    if M3_PROFILING
        args += "-p"
    end
    return try_exec(m3back, args)
end

%------------------------------------------------------------------------------

proc
FileExists(
    a,
    )
is
    return not stale(a, a)
end

%------------------------------------------------------------------------------

proc
DeleteFile(
    a,
    )
is
    delete_file(a)
end

%------------------------------------------------------------------------------

readonly OS = $OS

proc
MoveFile(
    a,
    b,
    )
is
    if equal(OS, "Windows_NT")
        exec("@cmd", "/c", "move", a, b)
    else
        exec("@mv", a, b)
    end
end

%------------------------------------------------------------------------------

proc
DeleteFiles(
    a
    )
is
    foreach b in a
        DeleteFile(b)
    end
end

%--------------------------------------------------------------- C compiler ---
% "compile_c" is called to compile C source files. Note that this function
% is only called if your program or library explicitly includes C source
% code, the system distributed by Critical Mass does not.

proc
compile_c_ms(
    source,
    object,
    options,
    optimize,
    debug,
    )
is
    local args =
    [
%
% Be quiet. Remove this if response file are used, since it
% inhibits the compiler dumping the response file, which is useful
% in any log.
%
        "-nologo",
%
% Put type information in .objs/.libs instead of shared in vc80.pdb, etc.
% vc80.pdb can be renamed with /Fd, we'd need the target name.
% This is bigger/slower but has advantages too.
% Debug information does not inhibit optimization so always generate it.
%
        "-Z7",
%
% needed for older headers such as with Visual C++ 2.0
%
        "-DWIN32",
        options
    ]
    if USE_MSVCRT
        %
        % Use msvcrt.lib and define _MT and _DLL.
        %
        args += ["-MD"]
    else
        %
        % Use libcmt.lib and define _MT.
        %
        args += ["-MT"]
    end
    if optimize
        args += "-Ox"
    end
    args += "-Oi"
    return try_exec("cl", [args, "-c", source])
end

proc
compile_c_gnu(
    source,
    object,
    options,
    optimize,
    debug,
    )
is
    local args = options
    if optimize
        args += "-O"
    end
    if debug
        % -g provides a little more information than -gstabs
        % -g is the same as -gstabs+
        % -ggdb crashes
        args += "-g"
    end
    if M3_PROFILING
        args += "-pg"
    end
    return try_exec("gcc", args, "-c", source, "-o", object)
end

proc
compile_c(
    source,
    object,
    options,
    optimize,
    debug,
    )
is
    if equal(C_COMPILER, "MS")
        return compile_c_ms(source, object, options, optimize, debug)
    end
    return compile_c_gnu(source, object, options, optimize, debug)
end

%---------------------------------------------------------------- assembler ---
% "assemble" is called to assemble .s or .asm files. Note that this function
% is only called if your program or library explicitly includes assembly source
% code, the system distributed by Critical Mass does not.

%
% not used
%
proc
assemble_ms(
    source,
    object,
    )
is
    local args = arglist("@", ["-Ml", "-t", "-z", source & "," & object & ";"])
    return try_exec("masm386", args)
end

proc
assemble_gnu(
    source,
    object,
    )
is
    return try_exec("@as", source, "-o", object)
end

proc
assemble(
    source,
    object,
    )
is
    return assemble_gnu(source, object)
end

%------------------------------------------------------------------------------

%
% Quake can't do math, or generate unique temp files,
% at least not that it cleans up.
%
% Uniqueness is not critical here, it is merely useful
% while debugging to go back and see the temp files.
%
% It is also good to put files in a place where they
% will reliably get deleted -- not TEMP.
%
% It is open question as to if carry over to two digits
% can be implemented in Quake. :)
%

ResponseFileCounter = "0"

readonly
proc
GetResponseFileName(
    )
is
    local readonly Result = "_m3responsefile" & ResponseFileCounter & ".txt"
    ResponseFileCounter =
        { "0":"1","1":"2","2":"3","3":"4","4":"5",
          "5":"6","6":"7","7":"8","8":"9","9":"0", }{ResponseFileCounter}
    return Result
end

%
% mklib wants newlines, so a direct write doesn't work
% I couldn't get anything with write to work, nothing would handle
% plain parameters and lists
%
readonly
proc
WriteResponseFile(
    File,
    Divider,
    Args,
    )
is
    local readonly Temp = arglist("", Args)
    if equal(Temp, Args)
        if equal(Divider, " ")
            return Temp
        end
        %
        % Quake has a fixed size limit on strings, after which it crashes.
        % Hopefully that our parameter list is too short to be in a response
        % file implies it is short enough to fit in a string.
        %
        local Result = ""
        foreach Arg in Args
            if Result
                Result = Result & Divider
            end
            Result = Result & Arg
        end
        return Result
    end
    MoveFile(Temp, File)
    DeleteFile(Temp)
    return "@" & File
end

%------------------------------------------------------------------------------

readonly
proc
GetPackageDirectory(
    )
is
    %
    % older builds, such as 5.1.3, do not define PACKAGE_DIR
    %
    if defined("PACKAGE_DIR")
        return PACKAGE_DIR & SL
    end
    return ""
end

%------------------------------------------------------------------------------

readonly
proc
ConvertLibsToStandalone(
    imported_libs,
    shared,
    )
is
    if shared
        return imported_libs
    end
    local imports = [ ]
    foreach f in imported_libs
        local ff = f & ".sa"
        if FileExists(ff)
            imports += ff
        else
            imports += f
        end
    end
    return imports
end

%------------------------------------------------------------------------------

% A "pdb' is a "program database", that is, a Microsoft symbol file.

readonly
proc
PdbExport(
    pdb,
    )
is
    if FileExists(pdb)
        BindExport(pdb)
    end
end

%------------------------------------------------------------------------------

readonly
proc
ManifestTool(
    DllOrExe,
    ManifestFile,
    ResourceId,
    )
is
    %
    % http://msdn2.microsoft.com/en-us/library/ms235591.aspx
    %
    if FileExists(ManifestFile)
        ret_code = try_exec("mt /nologo /manifest " & ManifestFile & " /outputresource:" & DllOrExe & ";" & ResourceId)
        if not equal(ret_code, 0)
            return ret_code
        end
        DeleteFile(ManifestFile)
    end
    return 0
end

%------------------------------------------------------------------------------

%
% Modula-3 has fixed sized buffers and fails assertions if we try
% to give it more than 1k. This is lame.
%
readonly
proc
EscapeList(
    List
    )
is
    local Result = [ ]
    foreach Element in List
        Result += escape(Element)
    end
    return Result
end

%--------------------------------------------------------- library creation ---
% "make_lib" is called to combine a collection of object modules into
% a library.

%% NOTE: we should set the "base" load address of the various DLLs
%%  to avoid relocating them every time they are loaded.

%
% make_lib and m3_link need to share code!
%

proc
make_dll_ms(
    options,
    objects,
    imported_libs,
    lib_file,
    def_file,
    dll_file,
    listing,
    LinkResponseFile,
    )
is
    %
    % Noentry cuts out the C runtime startup code,
    % which usually brings in most of our dependency on msvcr*.dll.
    % This leaves most Modula-3 .dlls using very few C runtime functions,
    % mainly setjmp for exception handling, and sometimes memmove, and
    % sometimes a few other functions.
    % This will break some scenarios that mix C and C++ with Modula-3, but
    % should get a link warning. Therefore this probably be configurable,
    % with the default being noentry.
    %
    % We don't use this when using libcmt.lib since that brings in more "real"
    % code that might require the initialization.
    %
    % For .exes a minimal custom entry point could be used, like:
    %  for gui: return WinMain(GetCommandLine(), GetModuleHandle(NULL), GetStartupInfo()...);
    %  for console: getmainargs...
    %
    % It would be nice to reduce the C runtime dependency to zero at some point.
    % On the other hand, it would be nice to get back a backend that generates
    % portable C, in order to get good codegen, on more platforms, without gcc.
    %
    if USE_MSVCRT
        options += "-noentry"
    end

    return try_exec(
        "link",
        WriteResponseFile(
            LinkResponseFile,
            " ",
            [
                m3_link_flags,
                "-def:" & def_file,
                "-dll",
                "-out:" & dll_file,
                 options,
                 objects,
                 imported_libs,
            ]),
        "2>&1",
        ">", listing
        )
end

proc
make_dll_gnu(
    options,
    objects,
    imported_libs,
    lib_file,
    def_file,
    dll_file,
    listing,
    LinkResponseFile,
    )
is
    if M3_PROFILING 
        objects += "-pg"
    end

    return try_exec(
            "gcc",
            %"-v",
            "-shared", % must be visible to compiler
            "-Wl," &
                WriteResponseFile(
                    LinkResponseFile,
                    ",",
                    [
                        "--output",
                        dll_file,
                        "--out-implib",
                        lib_file,
                        %"--export-all-symbols",
                        "--enable-auto-image-base",
                        "--warn-duplicate-exports",
                        "--disable-auto-import",
                        "--disable-runtime-pseudo-reloc",
                        "--large-address-aware",
                        objects,
                        EscapeList(imported_libs),
                    ]),
            "2>&1",
            ">", listing
            )
end

proc
make_lib(
    lib,
    options,
    objects,
    imported_libs,
    shared,
    )
is
    local ret_code = 0

    local readonly lib_file = lib & ".lib"
    local readonly lib0_file = lib & ".lib.sa"
    local readonly def_file = lib & ".def"
    local readonly dll_file = lib & ".dll"
    local readonly manifest_file  = dll_file & ".manifest"
    local readonly pdb_file = lib & ".pdb"
    local readonly listing  = lib & ".lst"
    local LibResponseFile = GetResponseFileName()
    local LinkResponseFile = LibResponseFile

    if shared
        LinkResponseFile = GetResponseFileName()
    end

    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        def_file,
        listing,
        manifest_file,
        pdb_file,
        LibResponseFile,
        LinkResponseFile,
        lib & ".ilk",
        ]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    local m3_lib_flags = [ ]
    if equal(LINKER, "MS")
        % m3_lib_flags = ["-debugtype:cv", "-machine:i386"]
        m3_lib_flags = ["-ign:__real"]
    end

    % build the static library

    local ret_code = try_exec(
        "mklib",
        WriteResponseFile(
            LibResponseFile,
            " ",
            [
                m3_lib_flags,
                "-out:" & lib_file,
                options,
                objects,
            ]),
        "2>&1",
        ">", listing
        )
    if not equal(ret_code, 0) or not FileExists(lib_file)
        error(
            "library creation failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL
            )
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end

    if shared

        % build an import library & DLL

        MoveFile(lib_file, lib0_file)

        if equal(LINKER, "MS")
            ret_code =
                make_dll_ms(
                    options,
                    objects,
                    imported_libs,
                    lib_file,
                    def_file,
                    dll_file,
                    listing,
                    LinkResponseFile,
                    )
        else
            ret_code =
                make_dll_gnu(
                    options,
                    objects,
                    imported_libs,
                    lib_file,
                    def_file,
                    dll_file,
                    listing,
                    LinkResponseFile,
                    )
        end

        if not equal(ret_code, 0) or not FileExists(dll_file)
            error(
                "dynamic link library creation failed, see "
                & GetPackageDirectory()
                & BUILD_DIR
                & SL
                & listing
                & " for more information"
                & EOL
                )
            if not equal(ret_code, 0)
                return ret_code
            end
            return 1
        end

        ret_code = ManifestTool(dll_file, manifest_file, "2")
        if not equal(ret_code, 0)
            return ret_code
        end

        BindExport(dll_file)
        PdbExport(pdb_file)
        install_derived(lib0_file)

    end
    return ret_code
end

%-------------------------------------------------------------------
% "skip_lib" is called when the compiler decides it doesn't need to
% call "make_lib", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc
skip_lib(
    lib,
    shared,
    )
is
    local lib_file  = lib & ".lib"
    local lib0_file = lib & ".lib.sa"
    local def_file  = lib & ".def"
    local dll_file  = lib & ".dll"
    local manifest_file  = dll_file & ".manifest"
    local pdb_file  = lib & ".pdb"
    local listing   = lib & ".lst"

    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        def_file,
        listing,
        manifest_file,
        pdb_file,
        lib & ".ilk",
        ]

    % make sure files get cleaned up
    deriveds("", Outputs)

    if shared
        % would have built an import library & DLL
        BindExport(dll_file)
        DeleteFile(manifest_file)
        PdbExport(pdb_file)
        install_derived(lib0_file)
    else
        DeleteFile(lib0_file)
        DeleteFile(dll_file)
        DeleteFile(manifest_file)
        DeleteFile(pdb_file)
    end

    return 0
end

%------------------------------------------------------------------- linker ---
% "m3_link" is called to produce a final executable.

m3_link_flags =
[
%
% Ignore that some .libs think they want libc.lib.
% This should not needed in a full coherent build, however
% existing distributions, such as 5.2.6, have C code built
% without /MD or /MT and bootstrapping uses their files,
% such as m3core.lib.sa(hand.obj).
%
% Cutting the C runtime dependency from Modula-3 may be desirable.
%
	"-nodefaultlib",
%
% Generate a .pdb for debugging.
%
    "-debug",
%
% Spend a little longer producing a slightly smaller/faster .dll/.exe and
% avoid some warnings.
%
    "-incremental:no",
%
% Remove unused code/data.
%
    "-opt:ref",
%
% With newer linkers, combine identical code/data.
%
%   "-opt:icf",
]

%
% The environment variable USE_DELAYLOAD is 0, 1, or not defined.
% Not defined is treated as 1. This is a safe default for
% linker versions going back a long way, but not infinitely so.
% sysinfo.cmd sets it based on probing the environment.
%
if not equal($USE_DELAYLOAD, "0")
    if not equal($USE_DELAYLOAD, "1")
        if not equal($USE_DELAYLOAD, "")
            error("The environment variable USE_DELAYLOAD should be 0, 1, or not defined, but it is " & $USE_DELAYLOAD & "." & EOL)
        end
    end
end

if not defined("USE_DELAYLOAD")
    if equal($USE_DELAYLOAD, "0")
        USE_DELAYLOAD = FALSE
    else
        USE_DELAYLOAD = TRUE
    end
end

if USE_DELAYLOAD
    m3_link_flags +=
    [
    %
    % The default static dependencies of Modula-3 binaries
    % are larger than they should be. Reduce them sleazily via delayload.
    % This requires a Visual C++ 6.0 or newer linker.
    %
        "-delayload:wsock32.dll",
        "-delayload:advapi32.dll",
        "-delayload:gdi32.dll",
        "-delayload:netapi32.dll",
        "-delayload:user32.dll",
        "-delayload:comctl32.dll",
        "delayimp.lib",
    ]
end

%------------------------------------------------------------------------------

proc
m3_link_ms(
    prog,
    options,
    objects,
    imported_libs,
    shared,
    pgm_file,
    listing,
    LinkResponseFile,
    )
is
    local entry = ["-subsystem:console", "-entry:mainCRTStartup"]
    if defined("M3_WINDOWS_GUI")
        if M3_WINDOWS_GUI
            entry = ["-subsystem:windows", "-entry:WinMainCRTStartup"]
        end
    end

    return try_exec(
        "link",
        WriteResponseFile(
            LinkResponseFile,
            " ",
            [
                "-out:" & pgm_file,
                entry,
                m3_link_flags,
                options,
                objects,
                imported_libs,
            ]),
        "2>&1",
        ">", listing
        )
end

proc
m3_link_gnu(
    prog,
    options,
    objects,
    imported_libs,
    shared,
    pgm_file,
    listing,
    LinkResponseFile,
    )
is
    if not shared
        %options += "-static"
    end
    if M3_PROFILING
        options += "-pg"
    end

    % not tested
    % if not defined("M3_WINDOWS_GUI")
    %   M3_WINDOWS_GUI = FALSE
    % end
    % if M3_WINDOWS_GUI
    %   options += "-mwindows"
    % else
    %   options += "-mconsole"
    % end

    return try_exec(
            "gcc",
            "-g",
            %"-v",
            "-Wl," &
                WriteResponseFile(
                    LinkResponseFile,
                    ",",
                    [
                        "--output",
                        pgm_file,
                        options,
                        objects,
                        EscapeList(imported_libs),
                    ]),
            "2>&1",
            ">", listing
            )
end

proc
m3_link(
    prog,
    options,
    objects,
    imported_libs,
    shared,
    )
is
    local ret_code = 0
    local readonly pgm_file = prog & ".exe"
    local readonly manifest_file = pgm_file & ".manifest"
    local readonly pdb_file = prog & ".pdb"
    local readonly listing  = prog & ".lst"
    local LinkResponseFile = GetResponseFileName()

    local readonly Outputs = [
        pgm_file,
        listing,
        manifest_file,
        pdb_file,
        LinkResponseFile,
        prog & ".ilk",
        ]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    imported_libs = ConvertLibsToStandalone(imported_libs, shared)

    if equal(LINKER, "MS")
        ret_code = m3_link_ms(
            prog,
            options,
            objects,
            imported_libs,
            shared,
            pgm_file,
            listing,
            LinkResponseFile,
            )
    else
        ret_code = m3_link_gnu(
            prog,
            options,
            objects,
            imported_libs,
            shared,
            pgm_file,
            listing,
            LinkResponseFile
            )
    end

    if not equal(ret_code, 0) or not FileExists(pgm_file)
        error(
            "link failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL
            )
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end

    ret_code = ManifestTool(pgm_file, manifest_file, "1")
    if not equal(ret_code, 0)
        return ret_code
    end

    PdbExport(pdb_file)

    return ret_code
end

%-------------------------------------------------------------------
% "skip_link" is called when the compiler decides it doesn't need to
% call "m3_link", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc
skip_link(
    prog,
    shared,
    )
is
    local readonly pgm_file = prog & ".exe"
    local readonly manifest_file = pgm_file & ".manifest"
    local readonly pdb_file = prog & ".pdb"
    local readonly listing  = prog & ".lst"

    local readonly Outputs = [
        pgm_file,
        listing,
        manifest_file,
        pdb_file,
        prog & ".ilk",
    ]

    % make sure files get cleaned up
    deriveds("", Outputs)

    BindExport(pgm_file)
    DeleteFile(manifest_file)
    PdbExport(pdb_file)

    return 0
end

%------------------------------------------------------------ misc. options ---
% Note, most of these options can be set from the command line. Otherwise,
% they can be set "permanently" here in the config file or in as needed
% in user's m3makefiles.

if equal(M3_BACKEND_MODE, "0") or equal(M3_BACKEND_MODE, "1")
    M3_FRONT_FLAGS = ["-unfold_nested_procs", "-check_procs"]
% --- internal configuration options passed directly to the Modula-3 front-end
else
    M3_FRONT_FLAGS = [ ]
end

M3_OPTIONS = [ ]
% --- user options passed directly to the Modula-3 front-end

M3_KEEP_FILES = TRUE
% --- keep intermediate and temporary files

% M3_WINDOWS_GUI = TRUE
% --- generate a Windows GUI subsystem program instead of a console one.

% M3_COVERAGE = TRUE
% --- compile & link with coverage options

M3_COVERAGE_LIB = "report_coverage" & Obj
% --- library linked in programs compiled with "-Z" coverage option

M3_SPLIT_LIBNAMES = FALSE
% --- split library names and pass -L/-l arguments to the linker

% M3_SHARED_LIB_ARG = ""
% --- pass "-R" flags to the linker too.

% M3_BOOTSTRAP = TRUE
% --- generate bootstrap code (assembly) instead of finaly object code

% M3_COMPILE_ONCE = TRUE
% --- don't recompile code to improve opaque object references

% SYS_HAS_LOADER = TRUE
% --- generate a loader info file with objects, libraries and timestamps

% M3_SKIP_LINK = TRUE
% --- skip the final link for programs, presumably to use the loader instead

% M3_MAIN_IN_C = TRUE
% --- generate the Modula-3 main program as C code

X11_WITH_SHARED_MEM = TRUE
% --- X11 libraries include the shared memory extensions (XShm...)

M3_NEED_STANDALONE_LINKS = FALSE
% --- linker is broken and we need to build a directory of symbolic
%     links pointing to the non-shared libraries.

%-------------------------------------------------------------------- emacs ---
% If you have emacs and want to compile ".el" files to ".elc" files,
% fill in the function below. Otherwise, comment out or delete the
% entire function. Note, the distributed code assumes gnuemacs version 19
% or later.

readonly
proc
emacs_compile(
    el,
    )
is
    exec("emacs -batch -f batch-byte-compile", el)
end
