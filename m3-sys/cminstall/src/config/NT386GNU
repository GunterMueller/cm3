% Copyright 1996 Critical Mass, Inc. All rights reserved.
%
%
% configuration file for NT386 using gcc backend
%

%-------------------------------------------------- compilation environment ---

%M3_PROFILING = TRUE  % set by cm3 since 5.1.2 (option -profile)
%M3_PROFILING = FALSE

if M3_PROFILING
    readonly PROFILING_P = "p"
else
    readonly PROFILING_P = ""
end

readonly TARGET       = "NT386GNU"              % code generation target
readonly BUILD_DIR    = TARGET & PROFILING_P    % directory for results
readonly OS_TYPE      = "WIN32"                 % { "WIN32" or "POSIX" }
readonly WORD_SIZE    = "32BITS"                % { "32BITS" or "64BITS" }
readonly GNU_PLATFORM = "i486-pc-cygwin"        % "cpu-vendor-os" string for GNU

readonly NAMING_CONVENTIONS = "2"
%                                        object files       libraries
%  0=Unix                          =>  .o   .io    .mo       libXX.a
%  1=Unix with a grumpy C compiler =>  .o   _i.o   _m.o      libXX.a
%  2=Windows NT or Windows 95      =>  .obj .io    .mo       XX.lib
%

%-------------------------------------------------- default compile options ---
% "set_config_options" is called before starting the compilation. It should
% be used to provide system-wide default options.

proc
set_config_options(
    )
is
    m3_option("-why")   %-- produce a listing that explains what's happening and why
    m3_debug(TRUE)      %-- produce object code with debugging symbols
    M3_OPTIONS += "-w1"  %-- produce "level 1" warnings
end

%------------------------------------------------------------- export paths ---
% During the installation, destination directories that do not exists 
% will be created. You need the necessary permissions to do so; otherwise,
% the installation will fail, but can be restarted after you have 
% fixed the permissions.

readonly
proc
CM3SetInstallRoot(
    )
is
    if defined("INSTALL_ROOT")
        return
    end
    if not equal($CM3_INSTALL, "")
        INSTALL_ROOT = $CM3_INSTALL
        return
    end
    if not equal($INSTALLROOT, "")
        INSTALL_ROOT = $INSTALLROOT
        return
    end
    INSTALL_ROOT = (path() & SL & "..")
end

CM3SetInstallRoot()

readonly BIN_INSTALL    = INSTALL_ROOT & SL & "bin"     % executables
readonly LIB_INSTALL    = INSTALL_ROOT & SL & "lib" & PROFILING_P   % libraries
readonly PKG_INSTALL    = INSTALL_ROOT & SL & "pkg"     % packages
readonly DOC_INSTALL    = INSTALL_ROOT & SL & "doc"     % documents
readonly EMACS_INSTALL  = INSTALL_ROOT & SL & "elisp"   % emacs lisp code
readonly MAN_INSTALL    = INSTALL_ROOT & SL & "man"     % man pages
readonly HTML_INSTALL   = INSTALL_ROOT & SL & "www"     % public hypertext

%
% On some systems (e.g. AFS) you must install public files in a different
% place from where you use them. If that is the case for your system,
% specify the "use" location here, otherwise leave them alone.
%
BIN_USE   = BIN_INSTALL     % executables
PKG_USE   = PKG_INSTALL     % packages

readonly INSTALL_IMPLS = FALSE
% TRUE
%    => save all source files during the install
%    => makes debugging easier and browsing more fruitful
% FALSE
%    => save only the exported interfaces and templates 
%    => makes the installed system slightly smaller.

%------------------------------------------------ external system libraries ---
% SYSTEM_LIBS provides a mapping from Modula-3 names for the common
% external libraries to site-dependent information about how they
% are accessed. If SYSTEM_LIBS{x} is defined it should be a list
% of linker arguments that are used when linking against that library.
% If SYSTEM_LIBS{x} is not defined, the Modula-3 system will assume
% that the library is not available.

SYSTEM_LIBS =
{
    "LIBC" :
    [
%       "-lwinspool",
        "-lcomctl32",
        "-lwsock32",
%       "-lcomdlg32",
        "-lnetapi32",
        "-lgdi32",
        "-luser32",
%       "-ladvapi32",
%       "-lkernel32",
    ],
    "ODBC" : ["-lodbc32"], %  -lodbccp32 ?
    "OPENGL" : ["-lglu32", "-lopengl32"], % -lglut32 ?
    "TCP" : [ ],
}

% SYSTEM_LIBORDER defines the order in which SYSTEM_LIBS should be
% scanned by the linker.

SYSTEM_LIBORDER =
[
    "OPENGL",
    "TCP",
    "ODBC",
    "LIBC",
]

%---------------------------------------------------------- system programs ---

readonly SYSTEM_CC  = "gcc" % C compiler
readonly SYSTEM_ASM = "as"  % Assembler

%--------------------------------------------------------- Modula-3 backend ---
% For platforms without an integrated backend, "m3_backend" is called to
% translate Modula-3 intermediate code to object code.

readonly m3back = "@cm3cg"

proc
m3_backend(
    source,
    object,
    optimize,
    debug,
    )
is
    local args = ["-quiet", source, "-o", object]
    if optimize
        args += "-O"
    end
    if debug
        args += "-gstabs"
    end
    if M3_PROFILING
        args += "-p"
    end
    return try_exec(m3back, args)
end

M3_BACKEND_MODE = "3"
% -- defines how the frontend, backend, and assembler interact
%  "0"  -- don't call m3_backend, M3CG produces object code
%  "1"  -- don't call m3_backend, M3CG produces assembly code
%  "2"  -- call m3_backend, it produces object code
%  "3"  -- call m3_backend, it produces assembly code

%------------------------------------------------------------------------------

proc
FileExists(
    a,
    )
is
    return not stale(a, a)
end

%------------------------------------------------------------------------------

proc
DeleteFile(
    a,
    )
is
    delete_file(a)
end

%------------------------------------------------------------------------------

readonly OS = $OS

proc
MoveFile(
    a,
    b,
    )
is
    if equal(OS, "Windows_NT")
        exec("@move", a, b)
    else
        exec("@mv", a, b)
    end
end

%------------------------------------------------------------------------------

proc
DeleteFiles(
    a
    )
is
    foreach b in a
        DeleteFile(b)
    end
end

%--------------------------------------------------------------- C compiler ---
% "compile_c" is called to compile C source files. Note that this function
% is only called if your program or library explicitly includes C source
% code, the system distributed by Critical Mass does not.

proc
compile_c(
    source,
    object,
    options,
    optimize,
    debug,
    )
is
    local args = options
    if optimize
        args += "-O"
    end
    if debug
        args += "-gstabs"
    end
    if M3_PROFILING
        args += "-pg"
    end
    return try_exec("@" & SYSTEM_CC, args, "-c", source, "-o", object)
end

%---------------------------------------------------------------- assembler ---
% "assemble" is called to assemble .s or .asm files. Note that this function
% is only called if your program or library explicitly includes assembly source
% code, the system distributed by Critical Mass does not.

proc
assemble(
    source,
    object,
    )
is
    return try_exec("@" & SYSTEM_ASM, source, "-o", object)
end

%------------------------------------------------------------------------------

%
% Quake can't do math, or generate unique temp files,
% at least not that it cleans up.
%
% Uniqueness is not critical here, it is merely useful
% while debugging to go back and see the temp files.
%
% It is also good to put files in a place where they
% will reliably get deleted -- not TEMP.
%
% It is open question as to if carry over to two digits
% can be implemented in Quake. :)
%
ResponseFileCounter = "0"

readonly
proc
GetResponseFileName(
    )
is
    local readonly Result = "_m3responsefile" & ResponseFileCounter & ".txt"
    ResponseFileCounter =
        { "0":"1","1":"2","2":"3","3":"4","4":"5",
          "5":"6","6":"7","7":"8","8":"9","9":"0", }{ResponseFileCounter}
    return Result
end

%
% mklib wants newlines, so a direct write doesn't work
% I couldn't get anything with write to work, nothing would handle
% plain parameters and lists
%
readonly
proc
WriteResponseFile(
    File,
    Args,
    )
is
    local readonly Temp = arglist("", Args)
    if equal(Temp, Args)
        return Temp
    end
    MoveFile(Temp, File)
    DeleteFile(Temp)
    return "@" & File
end

%------------------------------------------------------------------------------

readonly
proc
GetPackageDirectory(
    )
is
    %
    % older builds, such as 5.1.3, do not define PACKAGE_DIR
    %
    if defined("PACKAGE_DIR")
        return PACKAGE_DIR & SL
    end
    return ""
end

%------------------------------------------------------------------------------

readonly
proc
ConvertLibsToStandalone(
    imported_libs,
    shared,
    )
is
    if shared
        return imported_libs
    end
    local imports = [ ]
    foreach f in imported_libs
        local ff = f & ".sa"
        if FileExists(ff)
            imports += ff
        else
            imports += f
        end
    end
    return imports
end

%--------------------------------------------------------- library creation ---
% "make_lib" is called to combine a collection of object modules into
% a library.

%% NOTE: we should set the "base" load address of the various DLLs
%%  to avoid relocating them every time they are loaded.

%% m3_lib_flags = ["-debugtype:cv", "-machine:i386"]
m3_lib_flags = ["-ign:__real"]

%
% make_lib and m3_link need to share code!
%

proc
make_lib(
    lib,
    options,
    objects,
    imported_libs,
    shared,
    )
is
    local readonly lib_file = lib & ".lib"
    local readonly lib0_file = lib & ".lib.sa"
    local readonly dll_file = lib & ".dll"
    local readonly listing  = lib & ".lst"
    local LibResponseFile = GetResponseFileName()
    local LinkResponseFile = GetResponseFileName()
    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        listing,
        LibResponseFile,
        LinkResponseFile,
        ]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    % build the static library

    LibResponseFile =
        WriteResponseFile(
            LibResponseFile,
            [
                m3_lib_flags,
                "-out:" & lib_file,
                options,
                objects,
            ])

    local ret_code = try_exec("@mklib", LibResponseFile, ">", listing)
    if not equal(ret_code, 0) or not FileExists(lib_file)
        error(
            "library creation failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL
            )
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end

    if shared

        % build an import library & DLL

        MoveFile(lib_file, lib0_file)

        if M3_PROFILING 
            objects += "-pg"
        end

        % not yet tested, and there is a problem
        % in particular, whether or not lib is sharable is a separate question
        % than whether or not it shares other libs, but cm3 only exposes one
        % of these two bits.
        % imported_libs = ConvertLibsToStandalone(imported_libs, shared)

        %
        % Not clear if a) gcc options can go in response file
        % b) lib paths can go in response files, due to slash issues
        %
        LinkResponseFile =
            WriteResponseFile(
                LinkResponseFile,
                [
                    "--output",
                    dll_file,
                    "--out-implib",
                    lib_file,
                    objects,
                    escape(imported_libs),
                ])

        ret_code =
            try_exec(
                "@" & SYSTEM_CC,

                "-shared", % must be visible to compiler
                "-Wl," & LinkResponseFile,
                ">", listing
                )
        if not equal(ret_code, 0) or not FileExists(dll_file)
            error(
                "dynamic link library creation failed, see "
                & GetPackageDirectory()
                & BUILD_DIR
                & SL
                & listing
                & " for more information"
                & EOL
                )
            if not equal(ret_code, 0)
                return ret_code
            end
            return 1
        end

        BindExport(dll_file)
        install_derived(lib0_file)
    end

    return ret_code
end

%-------------------------------------------------------------------
% "skip_lib" is called when the compiler decides it doesn't need to
% call "make_lib", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc
skip_lib(
    lib,
    shared,
    )
is
    local lib_file  = lib & ".lib"
    local lib0_file = lib & ".lib.sa"
    local dll_file  = lib & ".dll"
    local listing   = lib & ".lst"

    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        listing,
        ]

    % make sure files get cleaned up
    deriveds("", Outputs)

    if shared
        % would have built an import library & DLL
        BindExport(dll_file)
        install_derived(lib0_file)
    else
        DeleteFile(lib0_file)
        DeleteFile(dll_file)
    end

    return 0
end

%------------------------------------------------------------------- linker ---
% "m3_link" is called to produce a final executable.

proc
m3_link(
    prog,
    options,
    objects,
    imported_libs,
    shared,
    )
is

    local readonly pgm_file = prog & ".exe"
    local readonly listing  = prog & ".lst"
    local LinkResponseFile = GetResponseFileName()

    local readonly Outputs = [
        pgm_file,
        listing,
        LinkResponseFile,
        ]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    if not shared
        options += "-static"
    end
    if M3_PROFILING
        options += "-pg"
    end

    imported_libs = ConvertLibsToStandalone(imported_libs, shared)

    % not tested
    % if not defined("M3_WINDOWS_GUI")
    %   M3_WINDOWS_GUI = FALSE
    % end
    % if M3_WINDOWS_GUI
    %   options += "-mwindows"
    % else
    %   options += "-mconsole"
    % end

    LinkResponseFile =
        WriteResponseFile(
            LinkResponseFile,
            [
                "--output",
                pgm_file,
                options,
                objects,
                escape(imported_libs),
            ])

    local ret_code = try_exec("@" & SYSTEM_CC, "-Wl," & LinkResponseFile, ">", listing)
    if not equal(ret_code, 0) or not FileExists(pgm_file)
        error(
            "link failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL
            )
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end

    return ret_code
end

%-------------------------------------------------------------------
% "skip_link" is called when the compiler decides it doesn't need to
% call "m3_link", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc
skip_link(
    prog,
    shared,
    )
is
    local readonly pgm_file = prog & ".exe"
    local readonly listing  = prog & ".lst"

    local readonly Outputs = [
        pgm_file,
        listing,
        ]

    % make sure files get cleaned up
    deriveds("", Outputs)

    return 0
end

%------------------------------------------------------------ misc. options ---
% Note, most of these options can be set from the command line. Otherwise,
% they can be set "permanently" here in the config file or in as needed
% in user's m3makefiles.

M3_FRONT_FLAGS = [ ]
% --- internal configuration options passed directly to the Modula-3 front-end

M3_OPTIONS = [ ]
% --- user options passed directly to the Modula-3 front-end

% M3_KEEP_FILES = TRUE
% --- keep intermediate and temporary files

% M3_WINDOWS_GUI = TRUE
% --- generate a Windows GUI subsystem program instead of a console one.

% M3_COVERAGE = TRUE
% --- compile & link with coverage options

M3_COVERAGE_LIB = "report_coverage.o"
% --- library linked in programs compiled with "-Z" coverage option

M3_SPLIT_LIBNAMES = FALSE
% --- split library names and pass -L/-l arguments to the linker

% M3_SHARED_LIB_ARG = "-Wl,-R"
% --- pass "-R" flags to the linker too...

% M3_BOOTSTRAP = TRUE
% --- generate bootstrap code (assembly) instead of finaly object code

% M3_COMPILE_ONCE = TRUE
% --- don't recompile code to improve opaque object references

% SYS_HAS_LOADER = TRUE
% --- generate a loader info file with objects, libraries and timestamps

% M3_SKIP_LINK = TRUE
% --- skip the final link for programs, presumably to use the loader instead

% M3_MAIN_IN_C = TRUE
% --- generate the Modula-3 main program as C code

X11_WITH_SHARED_MEM = TRUE
% --- X11 libraries include the shared memory extensions (XShm...)

M3_NEED_STANDALONE_LINKS = FALSE
% --- linker is broken and we need to build a directory of symbolic
%     links pointing to the non-shared libraries.

%-------------------------------------------------------------------- emacs ---
% If you have emacs and want to compile ".el" files to ".elc" files,
% fill in the function below. Otherwise, comment out or delete the
% entire function. Note, the distributed code assumes gnuemacs version 19
% or later.

readonly
proc
emacs_compile(
    el,
    )
is
    exec("emacs -batch -f batch-byte-compile", el)
end

%------------------------------------------------------------- GNU variants ---
% The two large pieces of GNU software used by the Modula-3 system
% gcc(=m3cc) and gdb(=m3gdb) often require slightly different C compilers
% or flags. They are specified here. Note that they may be overridden
% from the m3build command line.
%
% To use the GNU defaults for CC and CFLAGS, specify "*".
%

GNU_CC     = "gcc"
GNU_CFLAGS = "-O"
GNU_MAKE   = "make"
