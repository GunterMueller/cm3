% Copyright 1996-2000 Critical Mass, Inc. All rights reserved.
% See file COPYRIGHT-CMASS for details.
%
% Standard configuration file for an x86 machine running Windows NT or perhaps Windows 95.
%

%-------------------------------------------------- compilation environment ---

%M3_PROFILING = TRUE  % set by cm3 since 5.1.2 (option -profile)
%M3_PROFILING = FALSE

if M3_PROFILING
    readonly PROFILING_P = "p"
else
    readonly PROFILING_P = ""
end

readonly TARGET       = "NT386"                 % code generation target
readonly BUILD_DIR    = TARGET & PROFILING_P    % directory for results
readonly OS_TYPE      = "WIN32"                 % { "WIN32" or "POSIX" }
readonly WORD_SIZE    = "32BITS"                % { "32BITS" or "64BITS" }
readonly GNU_PLATFORM = "i486-pc-cygwin"        % "cpu-vendor-os" string for GNU

readonly NAMING_CONVENTIONS = "2"
%                                        object files       libraries
%  0=Unix                          =>  .o   .io    .mo       libXX.a
%  1=Unix with a grumpy C compiler =>  .o   _i.o   _m.o      libXX.a
%  2=Windows NT or Windows 95      =>  .obj .io    .mo       XX.lib
%

%-------------------------------------------------- default compile options ---
% "set_config_options" is called before starting the compilation. It should
% be used to provide system-wide default options.

proc
set_config_options(
    )
is
    m3_option("-why")   %-- produce a listing that explains what's happening and why
    m3_debug(TRUE)      %-- produce object code with debugging symbols
    M3_OPTIONS += "-w1"  %-- produce "level 1" warnings
end

%------------------------------------------------------------- export paths ---
% During the installation, destination directories that do not exists
% will be created. You need the necessary permissions to do so; otherwise,
% the installation will fail, but can be restarted after you have
% fixed the permissions.

readonly
proc
CM3SetInstallRoot(
    )
is
    if defined("INSTALL_ROOT")
        return
    end
    if not equal($CM3_INSTALL, "")
        INSTALL_ROOT = $CM3_INSTALL
        return
    end
    if not equal($INSTALLROOT, "")
        INSTALL_ROOT = $INSTALLROOT
        return
    end
    INSTALL_ROOT = (path() & SL & "..")
end

CM3SetInstallRoot()

readonly BIN_INSTALL    = INSTALL_ROOT & SL & "bin"     % executables
readonly LIB_INSTALL    = INSTALL_ROOT & SL & "lib" & PROFILING_P   % libraries
readonly PKG_INSTALL    = INSTALL_ROOT & SL & "pkg"     % packages
readonly DOC_INSTALL    = INSTALL_ROOT & SL & "doc"     % documents
readonly EMACS_INSTALL  = INSTALL_ROOT & SL & "elisp"   % emacs lisp code
readonly MAN_INSTALL    = INSTALL_ROOT & SL & "man"     % man pages
readonly HTML_INSTALL   = INSTALL_ROOT & SL & "www"     % public hypertext

%
% On some systems (e.g. AFS) you must install public files in a different
% place from where you use them. If that is the case for your system,
% specify the "use" location here, otherwise leave them alone.
%
BIN_USE   = BIN_INSTALL     % executables
PKG_USE   = PKG_INSTALL     % packages

readonly INSTALL_IMPLS = FALSE
% TRUE
%    => save all source files during the install
%    => makes debugging easier and browsing more fruitful
% FALSE
%    => save only the exported interfaces and templates
%    => makes the installed system slightly smaller.

%------------------------------------------------ external system libraries ---
% SYSTEM_LIBS provides a mapping from Modula-3 names for the common
% external libraries to site-dependent information about how they
% are accessed. If SYSTEM_LIBS{x} is defined it should be a list
% of linker arguments that are used when linking against that library.
% If SYSTEM_LIBS{x} is not defined, the Modula-3 system will assume
% that the library is not available.

SYSTEM_LIBS =
{
    "LIBC" :
    [
        "winspool.lib",
        "comctl32.lib",
        "wsock32.lib",
        "comdlg32.lib",
        "netapi32.lib",
        "gdi32.lib",
        "user32.lib",
        "advapi32.lib",
        "kernel32.lib"
    ],
    "ODBC" : ["odbc32.lib"],
    "OPENGL" : ["opengl32.lib", "glu32.lib"],
    "TCP" : [ ],
}

%
% We must explicitly specify libcmt.lib or msvcrt.lib
% in our link command because many links contain no C code and
% no /defaultlib directives. The Modula-3 backend should perhaps
% output those directives.
%
% Cutting the C runtime dependency from Modula-3 may be desirable.
%
% The environment variable USE_MSVCRT is 0, 1, or not defined.
% Not defined is treated as 1. This is a safe default for the
% vast majority of toolsets, but not all.
%
if not equal($USE_MSVCRT, "0")
    if not equal($USE_MSVCRT, "1")
        if not equal($USE_MSVCRT, "")
            error("The environment variable USE_MSVCRT should be 0, 1, or not defined, but it is " & $USE_MSVCRT & "." & EOL)
        end
    end
end

if not defined("USE_MSVCRT")
    if equal($USE_MSVCRT, "0")
        USE_MSVCRT = FALSE
    else
        USE_MSVCRT = TRUE
    end
end

if USE_MSVCRT
    SYSTEM_LIBS{"LIBC"} += ["msvcrt.lib"]
else
    SYSTEM_LIBS{"LIBC"} += ["libcmt.lib"]
end

% SYSTEM_LIBORDER defines the order in which SYSTEM_LIBS should be
% scanned by the linker.

SYSTEM_LIBORDER =
[
    "OPENGL",
    "TCP",
    "ODBC",
    "LIBC",
]

%--------------------------------------------------------- Modula-3 backend ---
% For platforms without an integrated backend, "m3_backend" is called to
% translate Modula-3 intermediate code to object code.

% proc
% m3_backend(
%   source,
%   object,
%   optimize,
%   debug,
%   )
% is
% end

M3_BACKEND_MODE = "0"
% -- defines how the frontend, backend, and assembler interact
%  "0"  -- don't call m3_backend, M3CG produces object code
%  "1"  -- don't call m3_backend, M3CG produces assembly code
%  "2"  -- call m3_backend, it produces object code
%  "3"  -- call m3_backend, it produces assembly code

%------------------------------------------------------------------------------

proc
FileExists(
    a,
    )
is
    return not stale(a, a)
end

%------------------------------------------------------------------------------

proc
DeleteFile(
    a,
    )
is
    delete_file(a)
end

%------------------------------------------------------------------------------

readonly OS = $OS

proc
MoveFile(
    a,
    b,
    )
is
    if equal(OS, "Windows_NT")
        exec("@move", a, b)
    else
        exec("@mv", a, b)
    end
end

%------------------------------------------------------------------------------

proc
DeleteFiles(
    a
    )
is
    foreach b in a
        delete_file(b)
    end
end

%--------------------------------------------------------------- C compiler ---
% "compile_c" is called to compile C source files. Note that this function
% is only called if your program or library explicitly includes C source
% code, the system distributed by Critical Mass does not.

proc
compile_c(
    source,
    object,
    options,
    optimize,
    debug,
    )
is
    local args =
    [
%
% Be quiet. Remove this if response file are used, since it
% inhibits the compiler dumping the response file, which is useful
% in any log.
%
        "-nologo",
%
% Put type information in .objs/.libs instead of shared in vc80.pdb, etc.
% vc80.pdb can be renamed with /Fd, we'd need the target name.
% This is bigger/slower but has advantages too.
% Debug information does not inhibit optimization so always generate it.
%
        "-Z7",
%
% needed for older headers such as with Visual C++ 2.0
%
        "-DWIN32",
        options
    ]
    if USE_MSVCRT
        %
        % Use msvcrt.lib and define _MT and _DLL.
        %
        args += ["-MD"]
    else
        %
        % Use libcmt.lib and define _MT.
        %
        args += ["-MT"]
    end
    if optimize
        args += "-Ox"
    end
    if debug
        args += "-Oi"
    end
    return try_exec("cl", [args, "-c", source])
end

%---------------------------------------------------------------- assembler ---
% "assemble" is called to assemble .s or .asm files. Note that this function
% is only called if your program or library explicitly includes assembly source
% code, the system distributed by Critical Mass does not.

proc
assemble(
    source,
    object,
    )
is
    local args = arglist("@", ["-Ml", "-t", "-z", source & "," & object & ";"])
    return try_exec("masm386", args)
end

%------------------------------------------------------------------------------

%
% Quake can't do math, or generate unique temp files,
% at least not that it cleans up.
%
% Uniqueness is not critical here, it is merely useful
% while debugging to go back and see the temp files.
%
% It is also good to put files in a place where they
% will reliably get deleted -- not TEMP.
%
% It is open question as to if carry over to two digits
% can be implemented in Quake. :)
%
Increment =
{ "0":"1","1":"2","2":"3","3":"4","4":"5",
  "5":"6","6":"7","7":"8","8":"9","9":"1", }

ResponseFileCounter = "0"

readonly
proc
GetResponseFileName(
    )
is
    local readonly Increment =
    { "0":"1","1":"2","2":"3","3":"4","4":"5",
      "5":"6","6":"7","7":"8","8":"9","9":"1", }

    local Result = "_m3responsefile" & ResponseFileCounter & ".txt"
    ResponseFileCounter = Increment{ResponseFileCounter}
    return Result
end

%
% mklib wants newlines, so a direct write doesn't work
% I couldn't get anything with write to work, nothing would handle
% plain parameters and lists
%
readonly
proc
WriteResponseFile(
    File,
    Args,
    )
is
    local Temp = arglist("", Args)
    if equal(Temp, Args)
        return Temp
    end
    MoveFile(Temp, File)
    DeleteFile(Temp)
    return "@" & File
end

%------------------------------------------------------------------------------

readonly
proc
GetPackageDirectory(
    )
is
    %
    % older builds, such as 5.1.3, do not define PACKAGE_DIR
    %
    if defined("PACKAGE_DIR")
        return PACKAGE_DIR & SL
    end
    return ""
end

%------------------------------------------------------------------------------

readonly
proc
ConvertLibsToStandalone(
    imported_libs,
    shared,
    )
is
    if shared
        return imported_libs
    end
    local imports = [ ]
    foreach f in imported_libs
        local ff = f & ".sa"
        if FileExists(ff)
            imports += ff
        else
            imports += f
        end
    end
    return imports
end

%--------------------------------------------------------- library creation ---
% "make_lib" is called to combine a collection of object modules into
% a library.

%% NOTE: we should set the "base" load address of the various DLLs
%%  to avoid relocating them every time they are loaded.

%% m3_lib_flags = ["-debugtype:cv", "-machine:i386"]
m3_lib_flags = ["-ign:__real"]

%
% make_lib and m3_link need to share code!
%

proc
make_lib(
    lib,
    options,
    objects,
    imported_libs,
    shared,
    )
is
    local readonly lib_file = lib & ".lib"
    local readonly lib0_file = lib & ".lib.sa"
    local readonly def_file = lib & ".def"
    local readonly dll_file = lib & ".dll"
    local readonly manifest_file  = dll_file & ".manifest"
    local readonly pdb_file = lib & ".pdb"
    local readonly listing  = lib & ".lst"
    local LibResponseFile = GetResponseFileName()
    local LinkResponseFile = GetResponseFileName()
    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        def_file,
        listing,
        manifest_file,
        pdb_file,
        LibResponseFile,
        LinkResponseFile,
        ]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    LibResponseFile =
        WriteResponseFile(
            LibResponseFile,
            [
                m3_lib_flags,
                "-out:" & lib_file,
                options,
                objects,
            ])

    local ret_code = try_exec("@mklib", LibResponseFile, ">", listing)
    if not equal(ret_code, 0) or not FileExists(lib_file)
        error(
            "library creation failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL
            )
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end


    %
    % Noentry cuts out the C runtime startup code,
    % which usually brings in most of our dependency on msvcr*.dll.
    % This leaves most Modula-3 .dlls using very few C runtime functions,
    % mainly setjmp for exception handling, and sometimes memmove, and
    % sometimes a few other functions.
    % This will break some scenarios that mix C and C++ with Modula-3, but
    % should get a link warning. Therefore this probably be configurable,
    % with the default being noentry.
    %
    % We don't use this when using libcmt.lib since that brings in more "real"
    % code that might require the initialization.
    %
    % For .exes a minimal custom entry point could be used, like:
    %  for gui: return WinMain(GetCommandLine(), GetModuleHandle(NULL), GetStartupInfo()...);
    %  for console: getmainargs...
    %
    % It would be nice to reduce the C runtime dependency to zero at some point.
    % On the other hand, it would be nice to get back a backend that generates
    % portable C, in order to get good codegen, on more platforms, without gcc.
    %
    local entry = 0
    if USE_MSVCRT
        entry = "-noentry"
    end

    if shared

        % build an import library & DLL

        MoveFile(lib_file, lib0_file)

        % not yet tested, and there is a problem
        % in particular, whether or not lib is sharable is a separate question
        % than whether or not it shares other libs, but cm3 only exposes one
        % of these two bits.
        % imported_libs = ConvertLibsToStandalone(imported_libs, shared)

        LinkResponseFile =
            WriteResponseFile(
                LinkResponseFile,
                [
                    m3_link_flags,
                    "-def:" & def_file,
                    "-dll",
                    "-out:" & dll_file,
                     options,
                     objects,
                     imported_libs,
                     entry
                ])

        ret_code = try_exec("link", LinkResponseFile, ">", listing)
        if not equal(ret_code, 0) or not FileExists(dll_file)
            error(
                "dynamic link library creation failed, see "
                & GetPackageDirectory()
                & BUILD_DIR
                & SL
                & listing
                & " for more information"
                & EOL
                )
            if not equal(ret_code, 0)
                return ret_code
            end
            return 1
        end

        %
        % http://msdn2.microsoft.com/en-us/library/ms235591.aspx
        %
        if FileExists(manifest_file)
            ret_code = try_exec("mt /nologo /manifest " & manifest_file & " /outputresource:" & dll_file & ";2")
            if not equal(ret_code, 0)
                return ret_code
            end
            delete_file(manifest_file)
        end

        BindExport(dll_file)
        BindExport(pdb_file)
        install_derived(lib0_file)
    end

    return ret_code
end

%-------------------------------------------------------------------
% "skip_lib" is called when the compiler decides it doesn't need to
% call "make_lib", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc
skip_lib(
    lib,
    shared,
    )
is
    local lib_file  = lib & ".lib"
    local lib0_file = lib & ".lib.sa"
    local def_file  = lib & ".def"
    local dll_file  = lib & ".dll"
    local manifest_file  = dll_file & ".manifest"
    local pdb_file  = lib & ".pdb"
    local listing   = lib & ".lst"

    local readonly Outputs = [
        lib_file,
        lib0_file,
        dll_file,
        def_file,
        listing,
        manifest_file,
        pdb_file,
        ]

    % make sure files get cleaned up
    deriveds("", Outputs)

    if shared
        % would have built an import library & DLL
        BindExport(dll_file)
        delete_file(manifest_file)
        BindExport(pdb_file)
        install_derived(lib0_file)
    else
        delete_file(lib0_file)
        delete_file(dll_file)
        delete_file(manifest_file)
        delete_file(pdb_file)
    end

    return 0
end

%------------------------------------------------------------------- linker ---
% "m3_link" is called to produce a final executable.

m3_link_flags =
[
%
% Ignore that some .libs think they want libc.lib.
% This should not needed in a full coherent build, however
% existing distributions, such as 5.2.6, have C code built
% without /MD or /MT and bootstrapping uses their files,
% such as m3core.lib.sa(hand.obj).
%
% Cutting the C runtime dependency from Modula-3 may be desirable.
%
	"-nodefaultlib",
%
% Generate a .pdb for debugging.
%
    "-debug",
%
% Spend a little longer producing a slightly smaller/faster .dll/.exe and
% avoid some warnings.
%
    "-incremental:no",
%
% Remove unused code/data.
%
    "-opt:ref",
%
% With newer linkers, combine identical code/data.
%
%   "-opt:icf",
]

%
% The environment variable USE_DELAYLOAD is 0, 1, or not defined.
% Not defined is treated as 1. This is a safe default for
% linker versions going back a long way, but not infinitely so.
% sysinfo.cmd sets it based on probing the environment.
%
if not equal($USE_DELAYLOAD, "0")
    if not equal($USE_DELAYLOAD, "1")
        if not equal($USE_DELAYLOAD, "")
            error("The environment variable USE_DELAYLOAD should be 0, 1, or not defined, but it is " & $USE_DELAYLOAD & "." & EOL)
        end
    end
end
if not equal($USE_DELAYLOAD, "0")
    m3_link_flags +=
    [
    %
    % The default static dependencies of Modula-3 binaries
    % are larger than they should be. Reduce them sleazily via delayload.
    % This requires a Visual C++ 6.0 or newer linker.
    %
        "-delayload:wsock32.dll",
        "-delayload:advapi32.dll",
        "-delayload:gdi32.dll",
        "-delayload:netapi32.dll",
        "-delayload:user32.dll",
        "-delayload:comctl32.dll",
        "delayimp.lib",
    ]
end

%------------------------------------------------------------------------------

proc
m3_link(
    prog,
    options,
    objects,
    imported_libs,
    shared,
    )
is
    local readonly pgm_file = prog & ".exe"
    local readonly manifest_file = pgm_file & ".manifest"
    local readonly pdb_file = prog & ".pdb"
    local readonly listing  = prog & ".lst"
    local LinkResponseFile = GetResponseFileName()

    local readonly Outputs = [
        pgm_file,
        listing,
        manifest_file,
        pdb_file,
        LinkResponseFile,
        ]

    % make sure files get cleaned up
    DeleteFiles(Outputs)
    deriveds("", Outputs)

    local entry = ["-subsystem:console", "-entry:mainCRTStartup"]
    if defined("M3_WINDOWS_GUI")
        if M3_WINDOWS_GUI
            entry = ["-subsystem:windows", "-entry:WinMainCRTStartup"]
        end
    end

    imported_libs = ConvertLibsToStandalone(imported_libs, shared)

    LinkResponseFile =
        WriteResponseFile(
            LinkResponseFile,
            [
                "-out:" & pgm_file,
                entry,
                m3_link_flags,
                options,
                objects,
                imported_libs
            ])

    local ret_code = try_exec("link", LinkResponseFile, ">", listing)
    if not equal(ret_code, 0) or not FileExists(pgm_file)
        error(
            "link failed, see "
            & GetPackageDirectory()
            & BUILD_DIR
            & SL
            & listing
            & " for more information"
            & EOL
            )
        if not equal(ret_code, 0)
            return ret_code
        end
        return 1
    end

    %
    % http://msdn2.microsoft.com/en-us/library/ms235591.aspx
    %
    if FileExists(manifest_file)
        ret_code = try_exec("mt /nologo /manifest " & manifest_file & " /outputresource:" & pgm_file & ";1")
        if not equal(ret_code, 0)
            return ret_code
        end
        delete_file(manifest_file)
    end

    BindExport(pdb_file)

    return ret_code
end

%-------------------------------------------------------------------
% "skip_link" is called when the compiler decides it doesn't need to
% call "m3_link", but it wants to discover the names of the derived
% files that should be deleted or shipped.

proc
skip_link(
    prog,
    shared,
    )
is
    local readonly pgm_file = prog & ".exe"
    local readonly manifest_file = pgm_file & ".manifest"
    local readonly pdb_file = prog & ".pdb"
    local readonly listing  = prog & ".lst"

    local readonly Outputs = [
        pgm_file,
        listing,
        pdb_file,
        manifest_file,
        ]

    % make sure files get cleaned up
    deriveds("", Outputs)

    return 0
end

%------------------------------------------------------------ misc. options ---
% Note, most of these options can be set from the command line. Otherwise,
% they can be set "permanently" here in the config file or in as needed
% in user's m3makefiles.

M3_FRONT_FLAGS = ["-unfold_nested_procs", "-check_procs"]
% --- internal configuration options passed directly to the Modula-3 front-end

M3_OPTIONS = [ ]
% --- user options passed directly to the Modula-3 front-end

% M3_KEEP_FILES = TRUE
% --- keep intermediate and temporary files

% M3_WINDOWS_GUI = TRUE
% --- generate a Windows GUI subsystem program instead of a console one.

% M3_COVERAGE = TRUE
% --- compile & link with coverage options

M3_COVERAGE_LIB = "report_coverage.o"
% --- library linked in programs compiled with "-Z" coverage option

M3_SPLIT_LIBNAMES = FALSE
% --- split library names and pass -L/-l arguments to the linker

% M3_SHARED_LIB_ARG = "-R"
% --- pass "-R" flags to the linker too.

% M3_BOOTSTRAP = TRUE
% --- generate bootstrap code (assembly) instead of finaly object code

% M3_COMPILE_ONCE = TRUE
% --- don't recompile code to improve opaque object references

% SYS_HAS_LOADER = TRUE
% --- generate a loader info file with objects, libraries and timestamps

% M3_SKIP_LINK = TRUE
% --- skip the final link for programs, presumably to use the loader instead

% M3_MAIN_IN_C = TRUE
% --- generate the Modula-3 main program as C code

X11_WITH_SHARED_MEM = TRUE
% --- X11 libraries include the shared memory extensions (XShm...)

M3_NEED_STANDALONE_LINKS = FALSE
% --- linker is broken and we need to build a directory of symbolic
%     links pointing to the non-shared libraries.

%-------------------------------------------------------------------- emacs ---
% If you have emacs and want to compile ".el" files to ".elc" files,
% fill in the function below. Otherwise, comment out or delete the
% entire function. Note, the distributed code assumes gnuemacs version 19
% or later.

readonly
proc
emacs_compile(
    el,
    )
is
    exec("emacs -batch -f batch-byte-compile", el)
end
