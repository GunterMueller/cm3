%
% This program endeavors to exercise the backend a lot,
% though not necessarily the optimizer.
%
% quash various parts of the output
% in order to get "just the instructions"
% and also avoid host file system paths (in the debug information)
%
% If we were more concerned, we could have coverage
% over various sets of options, optimized and not,
% position independent and not, debug info more or less or none, etc.
%
m3back_debug = ""
m3back_optimize = ""
m3back_pic = ""
m3back_unwind_table = "-fno-asynchronous-unwind-tables"
M3_BOOTSTRAP = TRUE
M3_KEEP_FILES = TRUE

include("Math.quake")

proc BeginInterface(a) is
  local b = a & ".i3.temp"
  > b in
    write("INTERFACE ", a, ";", CR)
  end
  return b
end

proc BeginModule(a) is
  local b = a & ".m3.temp"
  > b in
    write("MODULE ", a, ";", CR)
  end
  return b
end

proc EndX(a, ext) is
  local b = a & ext & ".temp"
  >> b in
    write("END ", a, ".", CR)
  end
  cp_if(b, a & ext)
end

proc EndInterface(a) is
  EndX(a, ".i3")
end

proc EndModule(a) is
  EndX(a, ".m3")
end

proc ToLong(name, fromType, toLong) is
  if not toLong or IsLong{fromType}
    return name
  end
  return "VAL(" & name & ", LONGINT)"
end

local signed = [FALSE, TRUE]
local constant = [FALSE, TRUE] % or variable
local params = [FALSE, TRUE] % or (global) variable (future: nested)
% k for constant, v for variable, p for parameter
local K = {FALSE:"v",TRUE:"k"}
local P = {FALSE:"v",TRUE:"p"}
local CONST = {FALSE:"VAR ",TRUE:"CONST "}
local assign = {FALSE:":=",TRUE:"="}
local L = {8:"",16:"",32:"",64:"L"}
local IsLong = {8:FALSE,16:FALSE,32:FALSE,64:TRUE}

local IsInt = { }
local IsFloat = { }
local TypeArray = [ ]
local TypeHash = { }
local sizes = [8,16,32,64]
local IsUnsignedInt = { }
local IsSignedInt = { }
local IntSize = { }
local Types = { }
%local ConstName = { } % or prefix
%local VarName =   { } % or prefix
%local ParamName = { } % or prefix
local ShortName = { }
local Builtin = { }
foreach size in sizes
  foreach unsigned in [TRUE, FALSE]
    local t = {FALSE:"",TRUE:"U","":"","U":"U"}{unsigned} & "INT" & size
    Types{t} = 1
    Builtin{t} = FALSE
    IntSize{t} = size
    IsInt{t} = TRUE
    IsFloat{t} = FALSE
    TypeArray += t
    TypeHash{t} = 1
    IsUnsignedInt{t} = unsigned
    IsSignedInt{t} = not unsigned
    IsLong{t} = IsLong{size}
    L{t} = L{size}
    ShortName{t} = {FALSE:"i",TRUE:"u"}{unsigned} & size
  end
end

foreach t in ["INTEGER", "CARDINAL", "LONGINT", "LONGCARD"]
  Types{t} = 1
  IsInt{t} = TRUE
  IsFloat{t} = FALSE
  TypeArray += t
  TypeHash{t} = 1
  ShortName{t} = t
  Builtin{t} = TRUE
end

foreach t in ["INTEGER", "CARDINAL"]
  IntSize{t} = {"32BITS":32,"64BITS":64}{WORD_SIZE}
  IsLong{t} = FALSE
  L{t} = ""
end

foreach t in ["LONGINT", "LONGCARD"]
  IntSize{t} = 64
  IsLong{t} = TRUE
  L{t} = "L"
end

foreach t in ["INTEGER", "LONGINT"]
  IsUnsignedInt{t} = FALSE
  IsSignedInt{t} = TRUE
end

foreach t in ["CARDINAL", "LONGCARD"]
  IsUnsignedInt{t} = TRUE
  IsSignedInt{t} = FALSE
end

local FloatArray = ["REAL", "LONGREAL", "EXTENDED"]
local FloatHash = {  }
foreach t in FloatArray
  Types{t} = 1
  IsInt{t} = FALSE
  IsFloat{t} = TRUE
  TypeArray += t
  TypeHash{t} = 1
  FloatHash{t} = 1
  IsUnsignedInt{t} = FALSE
  IsSignedInt{t} = FALSE
  IntSize{t} = 0
  ShortName{t} = {"REAL":"f32", "LONGREAL":"f64", "EXTENDED":"fx"}{t}
  %ParamName{t} = "p" & ShortName{t}
  %VarName{t} = "v" & ShortName{t}
  %ConstName{t} = "k" & ShortName{t}
  IsLong{t} = FALSE % needs work
end

>> BeginModule("A") in
  write("IMPORT Cstdint, <*NOWARN*>Word, <*NOWARN*>Long;", CR)
  write("TYPE <*NOWARN*>INT = INTEGER;",CR)
  write("TYPE <*NOWARN*>FLOAT32 = REAL;",CR)
  write("TYPE <*NOWARN*>FLOAT64 = LONGREAL;",CR)
  foreach t in Types
    if IsInt{t}
      % make a type
      
      if not Builtin{t}
        write("TYPE ", t, " = Cstdint.", {FALSE:"",TRUE:"u","":"","u":"u"}{IsSignedInt{t}}, "int", IntSize{t}, "_t;", CR)
      end

      foreach k in constant
            
        % make a constant or variable
      
        local v = K{k} & ShortName{t}
        if Builtin{t}
          v = K{k} & ShortName{t}
        end

        write("<*NOWARN*>", CONST{k}, v, ":", t, assign{k}, Increment(), L{t}, ";", CR)
              
        % return a constant or variable

        local f = "ret_" & {TRUE:"const",FALSE:"var"}{k} & "_" & ShortName{t}
        write("<*NOWARN*>PROCEDURE ", f, "():", t,
              "=BEGIN RETURN ")
        if k
          write(Increment(), L{t})
        else
          write(v)
        end
        write(";END ", f, ";", CR)
      end
    else
      % make a variable
      
      local v = "v" & ShortName{t}

      write("<*NOWARN*> VAR " , v, ":", t, ";", CR)
              
      % return a variable

      local f = "ret_" & ShortName{t}
      write("<*NOWARN*>PROCEDURE ", f, "():", t,
            "=BEGIN RETURN ")
      write(v)
      write(";END ", f, ";", CR)
    end

    % return a parameter with a type change
    foreach t2 in Types
      if IsInt{t} and IsInt{t2}
        local f = "ret_param_" & ShortName{t} & "_" & ShortName{t2}
        write("<*NOWARN*>PROCEDURE ", f, "(a:", t2, "):", t2, "=BEGIN RETURN ")
        if not equal(IsLong{t}, IsLong{t2})
          write("VAL(a,", t2, ")")
        else
          write("a")
        end
        write(";END ", f, ";", CR)            
      end
    end

    local ops = ["add", "sub", "and", "or", "xor", "mult", "div", "mod"]
    local float_ops = {"add":"+","sub":"-","mult":"*"}
    %local int_ops = {"add":"+","sub":"-","mult":"*","div":"DIV","mod":"MOD"}
    local infix_ops = {"add":"+","sub":"-","mult":"*","div":"DIV","mod":"MOD"}
    local word_ops = {"and":"And","or":"Or","xor":"Xor"}
      
    foreach op in ops
      foreach t2 in Types
        if (IsInt{t} and IsInt{t2}) or (equal(t, t2) and float_ops contains op)
          foreach p in params
            local f = op & "_" & {TRUE:"param",FALSE:"var"}{p} & "_" & ShortName{t} & "_" & ShortName{t2}
            write("<*NOWARN*>PROCEDURE ", f, "(")
            if p
              write("a:", t, ";b:", t2)
            end
            write("):")
            if IsInt{t}
              write("INT")
            else
              write(t)
            end
            local isLong = (IsLong{t} or IsLong{t2})
            if isLong
              write("64")
            end
            write("=BEGIN RETURN ")
            local a = "a"
            local b = "b"
            if not p
              a = "v" & ShortName{t}
              b = "v" & ShortName{t2}
            end
            a = ToLong(a, t, isLong)
            b = ToLong(b, t2, isLong)
            if infix_ops contains op
              write(a, " ", infix_ops{op}, " ", b)
            else
              local word = "Word"
              if isLong
                word = "Long"
              end
              write(word, ".", word_ops{op}, "(", a, ",", b, ")")
            end
            write(";END ", f, ";", CR)            
          end
        end
      end
    end
  end
  foreach i in InclusiveRange("0", "64")
    foreach j in InclusiveRange("1", Sub("64", i))
      local t = "BitField_offset" & i & "_count" & j
      write("<*NOWARN*>TYPE ", t, " = RECORD ", CR)
      write(" offset:BITS ", i, " FOR [0..0];", CR)
      write(" value:BITS ", j, " FOR [0..1];", CR)
      write("END;", CR)
      local p = "read_var_" & t
      write("<*NOWARN*> PROCEDURE ", p, "(a:", t, "):[0..1]=", CR, "  BEGIN RETURN a.value END ", p, ";", CR)
      p = "write_var_" & t
      write("<*NOWARN*> PROCEDURE ", p, "(VAR a:", t, ";b:[0..1])=", CR, "  BEGIN a.value := b END ",
            p, ";", CR)                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                          
    end
  end

  foreach t in ["INT32", "UINT32", "INT64", "UINT64"]
    foreach i in InclusiveRange("0", {"INT32":"31", "UINT32":"31", "INT64":"63", "UINT64":"63"}{t})
      local p = "div_pow2_" & t & "_" & i
      write("<*NOWARN*> PROCEDURE ", p, "(a:", t, "):", t, "=", CR, "  BEGIN RETURN a DIV 16_" & HexPowerOf2(i) & L{t} & " END ", p, ";", CR)
      p = "mod_pow2_" & t & "_" & i
      write("<*NOWARN*> PROCEDURE ", p, "(a:", t, "):", t, "=", CR, "  BEGIN RETURN a MOD 16_" & HexPowerOf2(i) & L{t} & " END ", p, ";", CR)
    end
  end

  write("BEGIN", CR)
end
EndModule("A")

>> BeginInterface("A") in
  write("(* bar *)", CR)
end
EndInterface("A")

derived_interface("A", HIDDEN)
derived_implementation("A")
implementation("Main")
build_standalone()
include ("../../Test.common")
