
% Partly copied from CVSup by John D. Polstra
%
% Copyright 1999-2003 John D. Polstra.
% All rights reserved.
%
% Redistribution and use in source and binary forms, with or without
% modification, are permitted provided that the following conditions
% are met:
% 1. Redistributions of source code must retain the above copyright
%    notice, this list of conditions and the following disclaimer.
% 2. Redistributions in binary form must reproduce the above copyright
%    notice, this list of conditions and the following disclaimer in the
%    documentation and/or other materials provided with the distribution.
% 3. All advertising materials mentioning features or use of this software
%    must display the following acknowledgment:
%      This product includes software developed by John D. Polstra.
% 4. The name of the author may not be used to endorse or promote products
%    derived from this software without specific prior written permission.
%
% THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
% IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
% OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
% IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
% INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
% NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
% DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
% THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
% (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
% THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
%
% $Id$


%------------------------------------------------------------------------------

proc FileExists(a) is
    return not stale(a, a)
end

%------------------------------------------------------------------------------

%
% Generate the "Version.i3" implementation file. It contains the release
% name, if any, else the compilation date and time, and other information
% about the environment used to build the compiler.
%
proc version_impl(name) is
    local filename = name & ".i3"
    local tempname = "_m3temp_" & filename
    local datefn = ".." & SL & BUILD_DIR & SL & "_m3datenow.quake"
    local dcmd = ""
    local ret = 0

    %
    % delete some but not all outputs
    %
    delete_file(datefn)
    delete_file("_m3version.cmd")
    delete_file(tempname)

    %
    % delete with the old names (these were outside the output directory)
    %
    delete_file(".." & SL & TARGET & ".datenow")
    delete_file("." & filename)

    if not defined("_all")
        return
    end

    > tempname in
        write("INTERFACE ", name, ";", CR)
    end

    local NOW = ""

    if defined("datetime")
        NOW = datetime()
    else
        NOW = "not available"
    end

    %
    % why two names for these?
    %
    local readonly Map =
    {
        "CM3_VERSION_NUMBER" : 
            { "EnvName"  : "CM3VERSIONNUM",
              "EnvValue" : $CM3VERSIONNUM,
            },

        "CM3_VERSION_TEXT" : 
            { "EnvName"  : "CM3VERSION",
              "EnvValue" : $CM3VERSION,
            },

        "CM3_LAST_CHANGED" : 
            { "EnvName"  : "CM3LASTCHANGED",
              "EnvValue" : $CM3LASTCHANGED,
            },
    }

    %
    % are any not defined, and not in the environment
    % if so, we need to run sysinfo.cmd to look at sysinfo.sh
    %
    local Missing = [ ]
    local AnyMissing = FALSE

    %
    % were any initially missing, but then gotten from environment
    % we still need to write and include a file for this
    %
    local AnyChanged = FALSE
    local Changed = [ ]

    foreach Name in Map
        if not defined(Name)
            EnvValue = Map{Name}{"EnvValue"}
            if not equal(EnvValue, "")
                write("getting " & Name & " from environment " & Map{Name}{"EnvName"} & "=" & EnvValue & CR)
                Map{Name}{"Value"} = EnvValue
                Changed += Name
                AnyChanged = TRUE
            else
                write("missing " & Name & " will read version file" & CR)
                Missing += Name
                AnyMissing = TRUE
            end
        end
    end

    if (AnyChanged or AnyMissing)
        if equal ($OS, "Windows_NT") and equal (SL, "\\")
            > "_m3version.cmd" in
                write("@echo off", CR)
                if AnyMissing
                    %    
                    % It does not make sense to me that we have to pass in the path to sysinfo.sh here.
                    % The useof %~dp0 in sysinfo.cmd is oddly not working, it is resolving
                    % to the cm3/src/<TARGET> directory of this calling .cmd file.
                    %
                    write("call ..\\..\\..\\scripts\\win\\sysinfo GetVersions ..\\..\\..\\scripts\\version || exit /b 1", CR)
                end
                foreach Name in Missing
                    write("echo ", Name, " = \"%", Map{Name}{"EnvName"}, "%\"", CR)
                end
                foreach Name in Changed
                    write("echo ", Name, " = \"", Map{Name}{"Value"}, "\"", CR)
                end
            end
            exec("@.\\_m3version.cmd > " & datefn)
        else
            > "_m3version.sh" in
                if AnyMissing
                    write("root=" & path() & "../../..", CR)
                    write(". ../../../scripts/sysinfo.sh || exit 1", CR)
                end
                foreach Name in Missing
                    write("echo ", Name, " = \\\"$", Map{Name}{"EnvName"}, "\\\"", CR)
                end
                foreach Name in Changed
                    write("echo ", Name, " = \\\"", Map{Name}{"Value"}, "\\\"", CR)
                end
            end
            exec("@chmod +x ./_m3version.sh")
            exec("@./_m3version.sh > " & datefn)
        end
    end
    if FileExists(datefn)
        include(datefn)
    end
    if not defined("CM3_VERSION_NUMBER")
        CM3_VERSION_NUMBER = "000000"
        write(" *** warning: CM3_VERSION_NUMBER not defined", CR)
    end
    if not defined("CM3_VERSION_TEXT")
        CM3_VERSION_TEXT = "d0.0.0"
        write(" *** warning: CM3_VERSION_TEXT not defined", CR)
    end
    if not defined("CM3_LAST_CHANGED")
        CM3_LAST_CHANGED = "unknown"
        write(" *** warning: CM3_LAST_CHANGED not defined", CR)
    end
    >> tempname in
        write("CONST", CR)
        write("  Text = \"", CM3_VERSION_TEXT, "\";", CR)
        write("  Number = \"", CM3_VERSION_NUMBER, "\";", CR)
        write("  LastChanged = \"", CM3_LAST_CHANGED, "\";", CR)
        write("  Created = \"", NOW, "\";", CR)

        %
        % When cm3 uses this data, it is describing the HOST.
        % They are reasonable defaults for the TARGET, ASSUMING a NATIVE build.
        %
        write("  Target = \"", TARGET, "\";", CR)
        write("  OSType = \"", OS_TYPE, "\";", CR)
        write("  WordSize = \"", WORD_SIZE, "\";", CR)

        local GNUPlatform = ""
        if defined ("GNU_PLATFORM")
            GNUPlatform = GNU_PLATFORM
        end
        write("  GNUPlatform = \"", GNUPlatform, "\";", CR)

        local CCompiler = ""
        if defined ("C_COMPILER")
            CCompiler = C_COMPILER
        end
        write("  CCompiler = \"", CCompiler, "\";", CR)

        local Linker = ""
        if defined ("LINKER")
            Linker = LINKER
        end
        write("  Linker = \"", Linker, "\";", CR)

        local ThreadLibrary = ""
        if defined ("THREAD_LIBRARY")
            ThreadLibrary = THREAD_LIBRARY
        end
        write("  ThreadLibrary = \"", ThreadLibrary, "\";", CR)

        local WindowLibrary = ""
        if defined ("WINDOW_LIBRARY")
            WindowLibrary = WINDOW_LIBRARY
        end
        write("  WindowLibrary = \"", WindowLibrary, "\";", CR)

        local GNUMake = "make"
        if defined("GNU_MAKE")
            GNUMake = GNU_MAKE
        end
        write("  GNUMake = \"", GNUMake, "\";", CR)

        local readonly proc map(a, b) is
            if a contains b
                return a{b}
            end
            return b
        end

        write("  BackendMode = \"",
            map({"0" : "IntegratedObject",
                 "1" : "IntegratedAssembly",
                 "2" : "ExternalObject",
                 "3" : "ExternalAssembly"}, M3_BACKEND_MODE), "\";", CR)

        local TargetNaming = ""
        if defined("TARGET_NAMING")
            TargetNaming = TARGET_NAMING
        else if defined("NAMING_CONVENTIONS")
            TargetNaming = NAMING_CONVENTIONS
        end end
        if TargetNaming
            TargetNaming = map({"0" : "Unix", "1" : "GrumpyUnix", "2" : "Win32"}, TargetNaming)
        end
        write("  TargetNaming      = \"", TargetNaming, "\";", CR)
        write("  NamingConventions = \"", TargetNaming, "\";", CR)

        write("END ", name, ".", CR)
    end
    cp_if(tempname, filename)
    derived_interface(name, HIDDEN)
end
