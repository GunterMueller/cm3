
<title>Unsafe Constructs for Systems Programming</title>
<H3>Unsafe Constructs for Systems Programming</H3>

<p>This program illustrates the use of unsafe constructs, such as
   <code>LOOPHOLE</code>, an unsafe cast. The default mode for 
   Modula-3 programs is <code>SAFE</code>, i.e., the language runtime 
   is responsible for checking run-time errors. For programming 
   intricate systems, integrating legacy systems, 
   or making your programs more efficent, you may decide that
   you would like the freedom to perform tasks that circumvent 
   the safety conditions enforced by the language run-time.

<p>Modula-3 gives you the freedom to do unsafe operations in 
   in the <code>UNSAFE</code> modules by providing more operations, 
   such as <code>LOOPHOLE</code> (an unsafe cast) or <code>ADR</code> (returns 
   the address of a variable) which do not work well with
   safe programming practices enforced in <code>SAFE</code> modules.
   With this freedom for you the programmer, comes the 
   responsibility to check for run-time errors. The language
   does not check for type safety in a <code>LOOPHOLE</code>.

<p>The separation of safe and unsafe codes is essential for writing
   portable programs that utilize unsafe or non-portable features 
   of particular systems. Indeed it is common practice for 
   systems progammers to divide up their code in safe and 
   unsafe portions. This way, the bulk of porting to 
   a new platform, lies in the unsafe portion. Modula-3 supports
   this programming model. Both interfaces and modules can be 
   marked as <code>UNSAFE</code>. You are best to code most (if not all) 
   of your programs in the safe mode, since it is much easier 
   to make safe programs robust. 

<p>A safe module can only 
   import safe interfaces, so in safe programming you can't mistakenly 
   count on unsafe functionality in another unsafe module. An unsafe module 
   can make its functionality available to other safe modules
   by exporting a <code>SAFE</code> interface.

<p>One nice aspect of the support for unsafe features is 
   that you don't have to rely on external calls, or implementation-specific
   features to make your programs more efficient. Indeed, 
   the unsafe portions of your code will have as much control
   over the representation an layout of your data structures as 
   you have when programming in an unsafe language like C. Indeed people
   have gone as far as writing operating system in Modula-3; something
   that is not possible in other high-level languages of its class.


