<html>
<head>
   <title>CM Modula-3: quake</title>
   <meta name="GENERATOR" content="Mozilla/2.0GoldB2 (Win32)">
<LINK HREF="../../../normal.css" REL="stylesheet" TYPE="text/css"></head>
<body>

<h2>quake</h2>

<p>This page documents <b>quake</b>. <b>Quake</b> is a simple, specialized
language and its interpreter drawing on elements of the C language, the
Bourne shell, and the C pre-processor. The <tt>cm3</tt> compiler includes
a quake interpreter as its extension language. In fact, the configuration
file, <tt>cm3.cfg</tt>, and <tt>m3makefiles</tt> are quake scripts.</p>

<p><b>Quake</b> was designed to be a simple extension language for the
builder. Building a complete, general-purpose language was not one of the
goals. </p>

<p>Cm3 calls out to quake every time it needs to do something that needs
to be specialized such as compiling C files or linking. Consult <tt>cm3.cfg</tt>
in your installation (in the same directory as cm3 executable) for more
information. </p>

<h3>Values</h3>

<p><b>Quake</b> is designed to make it easy to assemble arrays and tables
of strings. The value space is strings, arrays of strings, and tables of
strings. An array is a list of elements, and a table is a set of key/value
pairs where the keys in a table are all distinct. </p>

<h4>Strings</h4>

<p>A string is a sequence (delimited by `&quot;') of characters excluding
newline and double quote. Several special characters may be quoted (with
`\') as follows: </p>

<pre>    new-line    ignored
    \\          \
    \n          new-line
    \r          return
    \t          tab
    \b          backspace
    \f          formfeed
    \&quot;          double quote
</pre>

<h4>Arrays</h4>

<p>An array is constructed using `[' and `]'. `[]' is the empty array,
`[&quot;a&quot;]' is an array of the single string &quot;a&quot;. Elements
are separated by `,'. Thus `[&quot;a&quot;, &quot;b&quot;]' is an array
of two elements---the strings &quot;a&quot; and &quot;b&quot;. </p>

<p>Arrays are flattened whenever they are referenced. This means that `[&quot;a&quot;,
[&quot;b&quot;, &quot;c&quot;]]' is converted the the array `[&quot;a&quot;,
&quot;b&quot;, &quot;c&quot;]'. This means that an array can never be the
element of another array. </p>

<p>Arrays are accessed by an integer index. `a[2]' is the third element
of the array a. The index expression may also be a string which will be
converted to an integer. The range of the index is checked at run-time.
</p>

<h4>Tables</h4>

<p>A table is constructed using `{' and `}'. `{}' is the empty table. Elements
of a table are given as key/value pairs. An empty value may be omitted.
`{&quot;a&quot;, &quot;b&quot;}' is a table containing two keys---the strings
&quot;a&quot; and &quot;b&quot;. `{&quot;p&quot; : &quot;q&quot;}' is the
constructor for a table with the single key &quot;p&quot; whose value is
the string &quot;q&quot;. Missing values are returned as &quot;&quot;.
</p>

<p>Tables are accessed using expressions of the form `s{&quot;a&quot;}'.
This evaluates to the value of the key &quot;a&quot; in the table s. </p>

<h3>Names</h3>

<p>Names in <b>quake</b> start with an letter (`a'..`z', `A'..`Z') or an
underscore (`_'), followed by those characters, digits (`0'..`9'), hyphens
(`-'), or periods (`.'). </p>

<p>If the lookup for a name fails (it is undefined in any of the enclosing
scopes) it is installed in the current scope with an initial string value
of the text of the name. </p>

<h3>Comments</h3>

<p>C-style comments are supported (delimited by `/*' and `*/') and do not
nest. </p>

<p>Single-line comments are introduced with `%' and terminated with a new-line.
</p>

<h3>Conditionals</h3>

<p>A Boolean value is represented as a string. The empty string is false,
and any other string is true. </p>

<h3>Expressions</h3>

<p>An expression is: </p>

<pre>    string:                  &quot;baz&quot;
    name:                    foo
    environment variable:    $CPU_TYPE
    array selector:          array[5]
    array constructor:       [&quot;a&quot;, &quot;b&quot;]
    table selector:          t{&quot;a&quot;}
    table constructor:       {&quot;a&quot; : &quot;p&quot;, b}
    function call:           f(a, &quot;b&quot;)
    parentheses:             a and (b or f(c))
</pre>

<p>Operators are all left-associative, precedence is decreases from top
to bottom in the following list. </p>

<pre>    &amp;           string catenation (`&quot;Hello, &quot; &amp; foo')
    contains    table inclusion (`s contains &quot;a&quot;')
    not         logical negation (`not a')
    and         logical conjunction (`c and not d')
    or          logical disjunction (`a or b')
</pre>

<p>A note on string catenation. Operands of `&amp;' are converted to strings
whenever required and possible. Arrays and tables are converted to strings
by catenating their elements (for tables, their keys) separated by a single
spaces. For example, the expression </p>

<pre>    &quot;a&quot; &amp; &quot; &quot; &amp; [&quot;b&quot;, &quot;c&quot;]
</pre>

<p>evaluates to the string &quot;a b c&quot;. </p>

<h3>Statements</h3>

<p>A statement is either an assignment, a procedure definition, a procedure
invocation, a conditional statement, or a loop. </p>

<h4>Assignment</h4>

<p>Assign an expression (the string &quot;bar&quot;) to the variable `foo'
with </p>

<pre>    foo = &quot;bar&quot;
</pre>

<p>If `foo' already exists, and is an array, then </p>

<pre>    foo += &quot;baz&quot;
</pre>

<p>extends the array to include a new final element; the string &quot;baz&quot;.
</p>

<h4>Scope</h4>

<p><b>Quake</b> has a global name space, but local scopes are always introduced
when a procedure is called, and a `foreach' loop is executed. </p>

<p>Scopes are searched from innermost to outermost each time a name is
looked up. The outermost scope is always the global scope. </p>

<p>Assignments can be made local to the innermost scope by prefixing the
assignment statement with the keyword `local'. For example, </p>

<pre>    local foo = &quot;bog&quot;
</pre>

<p>In which case the values of any other instances of `foo' in other scopes
are hidden. The previous value of `foo' is restored once the local scope
is released by exiting the procedure or `foreach' loop. </p>

<p>To protect a name in the current scope, use </p>

<pre>    readonly dec = &quot;digital&quot;
</pre>

<h4>Procedures</h4>

<p>Procedures may be defined in the global scope only. Here is the definition
of a procedure `simple', taking two arguments bound to the local names
`prefix' and `suffix' in the procedure's local scope. </p>

<pre>    proc simple(prefix, suffix) is
      q = prefix &amp; &quot;.&quot; &amp; suffix
    end
</pre>

<p>The string `prefix &amp; &quot;.&quot; &amp; suffix' is assigned to
the global variable `q'. </p>

<p>This procedure can then be invoked with </p>

<pre>    simple(&quot;Hello&quot;, &quot;m3&quot;)
</pre>

<p>Procedures can return values, in which case they become functions. For
example, </p>

<pre>    proc combine(prefix, suffix) is
      return prefix &amp; &quot;.&quot; &amp; suffix
    end
</pre>

<p>defines a function `combine' which catenates and returns the three strings
`prefix', &quot;.&quot;, and `suffix'. Now the function `combine' can be
used in an expression, for example </p>

<pre>    q = combine(&quot;Hello&quot;, &quot;m3&quot;)
</pre>

<p>assigns the string &quot;Hello.m3&quot; to `q'. </p>

<h4>Conditional Statements</h4>

<p>Values may be tested using the `if' statement. For example, </p>

<pre>    if compiling
      message = &quot;compiling&quot;
    end
</pre>

<p>If statements may have an else part, for example </p>

<pre>    if not (ready or interested)
      return
    else
      message = &quot;congratulations&quot;
    end
</pre>

<p>returns from the current procedure if the test succeeds, otherwise executes
the assignment statement. </p>

<h4>Loops</h4>

<p>`Foreach' statements iterate over the string values in an array or in
a table. For example, </p>

<pre>    foreach file in [&quot;.login&quot;, &quot;.profile&quot;, &quot;.Xdefaults&quot;]
      write(&quot;Copying &quot; &amp; file &amp; &quot; to &quot; &amp; backup_dir &amp; &quot;0)
      copy_file(file, backup_dir)
    end
</pre>

<p>binds the name `file' to each of &quot;.login&quot;, &quot;.profile&quot;,
and &quot;.Xdefaults&quot; in turn in a local scope. This example assumes
that the procedures `copy_file', and the variable `backup_dir' have already
been defined. </p>

<p>Here is a function `squeeze' to remove duplicates from an array </p>

<pre>    proc squeeze(array) is
      local t = {}

      foreach i in array
        t{i} = &quot;&quot;
      end

      return [t]
    end
</pre>

<h3>Keywords</h3>

<p>Here is a list of reserved words in <b>quake</b>: </p>

<pre>    and  contains  else  end  foreach  if  in
    is  local  not  or  proc  readonly  return
</pre>

<h3>Built-in Procedures</h3>

<p><b>Quake</b> has a small collection of built-in procedures. Built-ins
cannot be redefined. The built-ins `write', `error', and `exec' are variadic.
</p>

<ul>
<li><b>write(...)</b> Writes its arguments to the current output stream.
Unlike the conversion of arrays to strings, there are no extra spaces inserted
between arguments. </li>

<li><b>error(...)</b> Writes its arguments to the standard error stream
and stop running <b>quake</b> with an error return value. </li>

<li><b>include(file)</b> The contents of `file' is interpreted by <b>quake</b>
in place of the call to `include'. This is analogous the `#include' directive
in the C preprocessor. Calls to `include' nest until you run out of file
descriptors or something equally bad. </li>

<li><b>exec(...)</b> The arguments are catenated and passed to the operating
system to be executed as a child process. The command may start `-' or
`@'. These are stripped before the command is passed to the command interpreter.
A prefix of `@' indicates that the default action of printing the command
to the standard output stream before execution should be overridden. A
prefix character of `-' overrides <b>quake</b>'s default action of aborting
if it detects an error return code after executing the command. </li>

<li><b>cp_if(src, dest)</b> If the file `src' differs from the file `dest',
or `dest' is missing, copy `src' to `dest'. </li>
</ul>

<h3>Built-in Functions</h3>

<ul>
<li><b>arglist(pfx, array)</b> This function may be used to avoid the problems
of limited space for argument lists in some command interpreters. Some
commands (notably `m3', the Modula-3 driver program) are prepared to accept
arguments from a file. The syntax for this is `-Ffile'. </li>

<p>Thus, `arglist(&quot;-F&quot;, really_huge_array)' returns either the
original array if it's not really all that huge, or it creates a temporary
file containing a list of the strings in the array (one to a line) and
returns the string &quot;-Ftemp&quot; where `temp' is the name of the temporary
file. </p>

<li><b>defined(foo)</b> Returns true if `foo' is defined, otherwise returns
false. Remember that the Boolean values false and true are represented
as empty and non-empty strings respectively. In this example, `foo' looks
like a name, and is evaluated before begin passed to `defined'. So if you
really want to find out whether `foo' is defined, use `defined(&quot;foo&quot;)'.
</li>

<li><b>empty(foo)</b> Returns true if the string, array, or table is empty,
false otherwise. </li>

<li><b>equal(foo, bar)</b> Returns true if the strings `foo' and `bar'
are the equivalent. </li>

<li><b>escape(s)</b> Returns the string `s' with backslash characters doubled.
</li>

<li><b>format(s, a...)</b> Returns the string `s' with each instance of
`%s' replaced by successive `a' arguments. The number of `a' arguments
must match the number of `%s's. </li>

<li><b>normalize(p, q)</b> If the path `p' is a prefix of the path `q',
returns the path from directory `p' to file `q'. Otherwise, returns `q'.
</li>

<li><b>path()</b> Returns the directory of the currently executing file
as a string. </li>

<li><b>stale(target, deps)</b> `target' is interpreted as a file name,
as is `deps' (or the elements of `deps' if it's an array). If the files
`target' or `deps' cannot be found, or if (one of) `deps' is more recent
than `target', `stale' returns true, otherwise false. </li>

<li><b>unlink_file(f)</b> Deletes the file `f'. </li>
</ul>

<h3>Output Redirection</h3>

<p>Sorry about the syntax for this. Suggestions (YACC permitting) welcome.
</p>

<p>Output (from the `write' built-in procedure) may be temporarily redirected
as follows: </p>

<pre>    &gt; &quot;foo.txt&quot; in
      write(&quot;Hello, world0)
    end
</pre>

<p>The output of the calls to `write' is written to the file `foo.txt'.
</p>

<p>Output may be appended to a file by using `&gt;&gt;' in place of `&gt;'.
</p>

<p>The special file names `_stdout' and `_stderr' are special and are bound
to the file descriptors corresponding to normal and error terminal output
respectively. </p>

<p>The default for output is the normal terminal stream. </p>

<h3>Running Quake</h3>

<p>The syntax of the <b>quake</b> command is </p>

<pre>    <b>quake</b> [definitions|files ...]
</pre>

<p>A definition has the form `-Dvar' or `-Dvar=string'. The first form
defines `var' in the global scope of the program, the second form gives
it a value. </p>

<p>Each file argument is executed as it is encountered. </p>

<hr>
<p>Original Author:&nbsp;Stephen Harrison.</a></p>

<p>
</body>
</html>
