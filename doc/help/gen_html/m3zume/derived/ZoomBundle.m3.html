<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3zume/derived/ZoomBundle.m3</TITLE>
</HEAD>
<BODY bgcolor="#eeeeee">
<A NAME="0TOP0">
<H2>m3zume/derived/ZoomBundle.m3</H2></A><HR>
<inModule>
<PRE>MODULE <module><implements><A HREF="ZoomBundle.i3.html">ZoomBundle</A></implements></module>;
</PRE><BLOCKQUOTE><EM> Generated by m3bundle; see its manpage. </EM></BLOCKQUOTE><PRE>

IMPORT <A HREF="../../libm3/src/bundleintf/Bundle.i3.html">Bundle</A>, <A HREF="../../libm3/src/bundleintf/BundleRep.i3.html">BundleRep</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;
IMPORT <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>, <A HREF="../../libm3/src/rw/TextWr.i3.html">TextWr</A>;

TYPE T = Bundle.T OBJECT OVERRIDES
           get      := LookUp;
           getNames := GetNames;
         END;

TYPE Texts = REF ARRAY OF TEXT;

VAR
  bundle: T     := NIL;
  names : Texts := NIL;

PROCEDURE <A NAME="Get"><procedure>Get</procedure></A>(): Bundle.T =
  BEGIN
    IF (bundle = NIL) THEN bundle := NEW (T) END;
    RETURN bundle;
  END Get;

PROCEDURE <A NAME="GetNames"><procedure>GetNames</procedure></A> (&lt;*UNUSED*&gt; self: T): Texts =
  BEGIN
    IF names = NIL THEN
      names := NEW (Texts, NUMBER (Names));
      names^ := Names;
    END;
    RETURN names;
  END GetNames;

PROCEDURE <A NAME="LookUp"><procedure>LookUp</procedure></A> (&lt;*UNUSED*&gt; self: T;  element: TEXT): TEXT =
  BEGIN
    FOR i := 0 TO LAST (Names)-1 DO
      IF Text.Equal (Names[i], element) THEN
        IF Elements[i] = NIL THEN Elements[i] := GetElt (i) END;
        RETURN Elements[i];
      END;
    END;
    RETURN NIL;
  END LookUp;

CONST Names = ARRAY [0..24] OF TEXT {
  &quot;TranscriptView.fv&quot;,
  &quot;Obliq3DView.i3&quot;,
  &quot;AlgClass.m3&quot;,
  &quot;IE3D.i3&quot;,
  &quot;GEFView.m3&quot;,
  &quot;JunoView.m3&quot;,
  &quot;TranscriptView.m3&quot;,
  &quot;DataView.m3&quot;,
  &quot;ViewClass3D.i3&quot;,
  &quot;IE.m3&quot;,
  &quot;ObliqView.m3&quot;,
  &quot;AlgClass.i3&quot;,
  &quot;ViewClass.m3&quot;,
  &quot;GEFView.i3&quot;,
  &quot;JunoView.i3&quot;,
  &quot;TranscriptView.i3&quot;,
  &quot;Obliq3DView.m3&quot;,
  &quot;DataView.i3&quot;,
  &quot;IE3D.m3&quot;,
  &quot;IE.i3&quot;,
  &quot;ObliqView.i3&quot;,
  &quot;ViewClass.i3&quot;,
  &quot;EventData.fv&quot;,
  &quot;ViewClass3D.m3&quot;,
  NIL
};

VAR Elements := ARRAY [0..24] OF TEXT {
  E0,
  E1,
  NIL (* E2 .. E2_2 *),
  E3,
  NIL (* E4 .. E4_0 *),
  NIL (* E5 .. E5_1 *),
  NIL (* E6 .. E6_1 *),
  E7,
  E8,
  NIL (* E9 .. E9_0 *),
  NIL (* E10 .. E10_2 *),
  E11,
  E12,
  E13,
  E14,
  E15,
  NIL (* E16 .. E16_1 *),
  E17,
  NIL (* E18 .. E18_1 *),
  E19,
  E20,
  E21,
  E22,
  E23,
  NIL
};

PROCEDURE <A NAME="GetElt"><procedure>GetElt</procedure></A> (n: INTEGER): TEXT =
  &lt;*FATAL Thread.Alerted, Wr.Failure *&gt;
  VAR wr := TextWr.New ();
  BEGIN
    CASE n OF
    | 2 =&gt;
        Wr.PutText (wr, E2);
        Wr.PutText (wr, E2_0);
        Wr.PutText (wr, E2_1);
        Wr.PutText (wr, E2_2);
    | 4 =&gt;
        Wr.PutText (wr, E4);
        Wr.PutText (wr, E4_0);
    | 5 =&gt;
        Wr.PutText (wr, E5);
        Wr.PutText (wr, E5_0);
        Wr.PutText (wr, E5_1);
    | 6 =&gt;
        Wr.PutText (wr, E6);
        Wr.PutText (wr, E6_0);
        Wr.PutText (wr, E6_1);
    | 9 =&gt;
        Wr.PutText (wr, E9);
        Wr.PutText (wr, E9_0);
    | 10 =&gt;
        Wr.PutText (wr, E10);
        Wr.PutText (wr, E10_0);
        Wr.PutText (wr, E10_1);
        Wr.PutText (wr, E10_2);
    | 16 =&gt;
        Wr.PutText (wr, E16);
        Wr.PutText (wr, E16_0);
        Wr.PutText (wr, E16_1);
    | 18 =&gt;
        Wr.PutText (wr, E18);
        Wr.PutText (wr, E18_0);
        Wr.PutText (wr, E18_1);
    ELSE (*skip*)
    END;
    RETURN TextWr.ToText (wr);
  END GetElt;

CONST E0 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:37:06 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file #(_A&quot;
 &amp; &quot;LGNAME_).evt.\n;*******************************************************&quot;
 &amp; &quot;*************\n\n(VBox\n  (Rim\n    (Pen 2)\n    (HBox\n      (VBox (Gl&quot;
 &amp; &quot;ue 4) (Shape (Height + Inf) (Button %clear \&quot;CLEAR\&quot;)) (Glue 4))\n     &quot;
 &amp; &quot; (Glue 4)\n      (VBox\n        (Boolean =TRUE %alg (Text LeftAlign \&quot;A&quot;
 &amp; &quot;lgorithm events\&quot;))\n        (Boolean =FALSE %zeus (Text LeftAlign \&quot;Ze&quot;
 &amp; &quot;us events\&quot;))\n        (Boolean =TRUE %args (Text LeftAlign \&quot;Display a&quot;
 &amp; &quot;rgs to events\&quot;)))\n      Fill))\n  (Bar 1)\n  (Shape (ShadowSize 0) (H&quot;
 &amp; &quot;eight 200 + INF) (TextEdit ReadOnly %transcript)))\n&quot;;

CONST E1 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Wed Feb &quot;
 &amp; &quot; 8 15:34:46 PST 1995 by kalsow  *)\n(*      modified on Mon Jan 24 10:0&quot;
 &amp; &quot;0:27 PST 1994 by najork  *)\n(*      modified on Sat Jul 17 10:55:21 PD&quot;
 &amp; &quot;T 1993 by mhb     *)\n(*      modified on Wed Feb 17 16:47:18 PST 1993 &quot;
 &amp; &quot;by johnh   *)\n\n(*****************************************************&quot;
 &amp; &quot;****************\n|*  NOTE: This file is generated automatically from t&quot;
 &amp; &quot;he event \n|*        definition file #(_ALGNAME_).evt.\n|**************&quot;
 &amp; &quot;*******************************************************)\n\nINTERFACE #&quot;
 &amp; &quot;(_ALGNAME_)#(_VIEWNAME_)Obliq3DView;\nEND #(_ALGNAME_)#(_VIEWNAME_)Obli&quot;
 &amp; &quot;q3DView.\n\n&quot;;

CONST E2 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:48:22 PST 1995 by kalsow  *)\n(*      modified on Wed Feb 17 16:4&quot;
 &amp; &quot;6:18 PST 1993 by johnh   *)\n(*      modified on Thu Sep 24 10:59:20 PD&quot;
 &amp; &quot;T 1992 by mhb     *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\nMODU&quot;
 &amp; &quot;LE #(_ALGNAME_)AlgClass;\n\n$Algorithm\n$Fmt\n$FormsVBT\n$Rd\n$Text\n$V&quot;
 &amp; &quot;BT\n$Wr\n$ZeusClass\n$ZeusPanel\n$ZeusUtil\n#(_IMPORTS_)\n\n&lt;* PRAGMA L&quot;
 &amp; &quot;L *&gt;\n\n(* Fix any FormsVBT errors; don\'t handle exceptions for them. &quot;
 &amp; &quot;*)\n&lt;* FATAL FormsVBT.Error, FormsVBT.Unimplemented *&gt;\n\n\nREVEAL\n  T&quot;
 &amp; &quot; = Public BRANDED OBJECT\n      OVERRIDES\n        &lt;* LL = VBT.mu *&gt;\n &quot;
 &amp; &quot;       init := #(_ALGNAME_)DefaultInit;\n        snapshot := #(_ALGNAME&quot;
 &amp; &quot;_)DefaultSnapshot;\n        restore := #(_ALGNAME_)DefaultRestore;\n   &quot;
 &amp; &quot;     updateEventCounts := #(_ALGNAME_)DefaultUpdateCts;\n#{_FEEDBACK\n &quot;
 &amp; &quot;       fe#(_EVENT_) := #(_EVENT_);\n#}\n      END;\n\nPROCEDURE #(_ALGN&quot;
 &amp; &quot;AME_)DefaultInit (v: T): Algorithm.T = \n  &lt;* LL = VBT.mu *&gt;\n  PROCEDU&quot;
 &amp; &quot;RE Attach (id: TEXT; proc: FormsVBT.Proc) =\n    BEGIN\n      FormsVBT.&quot;
 &amp; &quot;AttachProc(v.eventData, id, proc, v);\n    END Attach;\n  BEGIN\n    v.&quot;
 &amp; &quot;eventData := ZeusPanel.NewForm(\&quot;#(_ALGNAME_)EventData.fv\&quot;);\n    Atta&quot;
 &amp; &quot;ch(\&quot;stopatCodeEvents\&quot;, #(_ALGNAME_)DoIt);\n    Attach(\&quot;waitatCodeEve&quot;
 &amp; &quot;nts\&quot;, #(_ALGNAME_)DoIt);\n    Attach(\&quot;eventCounts\&quot;, #(_ALGNAME_)Refr&quot;
 &amp; &quot;eshCts);\n#{_OUTPUT\n    Attach(\&quot;stopAt#(_EVENT_)\&quot;, #(_ALGNAME_)DoIt)&quot;
 &amp; &quot;;\n    Attach(\&quot;waitAt#(_EVENT_)\&quot;, #(_ALGNAME_)DoIt);\n#}\n    FromFV &quot;
 &amp; &quot;(v.eventData, v);    (* Get FV and internal data in sync *)\n    RETURN&quot;
 &amp; &quot; Algorithm.T.init(v);\n  END #(_ALGNAME_)DefaultInit;\n\nPROCEDURE #(_A&quot;
 &amp; &quot;LGNAME_)DoIt (     &quot;;

CONST E2_0 =
   &quot;      fv : FormsVBT.T;\n                           e  : TEXT;\n        &quot;
 &amp; &quot;                   arg: REFANY;\n                &lt;*UNUSED*&gt; t  : VBT.Ti&quot;
 &amp; &quot;meStamp) =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN \n    IF Text.Equal(e, \&quot;stopa&quot;
 &amp; &quot;tCodeEvents\&quot;) THEN\n      NARROW(arg, T).stopatCodeEvents :=\n        &quot;
 &amp; &quot;  FormsVBT.GetBoolean(fv, \&quot;stopatCodeEvents\&quot;);\n    END;\n    IF Text&quot;
 &amp; &quot;.Equal(e, \&quot;waitatCodeEvents\&quot;) THEN\n      NARROW(arg, T).waitatCodeEv&quot;
 &amp; &quot;ents :=\n          FormsVBT.GetInteger(fv, \&quot;waitatCodeEvents\&quot;);\n    &quot;
 &amp; &quot;END;\n#{_OUTPUT\n    IF Text.Equal(e, \&quot;stopAt#(_EVENT_)\&quot;) THEN\n     &quot;
 &amp; &quot; NARROW(arg, T).eventDataRec.stopAt#(_EVENT_) :=\n          FormsVBT.Ge&quot;
 &amp; &quot;tBoolean(fv, \&quot;stopAt#(_EVENT_)\&quot;);\n    END;\n    IF Text.Equal(e, \&quot;w&quot;
 &amp; &quot;aitAt#(_EVENT_)\&quot;) THEN\n      NARROW(arg, T).eventDataRec.waitAt#(_EVE&quot;
 &amp; &quot;NT_) :=\n          FormsVBT.GetInteger(fv, \&quot;waitAt#(_EVENT_)\&quot;);\n    &quot;
 &amp; &quot;END;\n#}\n  END #(_ALGNAME_)DoIt;\n\nPROCEDURE #(_ALGNAME_)RefreshCts (&quot;
 &amp; &quot;\n                &lt;*UNUSED*&gt; fv  : FormsVBT.T;\n                &lt;*UNUSE&quot;
 &amp; &quot;D*&gt; e   : TEXT;\n                           arg : REFANY;\n            &quot;
 &amp; &quot;    &lt;*UNUSED*&gt; t   : VBT.TimeStamp) =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN\n  &quot;
 &amp; &quot;  NARROW(arg, T).updateEventCounts(FALSE);\n  END #(_ALGNAME_)RefreshCt&quot;
 &amp; &quot;s;\n\nPROCEDURE FromFV (fv : FormsVBT.T; alg: T) =\n  &lt;* LL = VBT.mu *&gt;&quot;
 &amp; &quot;\n  BEGIN \n    alg.stopatCodeEvents :=\n        FormsVBT.GetBoolean(fv&quot;
 &amp; &quot;, \&quot;stopatCodeEvents\&quot;);\n    alg.waitatCodeEvents :=\n        FormsVBT&quot;
 &amp; &quot;.GetInteger(fv, \&quot;waitatCodeEvents\&quot;);\n#{_OUTPUT\n    alg.eventDataRec&quot;
 &amp; &quot;.stopAt#(_EVENT_) :=\n        FormsVBT.GetBoolean(fv, \&quot;stopAt#(_EVENT_&quot;
 &amp; &quot;)\&quot;);\n    alg.eventDataRec.waitAt#(_EVENT_) :=\n        FormsVBT.GetIn&quot;
 &amp; &quot;teger(fv, \&quot;waitAt#(_EVENT_)\&quot;);\n#}\n  END FromFV;\n\n&lt;*UNUSED*&gt; \nPRO&quot;
 &amp; &quot;CEDURE ToFV (fv : FormsVBT.T; alg: T) =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN \n&quot;
 &amp; &quot;    FormsVBT.PutBoolean(fv, \&quot;stopatCodeEvents\&quot;, alg.stopatCodeEvents)&quot;
 &amp; &quot;;\n    FormsVBT.PutInteger(fv, \&quot;waitatCodeEvents\&quot;, alg.waitatCodeEven&quot;
 &amp; &quot;ts);\n#{_OUTPUT\n    FormsVBT.PutBoolean(fv, \&quot;stopAt#(_EVENT_)\&quot;, \n  &quot;
 &amp; &quot;                      alg.eventDataRec.stopAt#(_EVENT_));\n    FormsVBT&quot;
 &amp; &quot;.PutInteger(fv, \&quot;waitAt#(_EVEN&quot;;

CONST E2_1 =
   &quot;T_)\&quot;, \n                        alg.eventDataRec.waitAt#(_EVENT_));\n#&quot;
 &amp; &quot;}\n    CountsToFV (fv, alg);\n  END ToFV;\n\nPROCEDURE CountsToFV (fv :&quot;
 &amp; &quot; FormsVBT.T; alg: T) =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN \n#{_OUTPUT\n    F&quot;
 &amp; &quot;ormsVBT.PutText(fv, \&quot;ctOf#(_EVENT_)\&quot;, \n                        Fmt.I&quot;
 &amp; &quot;nt(alg.eventDataRec.ctOf#(_EVENT_)));\n#}\n  END CountsToFV;\n\nPROCEDU&quot;
 &amp; &quot;RE #(_ALGNAME_)DefaultUpdateCts ( v: T; reset: BOOLEAN) =\n  &lt;* LL = VB&quot;
 &amp; &quot;T.mu *&gt;\n  BEGIN\n    IF reset THEN\n#{_OUTPUT\n      v.eventDataRec.ct&quot;
 &amp; &quot;Of#(_EVENT_) := 0;\n#}\n    END;\n    CountsToFV (v.eventData, v);\n  E&quot;
 &amp; &quot;ND #(_ALGNAME_)DefaultUpdateCts;\n\n\nPROCEDURE #(_ALGNAME_)DefaultSnap&quot;
 &amp; &quot;shot (v: T; wr: Wr.T) \n  RAISES {ZeusClass.Error} =\n  &lt;* LL = VBT.mu &quot;
 &amp; &quot;*&gt;\n  BEGIN\n    TRY\n      Wr.PutChar(wr, \'(\')\n    EXCEPT\n    ELSE&quot;
 &amp; &quot;\n      RAISE ZeusClass.Error(\n          \&quot;#(_ALGNAME_)AlgClass.#(_ALG&quot;
 &amp; &quot;NAME_)DefaultSnapshot write error\&quot;);\n    END;\n    IF v.eventData = N&quot;
 &amp; &quot;IL THEN\n      RAISE ZeusClass.Error(\n          \&quot;#(_ALGNAME_)AlgClass&quot;
 &amp; &quot;.#(_ALGNAME_)DefaultSnapshot: \&quot; &amp; \n          \&quot;eventData not set!\&quot;);&quot;
 &amp; &quot;\n    END;\n    TRY\n      v.eventData.snapshot(wr)\n    EXCEPT\n      &quot;
 &amp; &quot;FormsVBT.Error (msg) =&gt;\n        RAISE ZeusClass.Error(\n          \&quot;#(&quot;
 &amp; &quot;_ALGNAME_)AlgClass.#(_ALGNAME_)DefaultSnapshot FV error: \&quot; \n         &quot;
 &amp; &quot; &amp; msg);\n    ELSE\n      RAISE ZeusClass.Error(\n        \&quot;#(_ALGNAME_&quot;
 &amp; &quot;)AlgClass.#(_ALGNAME_)DefaultSnapshot error\&quot;);\n    END;\n    Algorith&quot;
 &amp; &quot;m.T.snapshot(v, wr);\n    TRY\n      Wr.PutChar(wr, \')\')\n    EXCEPT\n&quot;
 &amp; &quot;    ELSE\n      RAISE ZeusClass.Error(\n          \&quot;#(_ALGNAME_)AlgClas&quot;
 &amp; &quot;s.#(_ALGNAME_)DefaultSnapshot write error\&quot;);\n    END;\n  END #(_ALGNA&quot;
 &amp; &quot;ME_)DefaultSnapshot;\n\n\nPROCEDURE #(_ALGNAME_)DefaultRestore (v: T; r&quot;
 &amp; &quot;d: Rd.T) \n  RAISES {ZeusClass.Error} =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN\n&quot;
 &amp; &quot;    IF rd = NIL THEN RETURN END;\n    IF NOT ZeusUtil.EatChar(rd, \'(\'&quot;
 &amp; &quot;) THEN\n      RAISE ZeusClass.Error(\n          \&quot;#(_ALGNAME_)AlgClass.&quot;
 &amp; &quot;#(_ALGNAME_)DefaultRestore read error\&quot;);\n    END;\n    IF v.eventData&quot;
 &amp; &quot; = NIL THEN\n      RAISE ZeusClass.Error(\n          \&quot;#(_ALGNAME_)AlgC&quot;
 &amp; &quot;lass.#(_ALGNAME_)DefaultRestore: \&quot; &amp; \n  &quot;;

CONST E2_2 =
   &quot;        \&quot;eventData not set!\&quot;);\n    END;\n    TRY\n      v.eventData.&quot;
 &amp; &quot;restore(rd);\n      v.updateEventCounts(FALSE);\n      FromFV(v.eventDa&quot;
 &amp; &quot;ta, v);\n    EXCEPT\n    ELSE\n      RAISE ZeusClass.Error(\n          &quot;
 &amp; &quot;\&quot;#(_ALGNAME_)AlgClass.#(_ALGNAME_)DefaultRestore error\&quot;);\n    END;\n&quot;
 &amp; &quot;    Algorithm.T.restore(v, rd);\n    IF NOT ZeusUtil.EatChar(rd, \')\')&quot;
 &amp; &quot; THEN\n      RAISE ZeusClass.Error(\n          \&quot;#(_ALGNAME_)AlgClass.#&quot;
 &amp; &quot;(_ALGNAME_)DefaultRestore read error\&quot;);\n    END;\n  END #(_ALGNAME_)D&quot;
 &amp; &quot;efaultRestore;\n\n#{_FEEDBACK\nPROCEDURE #(_EVENT_) (self: T\n#{\n    ;&quot;
 &amp; &quot; &lt;*UNUSED*&gt; #(_ARGMODE_)#(_ARGNAME_): #(_ARGTYPE_)\n#}\n) =\n  &lt;* LL = &quot;
 &amp; &quot;VBT.mu *&gt;\n  BEGIN\n    self.evtHandled := FALSE;\n  END #(_EVENT_);\n\n&quot;
 &amp; &quot;#}\n\nBEGIN\nEND #(_ALGNAME_)AlgClass.\n&quot;;

CONST E3 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:51:16 PST 1995 by kalsow  *)\n(* Last modified on Wed Feb 17 16:4&quot;
 &amp; &quot;6:35 PST 1993 by johnh   *)\n\n(***************************************&quot;
 &amp; &quot;******************************\n|*  NOTE: This file is generated automa&quot;
 &amp; &quot;tically from the event \n|*        definition file #(_ALGNAME_).evt.\n|&quot;
 &amp; &quot;*********************************************************************)\n&quot;
 &amp; &quot;\n&lt;* PRAGMA LL *&gt;\n\nINTERFACE #(_ALGNAME_)IE;\n\n$Algorithm\n$Thread\n&quot;
 &amp; &quot;$View\n#(_IMPORTS_)\n\n(* call the following to generate an event: *)\n&quot;
 &amp; &quot;\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (\n      initiator: Algorithm.T; \n  &quot;
 &amp; &quot;    #(_ARGSTR_) \n    ) RAISES {Thread.Alerted};\n    &lt;* LL = {} *&gt;\n\n&quot;
 &amp; &quot;#}\n#{_FEEDBACK\nPROCEDURE #(_EVENT_) (\n      initiator: View.T; \n   &quot;
 &amp; &quot;   #(_ARGSTR_) \n    ) RAISES {Thread.Alerted};\n    &lt;* LL = VBT.mu *&gt;\n&quot;
 &amp; &quot;\n#}\n#{_UPDATE\nPROCEDURE #(_EVENT_) (\n      initiator: Algorithm.T; &quot;
 &amp; &quot;\n      #(_ARGSTR_) \n    ) RAISES {Thread.Alerted};\n    &lt;* LL = VBT.m&quot;
 &amp; &quot;u *&gt;\n\n#}\n\nEND #(_ALGNAME_)IE.\n&quot;;

CONST E4 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 09:01:09 PST 1995 by kalsow  *)\n(* Last modified on Sat Jul 17 14:2&quot;
 &amp; &quot;8:37 PDT 1993 by mhb     *)\n(*      modified on Thu Jul 15 14:12:41 PD&quot;
 &amp; &quot;T 1993 by steveg  *)\n(*      modified on Tue Feb 16 16:31:40 PST 1993 &quot;
 &amp; &quot;by johnh   *)\n\n(*****************************************************&quot;
 &amp; &quot;****************\n|*  NOTE: This file is generated automatically from t&quot;
 &amp; &quot;he event \n|*        definition file #(_ALGNAME_).evt.\n|**************&quot;
 &amp; &quot;*******************************************************)\n\n&lt;* PRAGMA L&quot;
 &amp; &quot;L *&gt;\n\nMODULE #(_ALGNAME_)#(_VIEWNAME_)GEFView;\n\n$Filter\n$Fmt\n$GEF&quot;
 &amp; &quot;\n$GEFError\n$GEFViewClass\n$GraphVBT\n$Rd\n$Rsrc\n$SLisp\n$Thread\n$VB&quot;
 &amp; &quot;T\n$View\n$ViewClass\n$ZeusClass\n$ZeusPanel\n$#(_ALGNAME_)AlgClass\n$#&quot;
 &amp; &quot;(_ALGNAME_)ViewClass\n#(_IMPORTS_)\n\nTYPE\n  T = #(_ALGNAME_)ViewClass&quot;
 &amp; &quot;.T BRANDED OBJECT\n        name := \&quot;#(_VIEWNAME_).gef\&quot;; \n      OVERR&quot;
 &amp; &quot;IDES\n        &lt;* LL = VBT.mu *&gt;\n        install  := Install;\n        &quot;
 &amp; &quot;startrun := Startrun;\n        &lt;* LL = 0 *&gt;\n#{_OUTPUT\n        oe#(_EV&quot;
 &amp; &quot;ENT_) := #(_EVENT_);\n#}\n      END;\n\nPROCEDURE Install (v: T) =\n  &lt;&quot;
 &amp; &quot;* FATAL SLisp.Error *&gt;\n  VAR\n    interp := NEW(GEFViewClass.Interp).i&quot;
 &amp; &quot;nit();\n    gef    := NEW(GEF.T).init(interp);\n  BEGIN\n    EVAL Filte&quot;
 &amp; &quot;r.Replace (v, gef);\n    #(_ALGNAME_)ViewClass.T.install(v)\n  END Inst&quot;
 &amp; &quot;all;\n\nPROCEDURE Startrun(v: T) =\n  BEGIN\n    TRY\n      GEF.InitFro&quot;
 &amp; &quot;mRsrc(Filter.Child(v), v.name, ZeusPanel.GetPath());\n    EXCEPT\n    |&quot;
 &amp; &quot; Thread.Alerted =&gt;\n    | Rsrc.NotFound =&gt;\n        ZeusPanel.ReportErr&quot;
 &amp; &quot;or(\n          Fmt.F(\&quot;GEF View error: Could not find file: %s\&quot;, v.nam&quot;
 &amp; &quot;e));\n    | Rd.Failure =&gt;\n        ZeusPanel.ReportError(\n          Fm&quot;
 &amp; &quot;t.F(\&quot;GEF View error finding or parsing file: %s\&quot;, v.name));\n    | GE&quot;
 &amp; &quot;FError.T (msg) =&gt;\n        ZeusPanel.ReportError(\n          Fmt.F(\&quot;GE&quot;
 &amp; &quot;F View error (%s) pars&quot;;

CONST E4_0 =
   &quot;ing file: %s\&quot;, msg, v.name));\n    END;\n  END Startrun;\n\nPROCEDURE &quot;
 &amp; &quot;New (): View.T =\n  VAR g := NEW(GraphVBT.T).init(); \n  BEGIN\n    RET&quot;
 &amp; &quot;URN NEW(T).init(g)\n  END New;\n\n(* event handling methods: *)\n\n#{_O&quot;
 &amp; &quot;UTPUT\nPROCEDURE #(_EVENT_) (view: T; #(_ARGSTR_)) =\n  &lt;* LL = {} *&gt;\n&quot;
 &amp; &quot;  VAR gef: GEF.T := Filter.Child(view);\n  BEGIN\n    TRY\n      GEF.In&quot;
 &amp; &quot;vokeEvent (gef, \&quot;#(_EVENT_)\&quot;, GEF.EventData(\n#{\n      #(_ARGFMT_)(#&quot;
 &amp; &quot;(_ARGNAME_))\n#|\n      ,\n#}\n      ));\n      gef.redisplay();\n     &quot;
 &amp; &quot; gef.animate(0.0, 1.0);\n    EXCEPT\n    | Thread.Alerted =&gt;\n    | GEF&quot;
 &amp; &quot;Error.T (msg) =&gt;\n        ZeusPanel.ReportError(\n          Fmt.F(\&quot;GEF&quot;
 &amp; &quot; View error (%s) parsing file: %s\&quot;, msg, view.name));\n    END;\n  END&quot;
 &amp; &quot; #(_EVENT_);\n\n#}\n\nBEGIN\n  ZeusPanel.RegisterView(New, \&quot;#(_VIEWNAM&quot;
 &amp; &quot;E_).gef\&quot;, \&quot;#(_ALGNAME_)\&quot;); \nEND #(_ALGNAME_)#(_VIEWNAME_)GEFView.\n&quot;
;

CONST E5 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:59:04 PST 1995 by kalsow  *)\n(*      modified on Mon Jun  6 03:1&quot;
 &amp; &quot;6:18 PDT 1994 by mhb     *)\n(*      modified on Sun Jun  5 16:47:33 PD&quot;
 &amp; &quot;T 1994 by heydon  *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\n&lt;* P&quot;
 &amp; &quot;RAGMA LL *&gt;\n\nMODULE #(_ALGNAME_)#(_VIEWNAME_)JunoView;\n\n$Atom\n$Ato&quot;
 &amp; &quot;mList\n$Fmt\n$NetObj\n$Thread\n$VBT\n$Wr\n$Rd\n$ZFmt\n$ZeusPanel\n$Remo&quot;
 &amp; &quot;teView\n$View\n$#(_ALGNAME_)ViewClass\n#(_IMPORTS_)\n\nTYPE\n  T = #(_A&quot;
 &amp; &quot;LGNAME_)ViewClass.T BRANDED OBJECT\n         jz: RemoteView.T := NIL;\n&quot;
 &amp; &quot;      OVERRIDES\n        &lt;* LL.sup &lt; VBT.mu *&gt;\n        startrun := Sta&quot;
 &amp; &quot;rtrun;\n        endrun := Endrun;\n        &lt;* LL.sup &lt; VBT.mu *&gt;\n#{_OU&quot;
 &amp; &quot;TPUT\n        oe#(_EVENT_) := #(_EVENT_);\n#}\n        &lt;* LL.sup = VBT.&quot;
 &amp; &quot;mu *&gt;\n#{_UPDATE\n        ue#(_EVENT_) := #(_EVENT_);\n#}\n        &lt;* L&quot;
 &amp; &quot;L.sup = VBT.mu *&gt;\n        install := NoargNoop;\n        delete := Noa&quot;
 &amp; &quot;rgNoop;\n        snapshot := SnapshotNoop;\n        restore := RestoreN&quot;
 &amp; &quot;oop;\n        reactivity := ReactivityNoop\n      END;\n\n(* STARTRUN a&quot;
 &amp; &quot;nd ENDRUN methods: *)\n\nPROCEDURE Startrun(view: T) =\n  &lt;* LL.sup &lt; V&quot;
 &amp; &quot;BT.mu *&gt;\n  BEGIN\n    IF view.jz = NIL THEN RETURN END;\n    TRY view.&quot;
 &amp; &quot;jz.startrun() EXCEPT\n      NetObj.Error (err) =&gt; ZeusPanel.ReportError&quot;
 &amp; &quot;(NetObjError(err))\n    | Thread.Alerted =&gt; ZeusPanel.ReportError(\&quot;Net&quot;
 &amp; &quot;Obj call alerted\&quot;)\n    END\n  END Startrun;\n\nPROCEDURE Endrun(view:&quot;
 &amp; &quot; T) =\n  &lt;* LL.sup &lt; VBT.mu *&gt;\n  BEGIN\n    IF view.jz = NIL THEN RETU&quot;
 &amp; &quot;RN END;\n    TRY view.jz.endrun() EXCEPT\n      NetObj.Error (err) =&gt; Z&quot;
 &amp; &quot;eusPanel.ReportError(NetObjError(err))\n    | Thread.Alerted =&gt; ZeusPan&quot;
 &amp; &quot;el.ReportError(\&quot;&quot;;

CONST E5_0 =
   &quot;NetObj call alerted\&quot;)\n    END\n  END Endrun;\n\n(* OUTPUT and UPDATE &quot;
 &amp; &quot;event handling methods: *)\n\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (view: T;&quot;
 &amp; &quot; #(_ARGSTR_)) =\n  &lt;* LL.sup &lt; VBT.mu *&gt;\n  CONST EventName = \&quot;#(_EVEN&quot;
 &amp; &quot;T_)\&quot;;\n  VAR tfactor: REAL; BEGIN \n    IF view.jz = NIL THEN RETURN E&quot;
 &amp; &quot;ND;\n    LOCK VBT.mu DO\n      tfactor := ZeusPanel.GetAnimationTime()\n&quot;
 &amp; &quot;    END;\n    TRY\n      view.jz.event (tfactor, EventName, \&quot;(\&quot;\n#{\n&quot;
 &amp; &quot;      &amp; #(_ARGFMT_)(#(_ARGNAME_))\n#|\n      &amp; \&quot; \&quot;\n#}\n      &amp; \&quot;)\&quot;&quot;
 &amp; &quot;)\n    EXCEPT\n      RemoteView.Error (txt) =&gt; ReportError(EventName, t&quot;
 &amp; &quot;xt)\n    | NetObj.Error (err) =&gt; ReportError(EventName, NetObjError(err&quot;
 &amp; &quot;))\n    | Thread.Alerted =&gt; ReportError(EventName, \&quot;NetObj call alerte&quot;
 &amp; &quot;d\&quot;)\n    END\n  END #(_EVENT_);\n\n#}\n#{_UPDATE\nPROCEDURE #(_EVENT_)&quot;
 &amp; &quot; (view: T; #(_ARGSTR_)) =\n  &lt;* LL.sup = VBT.mu *&gt;\n  CONST EventName =&quot;
 &amp; &quot; \&quot;#(_EVENT_)\&quot;;\n  VAR tfactor: REAL; BEGIN \n    IF view.jz = NIL THE&quot;
 &amp; &quot;N RETURN END;\n    tfactor := ZeusPanel.GetAnimationTime();\n    TRY\n &quot;
 &amp; &quot;     view.jz.event (tfactor, EventName, \&quot;(\&quot;\n#{\n      &amp; #(_ARGFMT_)(&quot;
 &amp; &quot;#(_ARGNAME_))\n#|\n      &amp; \&quot; \&quot;\n#}\n      &amp; \&quot;)\&quot;)\n    EXCEPT\n     &quot;
 &amp; &quot; RemoteView.Error (txt) =&gt; ReportError(EventName, txt)\n    | NetObj.Er&quot;
 &amp; &quot;ror (err) =&gt; ReportError(EventName, NetObjError(err))\n    | Thread.Ale&quot;
 &amp; &quot;rted =&gt; ReportError(EventName, \&quot;NetObj call alerted\&quot;)\n    END\n  END&quot;
 &amp; &quot; #(_EVENT_);\n\n#}\nPROCEDURE NoargNoop(&lt;*UNUSED*&gt; v: T) =\n  BEGIN END&quot;
 &amp; &quot; NoargNoop;\n\nPROCEDURE SnapshotNoop(&lt;*UNUSED*&gt; v: T; &lt;*UNUSED*&gt; wr: W&quot;
 &amp; &quot;r.T) =\n  BEGIN END SnapshotNoop;\n\nPROCEDURE RestoreNoop(&lt;*UNUSED*&gt; v&quot;
 &amp; &quot;: T; &lt;*UNUSED*&gt; rd: Rd.T) =\n  BEGIN END RestoreNoop;\n\nPROCEDURE Reac&quot;
 &amp; &quot;tivityNoop(&lt;*UNUSED*&gt; v: T; &lt;*UNUSED*&gt; on: BOOLEAN) =\n  BEGIN END Reac&quot;
 &amp; &quot;tivityNoop;\n\nPROCEDURE New (): View.T =\n  VAR\n    res: T := NEW(T).&quot;
 &amp; &quot;init(NIL);\n    jz: NetObj.T;\n    errMsg: TEXT := NIL;\n  BEGIN\n    T&quot;
 &amp; &quot;RY\n      jz := NetObj.Import(\&quot;JunoZeus\&quot;);\n      IF jz = NIL THEN\n &quot;
 &amp; &quot;   \terrMsg := \&quot;NetObj Error: Can\'t find JunoZeus object\&quot;\n      ELS&quot;
 &amp; &quot;IF NOT ISTYPE(jz, RemoteView.T) THEN\n    \terrMsg := \&quot;NetObj Error: T&quot;
 &amp; &quot;ype mismatch between Juno and Zeus\&quot;\n      ELSE&quot;;

CONST E5_1 =
   &quot;\n    \tres.jz := jz;\n    \tRETURN res\n      END\n    EXCEPT\n      N&quot;
 &amp; &quot;etObj.Error (err) =&gt; errMsg := NetObjError(err)\n    | Thread.Alerted =&quot;
 &amp; &quot;&gt;     errMsg := \&quot;NetObj Import alerted\&quot;\n    END;\n    ZeusPanel.Repo&quot;
 &amp; &quot;rtError(errMsg);\n    RETURN NIL\n  END New;\n\nPROCEDURE NetObjError(e&quot;
 &amp; &quot;rr: AtomList.T): TEXT =\n  VAR res := \&quot;NetObj Error: \&quot;; BEGIN\n    WH&quot;
 &amp; &quot;ILE err # NIL DO\n      res := res &amp; Atom.ToText(err.head);\n      err &quot;
 &amp; &quot;:= err.tail;\n      IF err # NIL THEN res := res &amp; \&quot;; \&quot; END\n    END;&quot;
 &amp; &quot;\n    RETURN res\n  END NetObjError;\n\nPROCEDURE ReportError(nm, msg: &quot;
 &amp; &quot;TEXT) =\n  BEGIN\n    ZeusPanel.ReportError(\&quot;\\\&quot;\&quot; &amp; nm &amp; \&quot;\\\&quot; even&quot;
 &amp; &quot;t error: \&quot; &amp; msg)\n  END ReportError;\n\nPROCEDURE RegisterView () =\n&quot;
 &amp; &quot;  BEGIN \n    ZeusPanel.RegisterView(New, \&quot;#(_VIEWNAME_)\&quot;, \&quot;#(_ALGNA&quot;
 &amp; &quot;ME_)\&quot;)   \n  END RegisterView;\n\nBEGIN\n  RegisterView ();\nEND #(_AL&quot;
 &amp; &quot;GNAME_)#(_VIEWNAME_)JunoView.\n&quot;;

CONST E6 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:56:02 PST 1995 by kalsow  *)\n(*      modified on Mon Jun  6 03:1&quot;
 &amp; &quot;8:55 PDT 1994 by mhb   *)\n(*      modified on Tue Feb 16 16:31:40 PST &quot;
 &amp; &quot;1993 by johnh *)\n\n(**************************************************&quot;
 &amp; &quot;*******************\n|*  NOTE: This file is generated automatically fro&quot;
 &amp; &quot;m the event \n|*        definition file #(_ALGNAME_).evt.\n|***********&quot;
 &amp; &quot;**********************************************************)\n\n&lt;* PRAGM&quot;
 &amp; &quot;A LL *&gt;\n\nMODULE #(_ALGNAME_)TranscriptView;\n\n$ZFmt\n$Fmt\n$FormsVBT&quot;
 &amp; &quot;\n$Rd\n$Filter\n$TextEditVBT\n$TextPort\n$VBT\n$View\n$Wr\n$ZeusClass\n&quot;
 &amp; &quot;$ZeusPanel\n$#(_ALGNAME_)ViewClass\n#(_IMPORTS_)\n\n&lt;* FATAL FormsVBT.E&quot;
 &amp; &quot;rror, FormsVBT.Unimplemented *&gt;\n\nREVEAL\n  T = Public BRANDED OBJECT\n&quot;
 &amp; &quot;    fv: FormsVBT.T := NIL;\n    te: TextEditVBT.T := NIL;\n  OVERRIDES\n&quot;
 &amp; &quot;    init       := TViewInit;\n    install    := TViewInstall;\n    dele&quot;
 &amp; &quot;te     := TViewDelete;\n    snapshot   := TViewSnapshot;\n    restore  &quot;
 &amp; &quot;  := TViewRestore;\n    config     := TViewConfig;\n    reactivity := T&quot;
 &amp; &quot;ViewReactivity;\n    startrun   := TViewStartrun;\n    endrun     := TV&quot;
 &amp; &quot;iewEndrun;\n#{_OUTPUT\n    oe#(_EVENT_) := #(_EVENT_);\n#}\n#{_UPDATE\n&quot;
 &amp; &quot;    ue#(_EVENT_) := #(_EVENT_);\n#}\n  END;\n\nPROCEDURE TViewInit (vie&quot;
 &amp; &quot;w: T): T =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN\n    TViewZTrace (view, \&quot;init&quot;
 &amp; &quot;\&quot;);\n    RETURN #(_ALGNAME_)ViewClass.T.init (view, NIL);\n  END TView&quot;
 &amp; &quot;Init;\n\nPROCEDURE Clear (&lt;* UNUSED *&gt; fv  : FormsVBT.T;\n             &quot;
 &amp; &quot;    &lt;* UNUSED *&gt; name: TEXT;\n                              cl  : REFAN&quot;
 &amp; &quot;Y;\n                 &lt;* UNUSED *&gt; time: VBT.TimeStamp) =\n  BEGIN\n    &quot;
 &amp; &quot;TextPort.SetText(NARROW(cl, T).te.tp, \&quot;\&quot;)\n  END Clear;\n\nPROCEDURE &quot;
 &amp; &quot;TViewInstall (view: T) =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN\n    view.fv := &quot;
 &amp; &quot;ZeusPanel.NewForm(\&quot;#(_ALGNAME_)TranscriptView.fv\&quot;);\n    view.te := F&quot;
 &amp; &quot;ormsVBT.GetVBT(view.&quot;;

CONST E6_0 =
   &quot;fv, \&quot;transcript\&quot;);\n    TViewZTrace (view, \&quot;install\&quot;);\n    FormsVB&quot;
 &amp; &quot;T.AttachProc(view.fv, \&quot;clear\&quot;, Clear, view);\n    EVAL Filter.Replace&quot;
 &amp; &quot; (view, view.fv);\n    #(_ALGNAME_)ViewClass.T.install (view);\n  END T&quot;
 &amp; &quot;ViewInstall;\n\nPROCEDURE TViewDelete (view: T) =\n  &lt;* LL = VBT.mu *&gt;\n&quot;
 &amp; &quot;  BEGIN \n    TViewZTrace (view, \&quot;delete\&quot;);\n    #(_ALGNAME_)ViewClas&quot;
 &amp; &quot;s.T.delete (view);\n   END TViewDelete;\n\nPROCEDURE TViewSnapshot (vie&quot;
 &amp; &quot;w: T; wr: Wr.T) RAISES {ZeusClass.Error} =\n  &lt;* LL = VBT.mu *&gt;\n  BEGI&quot;
 &amp; &quot;N \n    TViewZTrace (view, \&quot;snapshot\&quot;);\n    #(_ALGNAME_)ViewClass.T.&quot;
 &amp; &quot;snapshot (view, wr);\n   END TViewSnapshot;\n\nPROCEDURE TViewRestore (&quot;
 &amp; &quot;view: T; rd: Rd.T) RAISES {ZeusClass.Error} =\n  &lt;* LL = VBT.mu *&gt;\n  B&quot;
 &amp; &quot;EGIN \n    TViewZTrace (view, \&quot;restore\&quot;);\n    #(_ALGNAME_)ViewClass.&quot;
 &amp; &quot;T.restore (view, rd);\n   END TViewRestore;\n\nPROCEDURE TViewConfig (\n&quot;
 &amp; &quot;    view: T; \n    state: ZeusClass.StateChange; \n    o: ZeusClass.T) &quot;
 &amp; &quot;=\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN \n    TViewZTrace (view, \&quot;config\&quot;);\n&quot;
 &amp; &quot;    #(_ALGNAME_)ViewClass.T.config (view, state, o);\n   END TViewConfi&quot;
 &amp; &quot;g;\n\nPROCEDURE TViewReactivity (view: T; &lt;*UNUSED*&gt; on: BOOLEAN) =\n  &quot;
 &amp; &quot;&lt;* LL = VBT.mu *&gt;\n  BEGIN\n    TViewZTrace(view, \&quot;reactivity\&quot;);\n   &quot;
 &amp; &quot; #(_ALGNAME_)ViewClass.T.reactivity (view, TRUE);\n  END TViewReactivit&quot;
 &amp; &quot;y;\n\nPROCEDURE TViewStartrun (view: T) =\n  &lt;* LL = {} *&gt;\n  BEGIN \n &quot;
 &amp; &quot;   TViewZTrace (view, \&quot;startrun\&quot;);\n    #(_ALGNAME_)ViewClass.T.start&quot;
 &amp; &quot;run (view);\n   END TViewStartrun;\n\nPROCEDURE TViewEndrun (view: T) =&quot;
 &amp; &quot;\n  &lt;* LL = {} *&gt;\n  BEGIN \n    TViewZTrace (view, \&quot;endrun\&quot;);\n    #&quot;
 &amp; &quot;(_ALGNAME_)ViewClass.T.endrun (view);\n  END TViewEndrun;\n\n\n(* event&quot;
 &amp; &quot; handling methods: *)\n\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (view: T; #(_A&quot;
 &amp; &quot;RGSTR_)) =\n  &lt;* LL = {} *&gt;\n  BEGIN \n    LOCK VBT.mu DO\n    IF Forms&quot;
 &amp; &quot;VBT.GetBoolean(view.fv, \&quot;alg\&quot;) THEN\n       IF NOT FormsVBT.GetBoolea&quot;
 &amp; &quot;n(view.fv, \&quot;args\&quot;) THEN\n          TViewTrace (view, \&quot;#(_EVENT_) ...&quot;
 &amp; &quot;\&quot;)\n       ELSE\n          TViewTrace (view, \&quot;#(_EVENT_) \&quot; \n#{\n   &quot;
 &amp; &quot;       &amp; #(_ARGFMT_)(#(_ARGNAME_))\n#|\n          &amp; \&quot; \&quot;\n#}\n        &quot;
 &amp; &quot;  )\n       END\n    END\n    END\n  END #(_EVENT_&quot;;

CONST E6_1 =
   &quot;);\n\n#}\n\n\n#{_UPDATE\nPROCEDURE #(_EVENT_) (view: T; #(_ARGSTR_)) =\n&quot;
 &amp; &quot;  &lt;* LL = VBT.mu *&gt;\n  BEGIN \n    IF FormsVBT.GetBoolean(view.fv, \&quot;al&quot;
 &amp; &quot;g\&quot;) THEN\n       IF NOT FormsVBT.GetBoolean(view.fv, \&quot;args\&quot;) THEN\n &quot;
 &amp; &quot;         TViewTrace (view, \&quot;#(_EVENT_) ...\&quot;)\n       ELSE\n          &quot;
 &amp; &quot;TViewTrace (view, \&quot;#(_EVENT_) \&quot; \n#{\n            &amp; #(_ARGFMT_)(#(_AR&quot;
 &amp; &quot;GNAME_))\n#|\n            &amp; \&quot; \&quot;\n#}\n            )\n       END\n   EN&quot;
 &amp; &quot;D\n  END #(_EVENT_);\n\n#}\n\n\nPROCEDURE TViewZTrace (view: T; t: TEXT&quot;
 &amp; &quot;) =\n  BEGIN\n    IF view.fv # NIL THEN\n      IF FormsVBT.GetBoolean(v&quot;
 &amp; &quot;iew.fv, \&quot;zeus\&quot;) THEN\n        TextPort.PutText(view.te.tp, \&quot;**zeus: &quot;
 &amp; &quot; \&quot; &amp; t &amp; \&quot;\\n\&quot;);\n        TextPort.Normalize(view.te.tp, LAST(INTEGE&quot;
 &amp; &quot;R))\n      END\n    END\n  END TViewZTrace;\n\nPROCEDURE TViewTrace (vi&quot;
 &amp; &quot;ew: T; t: TEXT) =\n  BEGIN\n    TextPort.PutText(view.te.tp, \&quot;--event:&quot;
 &amp; &quot; \&quot; &amp; t &amp; \&quot;\\n\&quot;);\n    TextPort.Normalize(view.te.tp, LAST(INTEGER))\n&quot;
 &amp; &quot;  END TViewTrace;\n\n\nPROCEDURE TViewNew (): View.T =\n  BEGIN\n    RE&quot;
 &amp; &quot;TURN NEW(T).init()\n  END TViewNew;\n\n\nBEGIN\n  ZeusPanel.RegisterVie&quot;
 &amp; &quot;w \n      (TViewNew, \&quot;#(_ALGNAME_) Transcript View\&quot;, \&quot;#(_ALGNAME_)\&quot;&quot;
 &amp; &quot;); \nEND #(_ALGNAME_)TranscriptView.\n&quot;;

CONST E7 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:54:53 PST 1995 by kalsow  *)\n(*      modified on Tue Jul 13 10:4&quot;
 &amp; &quot;0:26 PDT 1993 by mhb     *)\n\n(***************************************&quot;
 &amp; &quot;******************************\n|*  NOTE: This file is generated automa&quot;
 &amp; &quot;tically from the event \n|*        definition file #(_ALGNAME_).evt.\n|&quot;
 &amp; &quot;*********************************************************************)\n&quot;
 &amp; &quot;\nMODULE #(_ALGNAME_)DataView;\n\nIMPORT ZeusDataView, ZeusPanel;\n\nBE&quot;
 &amp; &quot;GIN\n  ZeusPanel.RegisterView (\n    ZeusDataView.New, \n    \&quot;#(_ALGNA&quot;
 &amp; &quot;ME_) Data View\&quot;, \n    \&quot;#(_ALGNAME_)\&quot;); \nEND #(_ALGNAME_)DataView.\n&quot;
;

CONST E8 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:57:10 PST 1995 by kalsow  *)\n(*      modified on Sun Nov 28 23:0&quot;
 &amp; &quot;9:13 PST 1993 by najork  *)\n\n(***************************************&quot;
 &amp; &quot;******************************\n|*  NOTE: This file is generated automa&quot;
 &amp; &quot;tically from the event \n|*        definition file #(_ALGNAME_).evt.\n|&quot;
 &amp; &quot;*********************************************************************)\n&quot;
 &amp; &quot;\n&lt;* PRAGMA LL *&gt;\n\nINTERFACE #(_ALGNAME_)3DViewClass;\n\n$Thread\n$Vi&quot;
 &amp; &quot;ew3D\n#(_IMPORTS_)\n\nTYPE\n  T &lt;: Public;\n  Public = View3D.T OBJECT\n&quot;
 &amp; &quot;      METHODS\n      &lt;*LL = {} *&gt;\n#{_OUTPUT\n        oe#(_EVENT_) (#(_&quot;
 &amp; &quot;ARGSTR_)) RAISES {Thread.Alerted};\n#}\n      &lt;*LL = VBT.mu *&gt;\n#{_UPDA&quot;
 &amp; &quot;TE\n        ue#(_EVENT_) (#(_ARGSTR_)) RAISES {Thread.Alerted};\n#}\n  &quot;
 &amp; &quot;    END;\n      \nEND #(_ALGNAME_)3DViewClass.\n&quot;;

CONST E9 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:50:48 PST 1995 by kalsow  *)\n(*      modified on Sun Jun  5 21:5&quot;
 &amp; &quot;9:57 PDT 1994 by mhb     *)\n(*      modified on Wed Feb 17 16:46:47 PS&quot;
 &amp; &quot;T 1993 by johnh   *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\n&lt;* P&quot;
 &amp; &quot;RAGMA LL *&gt;\n\nMODULE #(_ALGNAME_)IE;\n\n$Algorithm\n$AlgorithmClass\n$&quot;
 &amp; &quot;Thread\n$View\n$Zeus\n$ZeusClass\n$#(_ALGNAME_)AlgClass\n$#(_ALGNAME_)V&quot;
 &amp; &quot;iewClass\n#(_IMPORTS_)\n\n&lt;* FATAL Zeus.Error, Zeus.Locked *&gt;\n(* If yo&quot;
 &amp; &quot;u get either of these errors, contact a Zeus implementor. *)\n\nTYPE\n#&quot;
 &amp; &quot;{\n  #(_EVENT_)Args = BRANDED REF RECORD\n#{\n    #(_ARGNAME_): #(_ARGT&quot;
 &amp; &quot;YPE_);\n#}\n  END;\n\n#}\n\n(*  Zeus calls the following to invoke vbt &quot;
 &amp; &quot;v\'s event handler: *)\n\n&lt;*NOWARN*&gt; PROCEDURE OEDispatcher(v: ZeusClas&quot;
 &amp; &quot;s.T; evt: REFANY) RAISES {Thread.Alerted} =\n  &lt;* LL &lt;= VBT.mu *&gt;\n  (*&quot;
 &amp; &quot; LL = {} if event style is output, LL = VBT.mu if event style is update&quot;
 &amp; &quot;. *)\n  BEGIN\n    TYPECASE v OF\n    | #(_ALGNAME_)ViewClass.T (view) &quot;
 &amp; &quot;=&gt; &lt;*NOWARN*&gt;\n      TYPECASE evt OF\n#{_OUTPUT\n      | #(_EVENT_)Args&quot;
 &amp; &quot;(var#(_EVENT_)Args) =&gt; &lt;*NOWARN*&gt;\n          view.oe#(_EVENT_) (\n#{\n &quot;
 &amp; &quot;             var#(_EVENT_)Args.#(_ARGNAME_)\n#|\n                ,\n#}\n&quot;
 &amp; &quot;              )\n#}\n#{_UPDATE\n      | #(_EVENT_)Args(var#(_EVENT_)Arg&quot;
 &amp; &quot;s) =&gt; &lt;*NOWARN*&gt;\n          view.ue#(_EVENT_) (\n#{\n              var#&quot;
 &amp; &quot;(_EVENT_)Args.#(_ARGNAME_)\n#|\n                ,\n#}\n              )\n&quot;
 &amp; &quot;#}\n      ELSE &lt;* ASSERT FALSE *&gt;\n      END;\n    ELSE (* this view is&quot;
 &amp; &quot;n\'t a #(_ALGNAME_)ViewClass, so just ignore *)\n    END\n  END OEDispa&quot;
 &amp; &quot;tcher;\n\n&lt;*NOWARN*&gt; PROCEDURE FEDispatcher(v: ZeusClass.T; evt: REFANY&quot;
 &amp; &quot;) =\n  &lt;* LL = VB&quot;;

CONST E9_0 =
   &quot;T.mu *&gt;\n  BEGIN\n    TYPECASE v OF\n    | #(_ALGNAME_)AlgClass.T (alg)&quot;
 &amp; &quot; =&gt; &lt;*NOWARN*&gt;\n      TYPECASE evt OF\n#{_FEEDBACK\n      | #(_EVENT_)A&quot;
 &amp; &quot;rgs(var#(_EVENT_)Args) =&gt; &lt;*NOWARN*&gt;\n          alg.fe#(_EVENT_) (\n#{\n&quot;
 &amp; &quot;              var#(_EVENT_)Args.#(_ARGNAME_)\n#|\n                ,\n#}&quot;
 &amp; &quot;\n              )\n#}\n      ELSE &lt;* ASSERT FALSE *&gt;\n      END;\n    E&quot;
 &amp; &quot;LSE (* this alg isn\'t a #(_ALGNAME_)AlgClass, so just ignore *)\n    E&quot;
 &amp; &quot;ND\n  END FEDispatcher;\n\n\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (\n      i&quot;
 &amp; &quot;nitiator: Algorithm.T; \n      #(_ARGSTR_) \n    ) RAISES {Thread.Alert&quot;
 &amp; &quot;ed} =\n  &lt;* LL = {} *&gt;\n  VAR zumeArgRec := NEW(#(_EVENT_)Args \n#{\n  &quot;
 &amp; &quot;             , #(_ARGNAME_) := #(_ARGNAME_)\n#}\n      );\n      alg :=&quot;
 &amp; &quot; NARROW(initiator, #(_ALGNAME_)AlgClass.T);\n  BEGIN\n    LOCK alg.evtM&quot;
 &amp; &quot;u DO\n      INC(alg.eventDataRec.ctOf#(_EVENT_));\n      alg.stopAtEven&quot;
 &amp; &quot;t := alg.eventDataRec.stopAt#(_EVENT_);\n      alg.waitAtEvent := alg.e&quot;
 &amp; &quot;ventDataRec.waitAt#(_EVENT_);\n      Zeus.Dispatch(initiator, Zeus.Even&quot;
 &amp; &quot;tStyle.Output, #(_EVENTPRIO_),\n                    \&quot;#(_EVENT_)\&quot;, OED&quot;
 &amp; &quot;ispatcher, zumeArgRec);\n    END;\n  END #(_EVENT_);\n\n#}\n#{_UPDATE\n&quot;
 &amp; &quot;PROCEDURE #(_EVENT_) (\n      initiator: Algorithm.T; \n      #(_ARGSTR&quot;
 &amp; &quot;_) \n    ) RAISES {Thread.Alerted} =\n  &lt;* LL = VBT.mu *&gt;\n  VAR zumeAr&quot;
 &amp; &quot;gRec := NEW(#(_EVENT_)Args \n#{\n               , #(_ARGNAME_) := #(_AR&quot;
 &amp; &quot;GNAME_)\n#}\n      );\n  BEGIN\n    Zeus.Dispatch(initiator, Zeus.Event&quot;
 &amp; &quot;Style.Update, #(_EVENTPRIO_), \n                  \&quot;#(_EVENT_)\&quot;, OEDis&quot;
 &amp; &quot;patcher, zumeArgRec);\n  END #(_EVENT_);\n\n#}\n\n#{_FEEDBACK\nPROCEDUR&quot;
 &amp; &quot;E #(_EVENT_) (\n      initiator: View.T; \n      #(_ARGSTR_) \n    ) RA&quot;
 &amp; &quot;ISES {Thread.Alerted} =\n  &lt;* LL = VBT.mu *&gt;\n  VAR zumeArgRec := NEW(#&quot;
 &amp; &quot;(_EVENT_)Args \n#{\n               , #(_ARGNAME_) := #(_ARGNAME_)\n#}\n&quot;
 &amp; &quot;      );\n  BEGIN\n    Zeus.Dispatch(initiator, Zeus.EventStyle.Notify,&quot;
 &amp; &quot; #(_EVENTPRIO_), \n                  \&quot;#(_EVENT_)\&quot;, FEDispatcher, zume&quot;
 &amp; &quot;ArgRec);\n  END #(_EVENT_);\n\n#}\n\nBEGIN\nEND #(_ALGNAME_)IE.\n&quot;;

CONST E10 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Fri Sep &quot;
 &amp; &quot; 8 15:48:12 PDT 1995 by najork  *)\n(*      modified on Thu Feb  9 08:5&quot;
 &amp; &quot;4:15 PST 1995 by kalsow  *)\n(* Last modified on Fri Dec  9 15:00:46 PS&quot;
 &amp; &quot;T 1994 by mhb     *)\n(*      modified on Sat Jun  4 16:24:49 1994 by h&quot;
 &amp; &quot;eydon      *)\n(*      modified on Tue Feb 16 16:31:40 PST 1993 by john&quot;
 &amp; &quot;h   *)\n\n(************************************************************&quot;
 &amp; &quot;*********\n|*  NOTE: This file is generated automatically from the even&quot;
 &amp; &quot;t \n|*        definition file #(_ALGNAME_).evt.\n|*********************&quot;
 &amp; &quot;************************************************)\n\n&lt;* PRAGMA LL *&gt;\n\n&quot;
 &amp; &quot;MODULE #(_ALGNAME_)#(_VIEWNAME_)ObliqView;\n\n$Filter\n$Fmt\n$Obliq\n$O&quot;
 &amp; &quot;bliqParser\n$ObLibAnim\n$ObLibM3\n$ObLibUI\n$ObValue\n$Rd\n$Rsrc\n$SynW&quot;
 &amp; &quot;r\n$TextRd\n$TextWr\n$Thread\n$VBT\n$View\n$ZeusPanel\n$ZFmt\n$#(_ALGNA&quot;
 &amp; &quot;ME_)ViewClass\n#(_IMPORTS_)\n\nCONST \n  ViewName =  \&quot;#(_VIEWNAME_).ob&quot;
 &amp; &quot;l\&quot;;\n\nTYPE\n  T = #(_ALGNAME_)ViewClass.T BRANDED OBJECT\n        obj&quot;
 &amp; &quot;ect  : Obliq.Val;\n        env     : Obliq.Env;\n        wr      : Text&quot;
 &amp; &quot;Wr.T;\n        swr     : SynWr.T;\n        parser  : ObliqParser.T;\n  &quot;
 &amp; &quot;    OVERRIDES\n        &lt;* LL.sup &lt; VBT.mu *&gt;\n        startrun := Start&quot;
 &amp; &quot;run;\n        &lt;* LL.sup &lt; VBT.mu *&gt;\n#{_OUTPUT\n        oe#(_EVENT_) :=&quot;
 &amp; &quot; #(_EVENT_);\n#}\n        &lt;* LL.sup = VBT.mu *&gt;\n#{_UPDATE\n        ue#&quot;
 &amp; &quot;(_EVENT_) := #(_EVENT_);\n#}\n      END;\n\n(* OUTPUT and UPDATE event &quot;
 &amp; &quot;handling methods: *)\n\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (view: T; #(_AR&quot;
 &amp; &quot;GSTR_)) =\n  &lt;* LL.sup &lt; VBT.mu *&gt;\n  BEGIN \n    IF FieldDefined(view.&quot;
 &amp; &quot;object, \&quot;#(_EVENT_)\&quot;) THEN\n      Invoke (view, \&quot;#(_EVENT_)\&quot;, \&quot;\&quot;\n&quot;
 &amp; &quot;#{\n      &amp; #(_ARGFMT_)(#(_ARGNAME_))\n#|\n      &amp; \&quot;,\&quot;\n#}\n      )\n&quot;
 &amp; &quot;    END\n  END #(_EVENT_);\n#}\n\n#{_UPDATE\nPROCEDURE #(_EVENT_) (view&quot;
 &amp; &quot;: T; #(_ARGSTR_)) =\n  &lt;* LL = VBT.mu *&gt;\n  BEGIN \n    IF FieldDefined&quot;
 &amp; &quot;(view.object, \&quot;#(_EVENT_)\&quot;) THEN\n &quot;;

CONST E10_0 =
   &quot;     Invoke (view, \&quot;#(_EVENT_)\&quot;, \&quot;\&quot;\n#{\n      &amp; #(_ARGFMT_)(#(_ARG&quot;
 &amp; &quot;NAME_))\n#|\n      &amp; \&quot;,\&quot;\n#}\n      )\n    END\n  END #(_EVENT_);\n#}&quot;
 &amp; &quot;\n\nPROCEDURE RegisterView () =\n  BEGIN \n    ZeusPanel.RegisterView(N&quot;
 &amp; &quot;ew, \&quot;#(_VIEWNAME_).obl\&quot;, \&quot;#(_ALGNAME_)\&quot;)   \n  END RegisterView;\n\n&quot;
 &amp; &quot;PROCEDURE New (): View.T =\n  BEGIN\n    RETURN NEW(T).init(NIL)\n  END&quot;
 &amp; &quot; New;\n\nCONST \n  ObliqStackSizeMultiplier = 8;\n\nTYPE\n  Closure = T&quot;
 &amp; &quot;hread.SizedClosure OBJECT\n              view: T;\n            OVERRIDE&quot;
 &amp; &quot;S\n              apply := ForkedStartrun;\n            END;\n\nPROCEDUR&quot;
 &amp; &quot;E Startrun (view: T) =\n  &lt;* LL.sup &lt; VBT.mu *&gt;\n  BEGIN\n    EVAL\n   &quot;
 &amp; &quot;   Thread.Join(\n        Thread.Fork(\n          NEW(Closure, view := v&quot;
 &amp; &quot;iew,\n              stackSize := ObliqStackSizeMultiplier * Thread.GetD&quot;
 &amp; &quot;efaultStackSize())));\n  END Startrun;\n\nPROCEDURE ForkedStartrun (cl:&quot;
 &amp; &quot; Closure): REFANY =\n  VAR rd: Rd.T; view := cl.view;\n  BEGIN\n    IF &quot;
 &amp; &quot;view.parser = NIL THEN\n      view.wr := TextWr.New();\n      view.swr &quot;
 &amp; &quot;:= SynWr.New(view.wr);\n      view.parser := ObliqParser.New(view.swr);&quot;
 &amp; &quot;\n    END;\n    view.object := NIL;\n    TRY\n      rd := Rsrc.Open(Vie&quot;
 &amp; &quot;wName, ZeusPanel.GetPath());\n      view.env := ParseRd(view.parser, Vi&quot;
 &amp; &quot;ewName, rd);\n      WITH obj = Obliq.Lookup(\&quot;view\&quot;, view.env) DO\n   &quot;
 &amp; &quot;     IF NOT ISTYPE(obj, ObValue.ValObj) THEN\n          ZeusPanel.Repor&quot;
 &amp; &quot;tError(\n            \&quot;not an Obliq object in \'\&quot; &amp; ViewName &amp; \&quot;\'\&quot;)&quot;
 &amp; &quot;\n        ELSIF FieldDefined (obj, \&quot;graphvbt\&quot;) THEN\n          WITH g&quot;
 &amp; &quot;raphvbt =\n            NARROW(Obliq.ObjectSelect(obj, \&quot;graphvbt\&quot;),\n &quot;
 &amp; &quot;                  ObLibAnim.ValGraph).vbt DO\n            LOCK VBT.mu D&quot;
 &amp; &quot;O\n              EVAL Filter.Replace(view, graphvbt)\n            END\n&quot;
 &amp; &quot;          END;\n          view.object := obj;\n        ELSIF FieldDefin&quot;
 &amp; &quot;ed (obj, \&quot;rectsvbt\&quot;) THEN\n          WITH rectsvbt =\n            NAR&quot;
 &amp; &quot;ROW(Obliq.ObjectSelect(obj, \&quot;rectsvbt\&quot;),\n                   ObLibAni&quot;
 &amp; &quot;m.ValRects).vbt DO\n            LOCK VBT.mu DO\n              EVAL Filt&quot;
 &amp; &quot;er.Replace(view, rectsvbt)\n            END\n          END;\n          &quot;
 &amp; &quot;view.object := obj;\n        ELSIF FieldD&quot;;

CONST E10_1 =
   &quot;efined (obj, \&quot;formsvbt\&quot;) THEN\n          WITH formsvbt =\n           &quot;
 &amp; &quot; NARROW(Obliq.ObjectSelect(obj, \&quot;formsvbt\&quot;),\n                   ObLi&quot;
 &amp; &quot;bUI.ValForm).vbt DO\n            LOCK VBT.mu DO\n              EVAL Fil&quot;
 &amp; &quot;ter.Replace(view, formsvbt)\n            END\n          END;\n         &quot;
 &amp; &quot; view.object := obj;\n        ELSE\n          ZeusPanel.ReportError(\n &quot;
 &amp; &quot;           \&quot;cannot find \'graphvbt\', \'rectsvbt\', or \'formsvbt\' in&quot;
 &amp; &quot; \'\&quot; &amp; ViewName &amp; \&quot;\'\&quot;)\n        END\n      END\n    EXCEPT\n    | R&quot;
 &amp; &quot;src.NotFound =&gt;\n        ZeusPanel.ReportError(\&quot;cannot find \'\&quot; &amp; Vie&quot;
 &amp; &quot;wName &amp; \&quot;\'\&quot;)\n    | ObValue.Error (packet) =&gt; OblError(view, packet)&quot;
 &amp; &quot;\n    | ObValue.Exception (packet) =&gt; OblException(view, packet)\n    E&quot;
 &amp; &quot;ND;\n    RETURN NIL;\n  END ForkedStartrun;\n\nPROCEDURE ParseRd (p: Ob&quot;
 &amp; &quot;liqParser.T; name: TEXT; rd: Rd.T):\n  Obliq.Env RAISES {ObValue.Error,&quot;
 &amp; &quot; ObValue.Exception} =\n  VAR env := Obliq.EmptyEnv();\n  BEGIN\n    Obl&quot;
 &amp; &quot;iqParser.ReadFrom(p, name, rd, TRUE);\n    TRY\n      LOOP\n        EVA&quot;
 &amp; &quot;L ObliqParser.EvalPhrase(p, ObliqParser.ParsePhrase(p), env)\n      END&quot;
 &amp; &quot;\n    EXCEPT\n      ObliqParser.Eof =&gt; (* clean exit of loop *)\n    EN&quot;
 &amp; &quot;D;\n    RETURN env\n  END ParseRd;\n\nPROCEDURE Invoke (view: T; event,&quot;
 &amp; &quot; args: TEXT) =\n  VAR\n    exp    := \&quot;view.\&quot; &amp; event &amp; \&quot;(\&quot; &amp; args &amp;&quot;
 &amp; &quot; \&quot;);\&quot;;\n    name   := \&quot;Zeus Event &lt;\&quot; &amp; event &amp; \&quot;&gt;\&quot;;\n  BEGIN\n   &quot;
 &amp; &quot; ObliqParser.ReadFrom (view.parser, name, TextRd.New(exp), FALSE);\n   &quot;
 &amp; &quot; TRY\n      EVAL Obliq.EvalTerm(ObliqParser.ParseTerm(view.parser), vie&quot;
 &amp; &quot;w.env)\n    EXCEPT\n    | ObliqParser.Eof =&gt; &lt;* ASSERT FALSE *&gt;\n    | &quot;
 &amp; &quot;ObValue.Error (packet) =&gt; OblError(view, packet)\n    | ObValue.Excepti&quot;
 &amp; &quot;on (packet) =&gt; OblException(view, packet)\n    END\n  END Invoke;\n\nPR&quot;
 &amp; &quot;OCEDURE FieldDefined (object: Obliq.Val; event: TEXT): BOOLEAN =\n  BEG&quot;
 &amp; &quot;IN\n    TRY\n      RETURN object # NIL AND Obliq.ObjectHas(object, even&quot;
 &amp; &quot;t)\n    EXCEPT\n    | ObValue.Error =&gt;\n    | ObValue.Exception =&gt;\n   &quot;
 &amp; &quot; END;\n    RETURN FALSE\n  END FieldDefined;\n\nPROCEDURE OblError (vie&quot;
 &amp; &quot;w: T; packet: ObValue.ErrorPacket) =\n  BEGIN\n    Obliq.ReportError(vi&quot;
 &amp; &quot;ew.swr, packet);\n    ZeusPanel.ReportEr&quot;;

CONST E10_2 =
   &quot;ror(\n      \&quot;Obliq error: \&quot; &amp; TextWr.ToText(view.wr))\n  END OblError&quot;
 &amp; &quot;;\n\nPROCEDURE OblException (view: T; packet: ObValue.ExceptionPacket) &quot;
 &amp; &quot;=\n  BEGIN\n    Obliq.ReportException(view.swr, packet);\n    ZeusPanel&quot;
 &amp; &quot;.ReportError(\n      \&quot;Obliq exception: \&quot; &amp; TextWr.ToText(view.wr))\n &quot;
 &amp; &quot; END OblException;\n\nBEGIN\n  SynWr.Setup();\n  ObliqParser.PackageSet&quot;
 &amp; &quot;up();\n  ObLibM3.PackageSetup();\n  ObLibUI.PackageSetup();\n  ObLibAni&quot;
 &amp; &quot;m.PackageSetup();\n  RegisterView ();\nEND #(_ALGNAME_)#(_VIEWNAME_)Obl&quot;
 &amp; &quot;iqView.\n&quot;;

CONST E11 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:47:37 PST 1995 by kalsow  *)\n(* Last modified on Wed Feb 17 16:4&quot;
 &amp; &quot;4:58 PST 1993 by johnh   *)\n(*      modified on Tue Jun  9 00:35:07 19&quot;
 &amp; &quot;92 by mhb         *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\nINTE&quot;
 &amp; &quot;RFACE #(_ALGNAME_)AlgClass;\n\n$Algorithm\n$AlgorithmClass\n#(_IMPORTS_&quot;
 &amp; &quot;)\n\n&lt;* PRAGMA LL *&gt;\n\nTYPE\n  EventDataRec = RECORD\n#{_OUTPUT\n    s&quot;
 &amp; &quot;topAt#(_EVENT_): BOOLEAN := TRUE;\n    waitAt#(_EVENT_): CARDINAL := 1;&quot;
 &amp; &quot;\n    ctOf#(_EVENT_): CARDINAL := 0;\n#}\n  END;\n\n  T &lt;: Public;\n  P&quot;
 &amp; &quot;ublic = Algorithm.T OBJECT\n      eventDataRec: EventDataRec;\n#(_ALGDA&quot;
 &amp; &quot;TA_)\n      METHODS\n#{_FEEDBACK\n        fe#(_EVENT_) (#(_ARGSTR_));  &quot;
 &amp; &quot;  &lt;* LL = VBT.mu *&gt;\n#}\n      END;\n      \nREVEAL\n  Algorithm.T &lt;: A&quot;
 &amp; &quot;lgorithmClass.T;\n  \nEND #(_ALGNAME_)AlgClass.\n&quot;;

CONST E12 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:56:54 PST 1995 by kalsow  *)\n(*      modified on Sat Jun  4 16:2&quot;
 &amp; &quot;3:08 1994 by heydon      *)\n(*      modified on Wed Feb 17 17:04:32 PS&quot;
 &amp; &quot;T 1993 by johnh   *)\n(*      modified on Tue Jun  9 00:35:35 1992 by m&quot;
 &amp; &quot;hb         *)\n\n(*****************************************************&quot;
 &amp; &quot;****************\n|*  NOTE: This file is generated automatically from t&quot;
 &amp; &quot;he event \n|*        definition file #(_ALGNAME_).evt.\n|**************&quot;
 &amp; &quot;*******************************************************)\n\n&lt;* PRAGMA L&quot;
 &amp; &quot;L *&gt;\n\nMODULE #(_ALGNAME_)ViewClass;\n\n$ViewClass\n$ZeusClass\n$#(_AL&quot;
 &amp; &quot;GNAME_)AlgClass\n#(_IMPORTS_)\n\nREVEAL\n  T = Public BRANDED OBJECT\n &quot;
 &amp; &quot;     OVERRIDES\n        &lt;* LL.sup = VBT.mu *&gt;\n        isCompat := IsCo&quot;
 &amp; &quot;mpat;\n        &lt;* LL.sup &lt; VBT.mu *&gt;\n#{_OUTPUT\n        oe#(_EVENT_) :&quot;
 &amp; &quot;= #(_EVENT_);\n#}\n        &lt;* LL.sup = VBT.mu *&gt;\n#{_UPDATE\n        ue&quot;
 &amp; &quot;#(_EVENT_) := #(_EVENT_);\n#}\n      END;\n      \nPROCEDURE IsCompat(&lt;&quot;
 &amp; &quot;*UNUSED*&gt; v: T; alg: ZeusClass.T): BOOLEAN =\n  &lt;* LL.sup = VBT.mu *&gt;\n&quot;
 &amp; &quot;  BEGIN\n    RETURN ISTYPE(alg, #(_ALGNAME_)AlgClass.T)\n  END IsCompat&quot;
 &amp; &quot;;\n\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (view: T \n#{\n    ; &lt;*UNUSED*&gt; #(&quot;
 &amp; &quot;_ARGMODE_)#(_ARGNAME_): #(_ARGTYPE_)\n#}\n) =\n  &lt;* LL.sup &lt; VBT.mu *&gt;\n&quot;
 &amp; &quot;  BEGIN \n    view.evtHandled := FALSE;\n  END #(_EVENT_);\n#}\n\n#{_UP&quot;
 &amp; &quot;DATE\nPROCEDURE #(_EVENT_) (view: T \n#{\n    ; &lt;*UNUSED*&gt; #(_ARGMODE_)&quot;
 &amp; &quot;#(_ARGNAME_): #(_ARGTYPE_)\n#}\n) =\n  &lt;* LL.sup = VBT.mu *&gt;\n  BEGIN \n&quot;
 &amp; &quot;    view.evtHandled := FALSE;\n  END #(_EVENT_);\n#}\n\nBEGIN\nEND #(_A&quot;
 &amp; &quot;LGNAME_)ViewClass.\n&quot;;

CONST E13 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Wed Feb &quot;
 &amp; &quot; 8 15:29:45 PST 1995 by kalsow  *)\n(*      modified on Sat Jul 17 10:5&quot;
 &amp; &quot;5:43 PDT 1993 by mhb     *)\n(*      modified on Thu Jul 15 13:53:13 PD&quot;
 &amp; &quot;T 1993 by steveg  *)\n(*      modified on Wed Feb 17 16:47:18 PST 1993 &quot;
 &amp; &quot;by johnh   *)\n\n(*****************************************************&quot;
 &amp; &quot;****************\n|*  NOTE: This file is generated automatically from t&quot;
 &amp; &quot;he event \n|*        definition file #(_ALGNAME_).evt.\n|**************&quot;
 &amp; &quot;*******************************************************)\n\nINTERFACE #&quot;
 &amp; &quot;(_ALGNAME_)#(_VIEWNAME_)GEFView;\nEND #(_ALGNAME_)#(_VIEWNAME_)GEFView.&quot;
 &amp; &quot;\n\n&quot;;

CONST E14 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Wed Feb &quot;
 &amp; &quot; 8 15:33:55 PST 1995 by kalsow  *)\n(*      modified on Wed Jun  1 23:5&quot;
 &amp; &quot;8:34 PDT 1994 by mhb     *)\n\n(***************************************&quot;
 &amp; &quot;******************************\n|*  NOTE: This file is generated automa&quot;
 &amp; &quot;tically from the event \n|*        definition file #(_ALGNAME_).evt.\n|&quot;
 &amp; &quot;*********************************************************************)\n&quot;
 &amp; &quot;\nINTERFACE #(_ALGNAME_)#(_VIEWNAME_)JunoView;\nEND #(_ALGNAME_)#(_VIEW&quot;
 &amp; &quot;NAME_)JunoView.\n\n&quot;;

CONST E15 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Wed Feb &quot;
 &amp; &quot; 8 15:42:11 PST 1995 by kalsow  *)\n(*      modified on Wed Feb 17 16:4&quot;
 &amp; &quot;7:18 PST 1993 by johnh   *)\n(*      modified on Tue Jun  9 00:43:17 19&quot;
 &amp; &quot;92 by mhb         *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\n&lt;* P&quot;
 &amp; &quot;RAGMA LL *&gt;\n\nINTERFACE #(_ALGNAME_)TranscriptView;\n\nIMPORT #(_ALGNA&quot;
 &amp; &quot;ME_)ViewClass;\n\nTYPE\n  T &lt;: Public;\n  Public = #(_ALGNAME_)ViewClas&quot;
 &amp; &quot;s.T OBJECT\n      METHODS\n        &lt;* LL = VBT.mu *&gt;\n        init(): T&quot;
 &amp; &quot;;\n      END;\n\nEND #(_ALGNAME_)TranscriptView.\n&quot;;

CONST E16 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Mon Jul &quot;
 &amp; &quot;10 15:31:57 PDT 1995 by najork  *)\n(*      modified on Thu Feb  9 08:5&quot;
 &amp; &quot;3:09 PST 1995 by kalsow  *)\n(*      modified on Mon Jun  6 03:20:38 PD&quot;
 &amp; &quot;T 1994 by mhb     *)\n(*      modified on Sat Jun  4 16:22:04 1994 by h&quot;
 &amp; &quot;eydon      *)\n(*      modified on Tue Feb 16 16:31:40 PST 1993 by john&quot;
 &amp; &quot;h   *)\n\n(************************************************************&quot;
 &amp; &quot;*********\n|*  NOTE: This file is generated automatically from the even&quot;
 &amp; &quot;t \n|*        definition file #(_ALGNAME_).evt.\n|*********************&quot;
 &amp; &quot;************************************************)\n\n&lt;* PRAGMA LL *&gt;\n\n&quot;
 &amp; &quot;MODULE #(_ALGNAME_)#(_VIEWNAME_)Obliq3DView;\n\n$Fmt\n$ZFmt\n$Obliq\n$O&quot;
 &amp; &quot;bliqParser\n$ObLib3D\n$ObLibAnim\n$ObLibM3\n$ObLibUI\n$ObValue\n$ObView&quot;
 &amp; &quot;3D\n$ObZeus3D\n$Rd\n$Rsrc\n$SynWr\n$TextRd\n$TextWr\n$Thread\n$View\n$V&quot;
 &amp; &quot;iew3DProxy\n$ZeusPanel\n$SynLocation\n$SynParse\n$MetaParser\n$ObliqPri&quot;
 &amp; &quot;nter\n$ObLibOnline\n$#(_ALGNAME_)3DViewClass\n#(_IMPORTS_)\n\nCONST \n &quot;
 &amp; &quot; ViewName =  \&quot;#(_VIEWNAME_).obl\&quot;;\n\nTYPE\n  T = #(_ALGNAME_)3DViewCl&quot;
 &amp; &quot;ass.T BRANDED OBJECT\n        env     : Obliq.Env;\n        wr      : T&quot;
 &amp; &quot;extWr.T;\n        swr     : SynWr.T;\n        parser  : ObliqParser.T;\n&quot;
 &amp; &quot;      OVERRIDES\n        &lt;* LL.sup &lt; VBT.mu *&gt;\n        startrun := Sta&quot;
 &amp; &quot;rtrun;\n        &lt;* LL.sup &lt; VBT.mu *&gt;\n#{_OUTPUT\n        oe#(_EVENT_) &quot;
 &amp; &quot;:= #(_EVENT_);\n#}\n        &lt;* LL.sup = VBT.mu *&gt;\n#{_UPDATE\n        u&quot;
 &amp; &quot;e#(_EVENT_) := #(_EVENT_);\n#}\n      END;\n\n(* OUTPUT and UPDATE even&quot;
 &amp; &quot;t handling methods: *)\n\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (view: T; #(_&quot;
 &amp; &quot;ARGSTR_)) =\n  &lt;* LL.sup &lt; VBT.mu *&gt;\n  BEGIN \n      Invoke (view, \&quot;#&quot;
 &amp; &quot;(_EVENT_)\&quot;, \&quot;\&quot;\n#{\n      &amp; #(_ARGFMT_)(#(_ARGNAME_))\n#|\n      &amp; \&quot;&quot;
 &amp; &quot;,\&quot;\n#}\n      )\n  END #(_EVENT_);\n\n#}\n\n#{_UPDATE\nPROCEDURE #(_EV&quot;
 &amp; &quot;ENT_) (view: T; #(_ARGSTR_)) =\n  &lt;* LL.sup = VBT.mu *&gt;\n  BEGIN \n    &quot;
 &amp; &quot;  Invoke (view, \&quot;#(_EVENT_)\&quot;, \&quot;\&quot;\n#{\n&quot;;

CONST E16_0 =
   &quot;      &amp; #(_ARGFMT_)(#(_ARGNAME_))\n#|\n      &amp; \&quot;,\&quot;\n#}\n      )\n  EN&quot;
 &amp; &quot;D #(_EVENT_);\n#}\n\nTYPE \n  Closure = Thread.SizedClosure BRANDED OBJ&quot;
 &amp; &quot;ECT\n    view : T;\n  OVERRIDES\n    apply := Apply;\n  END;\n\n\nPROCE&quot;
 &amp; &quot;DURE Apply (self : Closure) : REFANY =\n\n  PROCEDURE ParseRd (p: Obliq&quot;
 &amp; &quot;Parser.T; name: TEXT; rd: Rd.T) : Obliq.Env \n      RAISES {ObValue.Err&quot;
 &amp; &quot;or, ObValue.Exception} =\n    VAR \n      env := Obliq.EmptyEnv ();\n  &quot;
 &amp; &quot;  BEGIN\n      ObliqParser.ReadFrom (p, name, rd, TRUE);\n      TRY\n  &quot;
 &amp; &quot;      LOOP\n          EVAL ObliqParser.EvalPhrase (p, ObliqParser.Parse&quot;
 &amp; &quot;Phrase (p), env)\n        END\n      EXCEPT\n        ObliqParser.Eof =&gt;&quot;
 &amp; &quot; (* clean exit of loop *)\n      END;\n      RETURN env\n    END ParseR&quot;
 &amp; &quot;d;\n\n  BEGIN\n    WITH view = self.view DO\n      (*** Parse the .obl &quot;
 &amp; &quot;file ***)\n      TRY\n        WITH rd = Rsrc.Open (ViewName, ZeusPanel.&quot;
 &amp; &quot;GetPath ()) DO\n          view.env := ParseRd (view.parser, ViewName, r&quot;
 &amp; &quot;d);\n        END;\n        WITH obj = Obliq.Lookup (\&quot;view\&quot;, view.env)&quot;
 &amp; &quot; DO\n          ObView3D.PairUp (view, obj);\n        END;\n      EXCEPT&quot;
 &amp; &quot;\n      | Rsrc.NotFound =&gt; \n        ZeusPanel.ReportError(\&quot;cannot fin&quot;
 &amp; &quot;d \'\&quot; &amp; ViewName &amp; \&quot;\'\&quot;);\n      | ObValue.Error (packet) =&gt; \n     &quot;
 &amp; &quot;   OblError(view, packet);\n      | ObValue.Exception (packet) =&gt; \n   &quot;
 &amp; &quot;     OblException(view, packet);\n      END;\n\n      RETURN NIL;\n    &quot;
 &amp; &quot;END;\n  END Apply;\n\n\nPROCEDURE New (): View.T =\n  VAR\n    view : T&quot;
 &amp; &quot;;\n  BEGIN\n    (*** Create a View3D.T ***)\n    view := NEW (T).init (&quot;
 &amp; &quot;\&quot;Obliq3D View\&quot;);\n\n    (*** Create a new Obliq parser ***)\n    view&quot;
 &amp; &quot;.wr     := TextWr.New ();\n    view.swr    := SynWr.New (view.wr);\n   &quot;
 &amp; &quot; view.parser := ObliqParser.New (view.swr);\n\n    (*** Load the .obl f&quot;
 &amp; &quot;ile ***)\n    WITH thread = Thread.Fork (NEW (Closure, view := view)) D&quot;
 &amp; &quot;O\n      EVAL Thread.Join (thread);\n    END;\n\n    (*** invoke the Ne&quot;
 &amp; &quot;w method of the Obliq object \&quot;view\&quot; ***)\n    Invoke (view, \&quot;New\&quot;, &quot;
 &amp; &quot;\&quot;\&quot;);\n\n    (*** Return the new view ***)\n    RETURN view;\n  END Ne&quot;
 &amp; &quot;w;\n\n\nPROCEDURE Startrun (view: T) =\n  &lt;* LL.sup &lt; VBT.mu *&gt;\n  BEGI&quot;
 &amp; &quot;N\n    (*** Reload the .obl file ***)\n    WIT&quot;;

CONST E16_1 =
   &quot;H thread = Thread.Fork (\n                      NEW (Closure,\n        &quot;
 &amp; &quot;                   stackSize := 2 * Thread.GetDefaultStackSize (),\n   &quot;
 &amp; &quot;                        view := view)) DO\n      EVAL Thread.Join (thre&quot;
 &amp; &quot;ad);\n    END;\n  END Startrun;\n\n\nPROCEDURE Invoke (view: T; event, &quot;
 &amp; &quot;args: TEXT) =\n  VAR\n    exp    := \&quot;view.\&quot; &amp; event &amp; \&quot;(\&quot; &amp; args &amp; &quot;
 &amp; &quot;\&quot;);\&quot;;\n    name   := \&quot;Zeus Event &lt;\&quot; &amp; event &amp; \&quot;&gt;\&quot;;\n    proxy  :=&quot;
 &amp; &quot; ObView3D.M3ToObliq (view);\n  BEGIN\n    TRY\n      IF proxy # NIL AND&quot;
 &amp; &quot; Obliq.ObjectHas (proxy, event) THEN\n        ObliqParser.ReadFrom (vie&quot;
 &amp; &quot;w.parser, name, TextRd.New(exp), FALSE);\n        EVAL Obliq.EvalTerm (&quot;
 &amp; &quot;ObliqParser.ParseTerm (view.parser), view.env);\n      END;\n    EXCEPT&quot;
 &amp; &quot;\n    | ObliqParser.Eof =&gt; &lt;* ASSERT FALSE *&gt;\n    | ObValue.Error (pac&quot;
 &amp; &quot;ket) =&gt; OblError(view, packet)\n    | ObValue.Exception (packet) =&gt; Obl&quot;
 &amp; &quot;Exception(view, packet)\n    END;\n  END Invoke;\n\n\nPROCEDURE OblErro&quot;
 &amp; &quot;r (view: T; packet: ObValue.ErrorPacket) =\n  BEGIN\n    Obliq.ReportEr&quot;
 &amp; &quot;ror(view.swr, packet);\n    ZeusPanel.ReportError(\&quot;Obliq error: \&quot; &amp; T&quot;
 &amp; &quot;extWr.ToText(view.wr))\n  END OblError;\n\n\nPROCEDURE OblException (vi&quot;
 &amp; &quot;ew: T; packet: ObValue.ExceptionPacket) =\n  BEGIN\n    Obliq.ReportExc&quot;
 &amp; &quot;eption(view.swr, packet);\n    ZeusPanel.ReportError(\n      \&quot;Obliq ex&quot;
 &amp; &quot;ception: \&quot; &amp; TextWr.ToText(view.wr))\n  END OblException;\n\n\nBEGIN\n&quot;
 &amp; &quot;  SynWr.Setup();\n  SynLocation.PackageSetup();\n  SynParse.PackageSetu&quot;
 &amp; &quot;p();\n  MetaParser.PackageSetup(); &lt;* NOWARN *&gt;\n  Obliq.PackageSetup()&quot;
 &amp; &quot;;\n  ObliqParser.PackageSetup();\n  ObliqPrinter.PackageSetup();\n  ObL&quot;
 &amp; &quot;ibOnline.Setup();             (* really needed! *)\n\n  ObLibM3.Package&quot;
 &amp; &quot;Setup();\n  ObLibUI.PackageSetup();\n  ObLibAnim.PackageSetup();\n  ObL&quot;
 &amp; &quot;ib3D.PackageSetup();\n  ObZeus3D.PackageSetup();\n\n  ZeusPanel.Registe&quot;
 &amp; &quot;rView (New, \n                          \&quot;#(_VIEWNAME_).obl\&quot;, \n      &quot;
 &amp; &quot;                    \&quot;#(_ALGNAME_)\&quot;, \n                          sampl&quot;
 &amp; &quot;e := NEW(T));\nEND #(_ALGNAME_)#(_VIEWNAME_)Obliq3DView.\n&quot;;

CONST E17 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Wed Feb &quot;
 &amp; &quot; 8 15:27:36 PST 1995 by kalsow  *)\n(*       modified on Mon Jul 12 22:&quot;
 &amp; &quot;36:53 PDT 1993 by mhb    *)\n\nINTERFACE #(_ALGNAME_)DataView;\n\nEND #&quot;
 &amp; &quot;(_ALGNAME_)DataView.\n&quot;;

CONST E18 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 09:00:07 PST 1995 by kalsow  *)\n(*      modified on Mon Nov 29 08:0&quot;
 &amp; &quot;7:34 PST 1993 by najork  *)\n(*      modified on Wed Feb 17 16:46:47 PS&quot;
 &amp; &quot;T 1993 by johnh   *)\n(*      modified on Tue Jun  9 00:41:25 1992 by m&quot;
 &amp; &quot;hb         *)\n\n(*****************************************************&quot;
 &amp; &quot;****************\n|*  NOTE: This file is generated automatically from t&quot;
 &amp; &quot;he event \n|*        definition file #(_ALGNAME_).evt.\n|**************&quot;
 &amp; &quot;*******************************************************)\n\n&lt;* PRAGMA L&quot;
 &amp; &quot;L *&gt;\n\nMODULE #(_ALGNAME_)IE;\n\n$Algorithm\n$AlgorithmClass\n$Thread\n&quot;
 &amp; &quot;$View\n$Zeus\n$ZeusClass\n$#(_ALGNAME_)AlgClass\n$#(_ALGNAME_)ViewClass&quot;
 &amp; &quot;\n$#(_ALGNAME_)3DViewClass\n#(_IMPORTS_)\n\n&lt;* FATAL Zeus.Error, Zeus.L&quot;
 &amp; &quot;ocked *&gt;\n(* If you get either of these errors, contact a Zeus implemen&quot;
 &amp; &quot;tor. *)\n\nTYPE\n#{\n  #(_EVENT_)Args = BRANDED REF RECORD\n#{\n    #(_&quot;
 &amp; &quot;ARGNAME_): #(_ARGTYPE_);\n#}\n  END;\n\n#}\n\n(*  Zeus calls the follow&quot;
 &amp; &quot;ing to invoke vbt v\'s event handler: *)\n\nPROCEDURE OEDispatcher(v: Z&quot;
 &amp; &quot;eusClass.T; evt: REFANY) RAISES {Thread.Alerted} =\n  &lt;* LL &lt;= VBT.mu *&quot;
 &amp; &quot;&gt;\n  (* LL = {} if event style is output, LL = VBT.mu if event style is&quot;
 &amp; &quot; update. *)\n  BEGIN\n    TYPECASE v OF\n    | #(_ALGNAME_)ViewClass.T &quot;
 &amp; &quot;(view) =&gt;\n      TYPECASE evt OF\n#{_OUTPUT\n      | #(_EVENT_)Args(var&quot;
 &amp; &quot;#(_EVENT_)Args) =&gt; \n          view.oe#(_EVENT_) (\n#{\n              v&quot;
 &amp; &quot;ar#(_EVENT_)Args.#(_ARGNAME_)\n#|\n                ,\n#}\n             &quot;
 &amp; &quot; )\n#}\n#{_UPDATE\n      | #(_EVENT_)Args(var#(_EVENT_)Args) =&gt; \n     &quot;
 &amp; &quot;     view.ue#(_EVENT_) (\n#{\n              var#(_EVENT_)Args.#(_ARGNAM&quot;
 &amp; &quot;E_)\n#|\n                ,\n#}\n              )\n#}\n      ELSE &lt;* ASSE&quot;
 &amp; &quot;RT FALSE *&gt;\n      END;\n    | #(_ALGNAME_)3DViewClass.T (view) =&gt;\n   &quot;
 &amp; &quot;   TYPECASE evt OF\n#{_OUTPUT\n      | #(_EVENT_)Args(var#(_EVENT_)Args&quot;
 &amp; &quot;) =&gt; \n          v&quot;;

CONST E18_0 =
   &quot;iew.oe#(_EVENT_) (\n#{\n              var#(_EVENT_)Args.#(_ARGNAME_)\n#&quot;
 &amp; &quot;|\n                ,\n#}\n              )\n#}\n#{_UPDATE\n      | #(_EV&quot;
 &amp; &quot;ENT_)Args(var#(_EVENT_)Args) =&gt; \n          view.ue#(_EVENT_) (\n#{\n  &quot;
 &amp; &quot;            var#(_EVENT_)Args.#(_ARGNAME_)\n#|\n                ,\n#}\n&quot;
 &amp; &quot;              )\n#}\n      ELSE &lt;* ASSERT FALSE *&gt;\n      END;\n    ELS&quot;
 &amp; &quot;E (* this view isn\'t a #(_ALGNAME_)3DViewClass or\n            a #(_AL&quot;
 &amp; &quot;GNAME_)3DViewClass, so just ignore *)\n    END\n  END OEDispatcher;\n\n&quot;
 &amp; &quot;PROCEDURE FEDispatcher(v: ZeusClass.T; evt: REFANY) =\n  &lt;* LL = VBT.mu&quot;
 &amp; &quot; *&gt;\n  BEGIN\n    TYPECASE v OF\n    | #(_ALGNAME_)AlgClass.T (alg) =&gt;\n&quot;
 &amp; &quot;      TYPECASE evt OF\n#{_FEEDBACK\n      | #(_EVENT_)Args(var#(_EVENT_&quot;
 &amp; &quot;)Args) =&gt; \n          alg.fe#(_EVENT_) (\n#{\n              var#(_EVENT&quot;
 &amp; &quot;_)Args.#(_ARGNAME_)\n#|\n                ,\n#}\n              )\n#}\n  &quot;
 &amp; &quot;    ELSE &lt;* ASSERT FALSE *&gt;\n      END;\n    ELSE (* this alg isn\'t a &quot;
 &amp; &quot;#(_ALGNAME_)AlgClass, so just ignore *)\n    END\n  END FEDispatcher;\n&quot;
 &amp; &quot;\n\n#{_OUTPUT\nPROCEDURE #(_EVENT_) (\n      initiator: Algorithm.T; \n&quot;
 &amp; &quot;      #(_ARGSTR_) \n    ) RAISES {Thread.Alerted} =\n  &lt;* LL = {} *&gt;\n &quot;
 &amp; &quot; VAR zumeArgRec := NEW(#(_EVENT_)Args \n#{\n               , #(_ARGNAME&quot;
 &amp; &quot;_) := #(_ARGNAME_)\n#}\n      );\n      alg := NARROW(initiator, #(_ALG&quot;
 &amp; &quot;NAME_)AlgClass.T);\n  BEGIN\n    LOCK alg.evtMu DO\n      INC(alg.event&quot;
 &amp; &quot;DataRec.ctOf#(_EVENT_));\n      alg.stopAtEvent := alg.eventDataRec.sto&quot;
 &amp; &quot;pAt#(_EVENT_);\n      alg.waitAtEvent := alg.eventDataRec.waitAt#(_EVEN&quot;
 &amp; &quot;T_);\n      Zeus.Dispatch(initiator, Zeus.EventStyle.Output, #(_EVENTPR&quot;
 &amp; &quot;IO_),\n                    \&quot;#(_EVENT_)\&quot;, OEDispatcher, zumeArgRec);\n&quot;
 &amp; &quot;    END;\n  END #(_EVENT_);\n\n#}\n#{_UPDATE\nPROCEDURE #(_EVENT_) (\n &quot;
 &amp; &quot;     initiator: Algorithm.T; \n      #(_ARGSTR_) \n    ) RAISES {Thread&quot;
 &amp; &quot;.Alerted} =\n  &lt;* LL = VBT.mu *&gt;\n  VAR zumeArgRec := NEW(#(_EVENT_)Arg&quot;
 &amp; &quot;s \n#{\n               , #(_ARGNAME_) := #(_ARGNAME_)\n#}\n      );\n  &quot;
 &amp; &quot;BEGIN\n    Zeus.Dispatch(initiator, Zeus.EventStyle.Update, #(_EVENTPRI&quot;
 &amp; &quot;O_), \n                  \&quot;#(_EVENT_)\&quot;, OEDispatcher, zumeArgRec);\n  &quot;
 &amp; &quot;END #(_EVENT_);\n\n#}\n\n#{_FEEDBAC&quot;;

CONST E18_1 =
   &quot;K\nPROCEDURE #(_EVENT_) (\n      initiator: View.T; \n      #(_ARGSTR_)&quot;
 &amp; &quot; \n    ) RAISES {Thread.Alerted} =\n  &lt;* LL = VBT.mu *&gt;\n  VAR zumeArgR&quot;
 &amp; &quot;ec := NEW(#(_EVENT_)Args \n#{\n               , #(_ARGNAME_) := #(_ARGN&quot;
 &amp; &quot;AME_)\n#}\n      );\n  BEGIN\n    Zeus.Dispatch(initiator, Zeus.EventSt&quot;
 &amp; &quot;yle.Notify, #(_EVENTPRIO_), \n                  \&quot;#(_EVENT_)\&quot;, FEDispa&quot;
 &amp; &quot;tcher, zumeArgRec);\n  END #(_EVENT_);\n\n#}\n\nBEGIN\nEND #(_ALGNAME_)&quot;
 &amp; &quot;IE.\n&quot;;

CONST E19 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:50:12 PST 1995 by kalsow  *)\n(*      modified on Sun Jun  5 21:5&quot;
 &amp; &quot;8:07 PDT 1994 by mhb     *)\n(*      modified on Wed Feb 17 16:46:35 PS&quot;
 &amp; &quot;T 1993 by johnh   *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\n&lt;* P&quot;
 &amp; &quot;RAGMA LL *&gt;\n\nINTERFACE #(_ALGNAME_)IE;\n\n$Algorithm\n$Thread\n$View\n&quot;
 &amp; &quot;#(_IMPORTS_)\n\n\n(* call the following to generate an event: *)\n\n#{_&quot;
 &amp; &quot;OUTPUT\nPROCEDURE #(_EVENT_) (\n      initiator: Algorithm.T; \n      #&quot;
 &amp; &quot;(_ARGSTR_) \n    ) RAISES {Thread.Alerted};\n    &lt;* LL = {} *&gt;\n\n#}\n#&quot;
 &amp; &quot;{_FEEDBACK\nPROCEDURE #(_EVENT_) (\n      initiator: View.T; \n      #(&quot;
 &amp; &quot;_ARGSTR_) \n    ) RAISES {Thread.Alerted};\n    &lt;* LL = VBT.mu *&gt;\n\n#}&quot;
 &amp; &quot;\n#{_UPDATE\nPROCEDURE #(_EVENT_) (\n      initiator: Algorithm.T; \n  &quot;
 &amp; &quot;    #(_ARGSTR_) \n    ) RAISES {Thread.Alerted};\n    &lt;* LL = VBT.mu *&gt;&quot;
 &amp; &quot;\n\n#}\n\nEND #(_ALGNAME_)IE.\n&quot;;

CONST E20 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Wed Feb &quot;
 &amp; &quot; 8 15:36:04 PST 1995 by kalsow  *)\n(*      modified on Sat Jul 17 10:5&quot;
 &amp; &quot;5:21 PDT 1993 by mhb     *)\n(*      modified on Wed Feb 17 16:47:18 PS&quot;
 &amp; &quot;T 1993 by johnh   *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\nINTE&quot;
 &amp; &quot;RFACE #(_ALGNAME_)#(_VIEWNAME_)ObliqView;\nEND #(_ALGNAME_)#(_VIEWNAME_&quot;
 &amp; &quot;)ObliqView.\n\n&quot;;

CONST E21 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:56:28 PST 1995 by kalsow  *)\n(*      modified on Wed Feb 17 17:0&quot;
 &amp; &quot;4:21 PST 1993 by johnh   *)\n(*      modified on Tue Jun  9 00:35:21 19&quot;
 &amp; &quot;92 by mhb         *)\n\n(**********************************************&quot;
 &amp; &quot;***********************\n|*  NOTE: This file is generated automatically&quot;
 &amp; &quot; from the event \n|*        definition file #(_ALGNAME_).evt.\n|*******&quot;
 &amp; &quot;**************************************************************)\n\n&lt;* P&quot;
 &amp; &quot;RAGMA LL *&gt;\n\nINTERFACE #(_ALGNAME_)ViewClass;\n\n$Thread\n$View\n#(_I&quot;
 &amp; &quot;MPORTS_)\n\nTYPE\n  T &lt;: Public;\n  Public = View.T OBJECT\n      METHO&quot;
 &amp; &quot;DS\n      &lt;*LL = {} *&gt;\n#{_OUTPUT\n        oe#(_EVENT_) (#(_ARGSTR_)) R&quot;
 &amp; &quot;AISES {Thread.Alerted};\n#}\n      &lt;*LL = VBT.mu *&gt;\n#{_UPDATE\n       &quot;
 &amp; &quot; ue#(_EVENT_) (#(_ARGSTR_)) RAISES {Thread.Alerted};\n#}\n      END;\n &quot;
 &amp; &quot;     \nEND #(_ALGNAME_)ViewClass.\n&quot;;

CONST E22 =
   &quot;; Copyright (C) 1995, Digital Equipment Corporation.\n; All rights rese&quot;
 &amp; &quot;rved.\n; See the file COPYRIGHT for a full description.\n;\n; Last modi&quot;
 &amp; &quot;fied on Wed Feb  8 15:29:09 PST 1995 by kalsow\n\n;********************&quot;
 &amp; &quot;************************************************\n;  NOTE: This file is&quot;
 &amp; &quot; generated automatically from the event \n;        definition file #(_A&quot;
 &amp; &quot;LGNAME_).evt.\n;*******************************************************&quot;
 &amp; &quot;*************\n\n(VBox\n  (Border (Pen 1)\n    (Shape\n      (Height 75&quot;
 &amp; &quot; - 25 + Inf)\n      (Viewport\n        (HBox\n          (Glue 4 + Inf)\n&quot;
 &amp; &quot;          (VBox\n            (Glue 6)\n            (Shape (Height 16 + &quot;
 &amp; &quot;0)\n              (HBox Fill (Shape (Width + 0) (Height + 0) \n        &quot;
 &amp; &quot;                        \&quot;Code View events:   Stop? \&quot;) \n             &quot;
 &amp; &quot;       (Boolean %stopatCodeEvents =TRUE \&quot;\&quot;)\n                    (Glu&quot;
 &amp; &quot;e 10)\n                    (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;&quot;
 &amp; &quot;)\n                    (Shape (Width 80) (Numeric %waitatCodeEvents =1 &quot;
 &amp; &quot;\n                                               (Min 0) (Max 100)))))\n&quot;
 &amp; &quot;            (Glue 6)\n#{_OUTPUT\n            (Shape (Height 16 + 0)\n  &quot;
 &amp; &quot;            (HBox Fill (Shape (Width + 0) (Height + 0) \n              &quot;
 &amp; &quot;                  \&quot;#(_EVENT_):   Stop? \&quot;) \n                    (Bool&quot;
 &amp; &quot;ean %stopAt#(_EVENT_) =TRUE \&quot;\&quot;)\n                    (Glue 10)\n     &quot;
 &amp; &quot;               (Shape (Width + 0) (Height + 0) \&quot;Weight: \&quot;)\n         &quot;
 &amp; &quot;           (Shape (Width 80) (Numeric %waitAt#(_EVENT_) =1 \n          &quot;
 &amp; &quot;                                     (Min 0) (Max 100)))))\n           &quot;
 &amp; &quot; (Glue 6)\n#}\n          )\n          (Glue 4)\n          (VBox\n      &quot;
 &amp; &quot;      (Glue 5)\n            (Shape (Width + 0) (Height 16 + 0) \&quot;Cts:\&quot;&quot;
 &amp; &quot;)\n            (Button %eventCounts\n              (VBox\n#{_OUTPUT\n  &quot;
 &amp; &quot;              (Glue 6)\n                (HBox Fill (Shape (Width + 0) (&quot;
 &amp; &quot;Height 16 + 0) \n                                  (Text %ctOf#(_EVENT_&quot;
 &amp; &quot;) \&quot;0\&quot;)))\n#}\n                (Glue 3))))\n          Fill\n          &quot;
 &amp; &quot;(Glue 4 + Inf)\n        )\n      )\n    )\n  )\n)\n&quot;;

CONST E23 =
   &quot;(* Copyright (C) 1995, Digital Equipment Corporation.       *)\n(* All &quot;
 &amp; &quot;rights reserved.                                     *)\n(* See the fil&quot;
 &amp; &quot;e COPYRIGHT for a full description.           *)\n(*                   &quot;
 &amp; &quot;                                       *)\n(* Last modified on Thu Feb &quot;
 &amp; &quot; 9 08:57:32 PST 1995 by kalsow  *)\n(*      modified on Sun Nov 28 23:0&quot;
 &amp; &quot;8:58 PST 1993 by najork  *)\n\n(***************************************&quot;
 &amp; &quot;******************************\n|*  NOTE: This file is generated automa&quot;
 &amp; &quot;tically from the event \n|*        definition file #(_ALGNAME_).evt.\n|&quot;
 &amp; &quot;*********************************************************************)\n&quot;
 &amp; &quot;\n&lt;* PRAGMA LL *&gt;\n\nMODULE #(_ALGNAME_)3DViewClass;\n\n$View3D\n$ViewC&quot;
 &amp; &quot;lass\n$ZeusClass\n$#(_ALGNAME_)AlgClass\n#(_IMPORTS_)\n\nREVEAL\n  T = &quot;
 &amp; &quot;Public BRANDED OBJECT\n      OVERRIDES\n       isCompat := IsCompat;\n &quot;
 &amp; &quot;     &lt;*LL = {} *&gt;\n#{_OUTPUT\n        oe#(_EVENT_) := #(_EVENT_);\n#}\n&quot;
 &amp; &quot;      &lt;*LL = VBT.mu *&gt;\n#{_UPDATE\n        ue#(_EVENT_) := #(_EVENT_);\n&quot;
 &amp; &quot;#}\n      END;\n      \nPROCEDURE IsCompat (v: T; alg: ZeusClass.T): BO&quot;
 &amp; &quot;OLEAN =\n  BEGIN\n    RETURN ISTYPE(alg, #(_ALGNAME_)AlgClass.T) AND Vi&quot;
 &amp; &quot;ew3D.T.isCompat (v, alg);\n  END IsCompat;\n\n#{_OUTPUT\nPROCEDURE #(_E&quot;
 &amp; &quot;VENT_) (view: T \n#{\n    ; &lt;*UNUSED*&gt; #(_ARGMODE_)#(_ARGNAME_): #(_ARG&quot;
 &amp; &quot;TYPE_)\n#}\n) =\n  &lt;*LL = {} *&gt;\n  BEGIN \n    view.evtHandled := FALSE&quot;
 &amp; &quot;;\n  END #(_EVENT_);\n\n#}\n\n#{_UPDATE\nPROCEDURE #(_EVENT_) (view: T &quot;
 &amp; &quot;\n#{\n    ; &lt;*UNUSED*&gt; #(_ARGMODE_)#(_ARGNAME_): #(_ARGTYPE_)\n#}\n) =\n&quot;
 &amp; &quot;  &lt;*LL = VBT.mu *&gt;\n  BEGIN \n    view.evtHandled := FALSE;\n  END #(_E&quot;
 &amp; &quot;VENT_);\n\n#}\n\nBEGIN\nEND #(_ALGNAME_)3DViewClass.\n&quot;;

BEGIN
END ZoomBundle.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
