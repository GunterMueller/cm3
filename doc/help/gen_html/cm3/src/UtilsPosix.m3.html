<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: cm3/src/UtilsPosix.m3</TITLE>
</HEAD>
<BODY bgcolor="#eeeeee">
<A NAME="0TOP0">
<H2>cm3/src/UtilsPosix.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1996-2000 Critical Mass, Inc. All rights reserved.    
 See file COPYRIGHT-CMASS for details. 

<P><PRE>UNSAFE MODULE <module>UtilsPosix</module> EXPORTS <A HREF="Utils.i3.html"><implements>Utils</A></implements>;

IMPORT <A HREF="../../m3core/src/C/Common/Ctypes.i3.html">Ctypes</A>, <A HREF="../../m3core/src/unix/linux-libc6/Unix.i3.html">Unix</A>, <A HREF="../../m3core/src/C/Common/M3toC.i3.html">M3toC</A>, <A HREF="#x1">Msg</A>, <A HREF="../../libm3/src/os/Common/Pathname.i3.html">Pathname</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>;

PROCEDURE <A NAME="LinkFile"><procedure>LinkFile</procedure></A> (from, to: TEXT) =
  VAR s_from, s_to: Ctypes.char_star;
  BEGIN
    Remove (to);
    MakeRelative (from, to);
    Msg.Commands (&quot;link -s &quot;, from, &quot; &quot;, to);
    s_from := M3toC.SharedTtoS (from);
    s_to   := M3toC.SharedTtoS (to);
    EVAL Unix.symlink (s_from, s_to);
    M3toC.FreeSharedS (from, s_from);
    M3toC.FreeSharedS (to, s_to);
  END LinkFile;

PROCEDURE <A NAME="MakeRelative"><procedure>MakeRelative</procedure></A> (VAR from: TEXT;  to: TEXT) =
  VAR
    from_arcs, to_arcs: Pathname.Arcs;
    from_len, to_len  : INTEGER;
    from_x, to_x      : TEXT;
    common            : INTEGER;
    new_arcs          : Pathname.Arcs;
  BEGIN
    IF NOT Pathname.Absolute (from) OR NOT Pathname.Absolute (to) THEN
      RETURN;  (* bail out *)
    END;

    TRY
      from_arcs := Pathname.Decompose (from);
      to_arcs   := Pathname.Decompose (to);
    EXCEPT Pathname.Invalid =&gt;
      RETURN;  (* bail out *)
    END;

    from_len := from_arcs.size ();
    to_len := to_arcs.size ();
    common := 0;
    WHILE (common &lt; from_len-1) AND (common &lt; to_len-1) DO
      from_x := from_arcs.get (common);
      to_x := to_arcs.get (common);
      IF    (from_x = NIL) AND (to_x = NIL) THEN  (* they're common *)
      ELSIF (from_x = NIL) OR  (to_x = NIL) THEN  EXIT;  (* they're different *)
      ELSIF NOT Text.Equal (from_x, to_x)   THEN  EXIT;  (* they're different *)
      END;
      INC (common);
    END;
    IF (common &lt;= 0) THEN RETURN END;

    new_arcs := NEW (Pathname.Arcs).init (from_len);
    new_arcs.addhi (NIL); (* make a relative path *)
    FOR i := common TO to_len-2   DO new_arcs.addhi (Pathname.Parent);   END;
    FOR i := common TO from_len-1 DO new_arcs.addhi (from_arcs.get (i)); END;

    TRY
      from_x := Pathname.Compose (new_arcs);
    EXCEPT Pathname.Invalid =&gt;
      RETURN; (* bail out *)
    END;

    Msg.Verbose (&quot;\nREWRITE: &quot;,  from,    &quot; -&gt; &quot;,  to,
                 &quot;\n         &quot; &amp; from_x &amp; &quot; -&gt; &quot; &amp; to);
    from := from_x;
  END MakeRelative;

BEGIN
END UtilsPosix.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Msg is in:
</A><UL>
<LI><A HREF="Msg.i3.html#0TOP0">cm3/src/Msg.i3</A>
<LI><A HREF="../../m3tohtml/src/Msg.i3.html#0TOP0">m3tohtml/src/Msg.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
