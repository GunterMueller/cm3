<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: cm3/src/Makefile.m3</TITLE>
</HEAD>
<BODY bgcolor="#eeeeee">
<A NAME="0TOP0">
<H2>cm3/src/Makefile.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright 1996 Critical Mass, Inc. All rights reserved.    

<P><PRE>MODULE <module><implements><A HREF="Makefile.i3.html">Makefile</A></implements></module>;

IMPORT <A HREF="../../libm3/src/os/Common/FS.i3.html">FS</A>, <A HREF="../../m3middle/src/M3File.i3.html">M3File</A>, <A HREF="../../m3middle/src/M3Timers.i3.html">M3Timers</A>, <A HREF="../../libm3/src/os/Common/OSError.i3.html">OSError</A>, <A HREF="../../libm3/src/params/Params.i3.html">Params</A>, <A HREF="../../libm3/src/os/Common/Process.i3.html">Process</A>, <A HREF="../../m3core/src/text/Text.i3.html">Text</A>, <A HREF="../../m3core/src/thread/Common/Thread.i3.html">Thread</A>, <A HREF="../../libm3/src/rw/Wr.i3.html">Wr</A>;
IMPORT <A HREF="Arg.i3.html">Arg</A>, <A HREF="M3Options.i3.html">M3Options</A>, <A HREF="M3Path.i3.html">M3Path</A>, <A HREF="#x1">Msg</A>, <A HREF="Utils.i3.html">Utils</A>;
IMPORT <A HREF="../../m3quake/src/MxConfig.i3.html">MxConfig</A> AS M3Config;

TYPE
  NK = M3Path.Kind;
  MM = M3Options.Mode;

CONST
  ModeName = ARRAY MM OF TEXT { &quot;-build&quot;, &quot;-clean&quot;, &quot;-ship&quot;, &quot;-find&quot; };
  ModeFlag = ARRAY MM OF TEXT { &quot;_all&quot;,   &quot;_clean&quot;, &quot;_ship&quot;, &quot;_find&quot; };

TYPE
  State = RECORD
    args          : Arg.List := NIL;
    wr            : Wr.T     := NIL;
    keep_files    : BOOLEAN  := FALSE;
    use_overrides : BOOLEAN  := FALSE;
    mode_set      : BOOLEAN  := FALSE;
    found_work    : BOOLEAN  := FALSE;
  END;

PROCEDURE <A NAME="Build"><procedure>Build</procedure></A> (src_dir: TEXT): TEXT =
  CONST Makefile = &quot;m3make.args&quot;;
  VAR
    s: State;
    src_makefile := M3Path.New (src_dir, &quot;m3makefile&quot;);
    src_overrides := M3Path.New (src_dir, &quot;m3overrides&quot;);

  PROCEDURE Emit (wr: Wr.T) RAISES {Wr.Failure, Thread.Alerted} =
    BEGIN
      s.wr := wr;
      Out (wr, &quot;set_config_options ()&quot;);
      Out (wr, &quot;readonly &quot;, ModeFlag [M3Options.major_mode],
           &quot; = TRUE % cm3 &quot;, ModeName [M3Options.major_mode]);

      CASE M3Options.major_mode OF
      | MM.Find =&gt; Out (wr, &quot;M3_FIND_UNITS = []&quot;)
      | MM.Build, MM.Clean, MM.Ship =&gt;  (* skip *)
      END;

      ConvertArgList (s);

      CASE M3Options.major_mode OF
      | MM.Build, MM.Clean, MM.Find =&gt;
          IncludeOverrides (s, src_overrides);
          IncludeMakefile (s, src_makefile, src_dir);

      | MM.Ship =&gt;
          IF M3File.IsReadable (&quot;.M3OVERRIDES&quot;) THEN
            Msg.Out (&quot;package was built with overrides, not shipping.&quot;, Wr.EOL);
          ELSIF NOT M3File.IsReadable (&quot;.M3SHIP&quot;) THEN
            Msg.Out (&quot;missing \&quot;.M3SHIP\&quot; file, build the package first.&quot;, Wr.EOL);
          ELSE
            Out (wr, &quot;include (\&quot;.M3SHIP\&quot;)&quot;);
            s.found_work := TRUE;
          END;
      END;
    END Emit;

  BEGIN
    s.args := Arg.NewList ();
    FOR i := 1 TO Params.Count - 1 DO
      Arg.Append (s.args, Params.Get (i));
    END;

    Utils.WriteFile (Makefile, Emit, append := FALSE);

    IF s.found_work THEN
      IF NOT s.keep_files THEN Utils.NoteTempFile (Makefile); END;
      RETURN Makefile;
    ELSE
      Msg.Out (&quot;cm3: found nothing to build.&quot;, Wr.EOL);
      IF NOT s.keep_files THEN Utils.Remove (Makefile); END;
      RETURN NIL;
    END;
  END Build;
</PRE>---------------------------------------------------------- internal ---

<P><PRE>PROCEDURE <A NAME="ConvertArgList"><procedure>ConvertArgList</procedure></A> (VAR s: State)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR len: INTEGER;  arg: TEXT;
  BEGIN
    WHILE (s.args.cnt &gt; 0) DO
      arg := Arg.Pop (s.args);
      len := Text.Length (arg);
      IF (len &lt; 1) THEN
        (* empty argument ignore *)
      ELSIF (Text.GetChar (arg, 0) # '-') OR (len &lt; 2) THEN
        NoteSourceFile (s, NIL, arg, cmd_line := TRUE);
      ELSE (* it's an option *)
        ConvertOption (s, arg, len);
      END;
    END;
  END ConvertArgList;

PROCEDURE <A NAME="ConvertOption"><procedure>ConvertOption</procedure></A> (VAR s: State;  arg: TEXT;  arg_len: INTEGER)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR ok := FALSE;  wr := s.wr;
  BEGIN
    CASE Text.GetChar (arg, 1) OF

    | '?' =&gt; IF (arg_len = 2) THEN
               ok := TRUE;  (* printed during the pre-scan *)
             END;

    | 'a' =&gt; IF (arg_len = 2) THEN
               Out (wr, &quot;library (\&quot;&quot;, GetArg (arg, s.args), &quot;\&quot;)&quot;);  ok := TRUE;
               s.found_work := TRUE;
             END;

    | 'A' =&gt; IF (arg_len = 2) THEN
               Out (wr, &quot;M3_OPTIONS += \&quot;-NoAsserts\&quot;&quot;);  ok := TRUE;
             END;

    | 'b' =&gt; IF Text.Equal (arg, &quot;-boot&quot;) THEN
               Out (wr, &quot;M3_BOOTSTRAP = TRUE&quot;);  ok := TRUE;
             ELSIF Text.Equal(arg, &quot;-build&quot;) THEN
               ok := TRUE; (* mode set during the pre-scan *)
             END;

    | 'c' =&gt; IF (arg_len = 2) THEN
               Out (wr, &quot;m3_compile_only ()&quot;);  ok := TRUE;
               s.found_work := TRUE;
             ELSIF Text.Equal (arg, &quot;-commands&quot;) THEN
               Msg.SetLevel (Msg.Level.Commands);  ok := TRUE;
               Out (wr, &quot;m3_option (\&quot;-commands\&quot;)&quot;);
             ELSIF Text.Equal (arg, &quot;-config&quot;) THEN
               ok := TRUE; (* printed during the pre-scan *)
             ELSIF Text.Equal (arg, &quot;-console&quot;) THEN
               Out (wr, &quot;M3_WINDOWS_GUI = FALSE&quot;);  ok := TRUE;
             ELSIF Text.Equal(arg, &quot;-clean&quot;) THEN
               ok := TRUE;  (* mode set during the pre-scan *)
               s.found_work := TRUE;
             END;

    | 'd' =&gt; IF Text.Equal(arg, &quot;-debug&quot;) THEN
               Msg.SetLevel (Msg.Level.Debug);  ok := TRUE;
               Out (wr, &quot;m3_option (\&quot;-debug\&quot;)&quot;);
             END;

    | 'D' =&gt; ProcessDefine (arg, wr);  ok := TRUE;

    | 'f' =&gt; IF Text.Equal(arg, &quot;-find&quot;) THEN
               ok := TRUE;  (* mode set during the pre-scan *)
               s.found_work := TRUE;
             END;

    | 'g' =&gt; IF (arg_len = 2) THEN
               Out (wr, &quot;m3_debug (TRUE)&quot;);  ok := TRUE;
             ELSIF Text.Equal(arg, &quot;-gui&quot;) THEN
               Out (wr, &quot;M3_WINDOWS_GUI = TRUE&quot;);  ok := TRUE;
             END;

    | 'h' =&gt; IF Text.Equal (arg, &quot;-heap_stats&quot;) THEN
               M3Options.heap_stats := TRUE;  ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-help&quot;) THEN
               ok := TRUE;  (* printed during the pre-scan *)
             END;

    | 'k' =&gt; IF (arg_len = 2) OR Text.Equal (arg, &quot;-keep&quot;) THEN
               Out (wr, &quot;M3_KEEP_FILES = TRUE&quot;);
               s.keep_files := TRUE;  ok := TRUE;
             END;

    | 'o' =&gt; IF (arg_len = 2) THEN
               Out (wr, &quot;program (\&quot;&quot;, GetArg (arg, s.args), &quot;\&quot;)&quot;);  ok := TRUE;
               s.found_work := TRUE;
             ELSIF Text.Equal (arg, &quot;-override&quot;) THEN
               s.use_overrides := TRUE;  ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-once&quot;) THEN
               Out (wr, &quot;M3_COMPILE_ONCE = TRUE&quot;);  ok := TRUE;
             END;

    | 'O' =&gt; IF (arg_len = 2) THEN
               Out (wr, &quot;m3_optimize (TRUE)&quot;);  ok := TRUE;
             END;

    | 's' =&gt; IF Text.Equal (arg, &quot;-silent&quot;) THEN
               Msg.SetLevel (Msg.Level.Silent);  ok := TRUE;
               Out (wr, &quot;m3_option (\&quot;-silent\&quot;)&quot;);
             ELSIF Text.Equal (arg, &quot;-skiplink&quot;) THEN
               Out (wr, &quot;M3_SKIP_LINK = TRUE&quot;);  ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-ship&quot;) THEN
               ok := TRUE;  (* mode set during the pre-scan *)
               s.found_work := TRUE;
             END;

    | 't' =&gt; IF Text.Equal (arg, &quot;-times&quot;) THEN
               M3Timers.Start ();  ok := TRUE;
             END;

    | 'v' =&gt; IF Text.Equal (arg, &quot;-verbose&quot;) THEN
               Msg.SetLevel (Msg.Level.Verbose);
               Out (wr, &quot;m3_option (\&quot;-verbose\&quot;)&quot;);
               M3Timers.Start ();
               ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-version&quot;) THEN
               ok := TRUE;  (* printed during the pre-scan *)
             END;

    | 'w' =&gt; IF Text.Equal (arg, &quot;-why&quot;) THEN
               Msg.SetLevel (Msg.Level.Explain);  ok := TRUE;
               Out (wr, &quot;m3_option (\&quot;-why\&quot;)&quot;);
             ELSIF Text.Equal (arg, &quot;-windows&quot;) THEN
               Out (wr, &quot;M3_WINDOWS_GUI = TRUE&quot;);  ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-w0&quot;) THEN
               Out (wr, &quot;M3_OPTIONS += \&quot;-w0\&quot;&quot;);  ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-w1&quot;) THEN
               Out (wr, &quot;M3_OPTIONS += \&quot;-w1\&quot;&quot;);  ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-w2&quot;) THEN
               Out (wr, &quot;M3_OPTIONS += \&quot;-w2\&quot;&quot;);  ok := TRUE;
             ELSIF Text.Equal (arg, &quot;-w3&quot;) THEN
               Out (wr, &quot;M3_OPTIONS += \&quot;-w3\&quot;&quot;);  ok := TRUE;
             END;

    | 'x' =&gt; IF (arg_len = 2) THEN
               s.use_overrides := TRUE;  ok := TRUE;
             END;

    | 'Z' =&gt; IF (arg_len = 2) THEN
               Out (wr, &quot;M3_COVERAGE = TRUE&quot;);  ok := TRUE;
             END;

    ELSE (* error *)
    END;

    IF (NOT ok) THEN Msg.UsageError (&quot;unrecognized option \&quot;&quot;, arg, &quot;\&quot;&quot;) END;
  END ConvertOption;

PROCEDURE <A NAME="GetArg"><procedure>GetArg</procedure></A> (arg: TEXT;  rest: Arg.List): TEXT =
  BEGIN
    IF (rest.cnt &lt;= 0) THEN
      Msg.UsageError (&quot;missing argument to \&quot;&quot;, arg, &quot;\&quot; option&quot;);
    END;
    RETURN Arg.Pop (rest);
  END GetArg;

PROCEDURE <A NAME="ProcessDefine"><procedure>ProcessDefine</procedure></A> (arg: TEXT;  wr: Wr.T)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR len := Text.Length (arg);  eq: INTEGER;  sym, val: TEXT;
  BEGIN
    IF (len &lt;= 2) THEN
      Msg.UsageError (&quot;missing argument to \&quot;-D\&quot; option&quot;);
      RETURN;
    END;

    eq := Text.FindChar (arg, '=');
    IF (eq &lt; 0) THEN
      (* -Dsymbol ==&gt;  symbol = TRUE *)
      Out (wr, Text.Sub (arg, 2), &quot; = TRUE&quot;);
      RETURN;
    END;

    sym := Text.Sub (arg, 2, eq-2);
    val := Text.Sub (arg, eq+1);
    len := Text.Length (val);

    IF (len = 0) THEN
      (* -Dsymbol=   ==&gt; symbol = &quot;&quot; *)
      Out (wr, sym, &quot; = \&quot;\&quot;&quot;);

    ELSIF Text.GetChar (arg, 0) = '&quot;'
      AND Text.GetChar (arg, len-1) = '&quot;' THEN
      (* -Dsymbol=&quot;foo&quot; ==&gt; symbol = &quot;foo&quot; *)
      Out (wr, sym, &quot; = &quot;, val);

    ELSIF Text.Equal (val, &quot;TRUE&quot;) OR Text.Equal (val, &quot;FALSE&quot;) THEN
      Out (wr, sym, &quot; = &quot;, val);

    ELSE
      (* -Dsymbol=val  ==&gt; symbol = &quot;val&quot; *)
      Out (wr, sym, &quot; = \&quot;&quot;, val, &quot;\&quot;&quot;);

    END;
  END ProcessDefine;

CONST
  SourceTag = ARRAY NK OF TEXT {
    NIL,                                              (* unknown *)
    &quot;interface&quot;, NIL, NIL, &quot;import_obj&quot;,              (* i3, ic, is, io *)
    &quot;implementation&quot;, NIL, NIL, &quot;import_obj&quot;,         (* m3, mc, ms, mo *)
    &quot;generic_interface&quot;, &quot;generic_implementation&quot;,    (* ig, mg *)
    &quot;c_source&quot;, &quot;h_source&quot;, &quot;s_source&quot;, &quot;import_obj&quot;, (* c, h, s, o *)
    &quot;import_lib&quot;, &quot;import_lib&quot;, NIL,                  (* m3lib, lib, m3x *)
    NIL, NIL, NIL                                     (* pgm, mx, tmpl *)
  };

PROCEDURE <A NAME="NoteSourceFile"><procedure>NoteSourceFile</procedure></A> (VAR s: State;  dir, name: TEXT;  cmd_line: BOOLEAN)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR
    file := M3Path.New (dir, name);
    info := M3Path.Parse (file, host := TRUE);
    tag  : TEXT;
  BEGIN
    Msg.Debug (&quot;  file &quot;, file, Wr.EOL);

    IF (M3Options.major_mode = MM.Find) AND (cmd_line) THEN
      Out (s.wr, &quot;M3_FIND_UNITS += \&quot;&quot;, M3Path.Join (NIL, info.base, info.kind,
                                             host := TRUE), &quot;\&quot;&quot;);
      s.found_work := TRUE;
      RETURN;
    END;

    tag := SourceTag [info.kind];
    IF (tag # NIL) THEN
      file := M3Path.Escape (M3Path.New (info.dir, info.base));
      Out (s.wr, tag, &quot; (\&quot;&quot;, file, &quot;\&quot;)&quot;);
      s.found_work := TRUE;
    ELSE
      VisitSourceDir (s, file, cmd_line);
    END;
  END NoteSourceFile;

PROCEDURE <A NAME="VisitSourceDir"><procedure>VisitSourceDir</procedure></A> (VAR s: State;  dir: TEXT;  cmd_line: BOOLEAN)
  RAISES {Wr.Failure, Thread.Alerted} =
  VAR iter: FS.Iterator;  name: TEXT;
  BEGIN
    Msg.Debug (&quot;--- dir &quot;, dir, &quot; ---&quot;, Wr.EOL);
    IF NOT M3File.IsDirectory (dir) THEN
      IF (cmd_line) THEN
        Msg.FatalError (NIL, &quot;unsupported file type \&quot;&quot;, dir, &quot;\&quot;&quot;);
      END;
      Msg.Verbose (&quot;ignoring &quot;, dir, &quot; (not a directory)&quot;);
      RETURN;
    END;
    TRY
      Msg.Verbose (&quot;Looking in &quot;, dir);
      iter := FS.Iterate (dir);
      TRY
        WHILE iter.next (name) DO
          NoteSourceFile (s, dir, name, cmd_line := FALSE);
        END;
      FINALLY
        iter.close();
      END;
    EXCEPT OSError.E (args) =&gt;
      Msg.FatalError (args, &quot;unable to scan directory \&quot;&quot;, dir, &quot;\&quot;&quot;);
    END;
  END VisitSourceDir;

PROCEDURE <A NAME="IncludeOverrides"><procedure>IncludeOverrides</procedure></A> (VAR s: State;  overrides: TEXT)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF M3File.IsReadable (overrides) THEN
      IF (s.use_overrides) THEN
        Out (s.wr, &quot;include (\&quot;&quot;, M3Path.Escape (overrides), &quot;\&quot;)&quot;);
        s.found_work := TRUE;
      ELSE
        Msg.Out (&quot;ignoring &quot;, overrides, Wr.EOL);
      END;
    ELSE
      IF (s.use_overrides) THEN
        Msg.Out (&quot;unable to read &quot;, overrides,
          &quot;, options \&quot;-override\&quot; and \&quot;-x\&quot; ignored.&quot;, Wr.EOL);
      END;
    END;
  END IncludeOverrides;

PROCEDURE <A NAME="IncludeMakefile"><procedure>IncludeMakefile</procedure></A> (VAR s: State;  makefile, dir: TEXT)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF M3File.IsReadable (makefile) THEN
      Out (s.wr, &quot;include_dir (\&quot;&quot;, M3Path.Escape (dir), &quot;\&quot;)&quot;);
      s.found_work := TRUE;
    ELSE
      Out (s.wr, &quot;import (\&quot;libm3\&quot;)&quot;);
      VisitSourceDir (s, dir, cmd_line := FALSE);
      Out (s.wr, &quot;program (\&quot;prog\&quot;)&quot;);
    END;
  END IncludeMakefile;
</PRE>----------------------------------------- pre-scan command line ---

<P><PRE>PROCEDURE <A NAME="ScanCommandLine"><procedure>ScanCommandLine</procedure></A> () =
  VAR cnt := 0;  arg: TEXT;
  BEGIN
    FOR i := 1 TO Params.Count-1 DO
      arg := Params.Get (i);
      IF    Text.Equal (arg, &quot;-build&quot;)   THEN  SetMode (cnt, MM.Build);
      ELSIF Text.Equal (arg, &quot;-clean&quot;)   THEN  SetMode (cnt, MM.Clean);
      ELSIF Text.Equal (arg, &quot;-find&quot;)    THEN  SetMode (cnt, MM.Find);
      ELSIF Text.Equal (arg, &quot;-ship&quot;)    THEN  SetMode (cnt, MM.Ship);
      ELSIF Text.Equal (arg, &quot;-?&quot;)       THEN  PrintHelp ();
      ELSIF Text.Equal (arg, &quot;-help&quot;)    THEN  PrintHelp ();
      ELSIF Text.Equal (arg, &quot;-config&quot;)  THEN  PrintVersion (TRUE);
      ELSIF Text.Equal (arg, &quot;-version&quot;) THEN  PrintVersion (TRUE);
      END;
    END;
    IF (cnt &lt;= 0) THEN SetMode (cnt, MM.Build); END;
  END ScanCommandLine;

PROCEDURE <A NAME="SetMode"><procedure>SetMode</procedure></A> (VAR cnt: INTEGER;  mode: MM) =
  BEGIN
    INC (cnt);
    IF (cnt &gt; 1) THEN
      Msg.Error (NIL, &quot;mode \&quot;&quot;, ModeName [M3Options.major_mode],
                 &quot;\&quot; already set, \&quot;&quot;, ModeName [mode] &amp; &quot;\&quot; ignored.&quot;);
    ELSE
      M3Options.major_mode := mode;
    END;
  END SetMode;

PROCEDURE <A NAME="PrintVersion"><procedure>PrintVersion</procedure></A> (exit: BOOLEAN) =
  BEGIN
    Msg.Out (&quot;Critical Mass Modula-3 version 5.1&quot;, Wr.EOL);
    Msg.Out (&quot;  last updated:  Nov 1, 1997&quot;, Wr.EOL);
    Msg.Out (&quot;  configuration: &quot;, M3Config.FindFile(), Wr.EOL);
    Msg.Out (Wr.EOL);
    IF exit THEN Process.Exit (0); END;
  END PrintVersion;

PROCEDURE <A NAME="PrintHelp"><procedure>PrintHelp</procedure></A> () =
  BEGIN
    PrintVersion (FALSE);
    FOR i := FIRST (HelpMsg) TO LAST (HelpMsg) DO
      Msg.Out (HelpMsg[i], Wr.EOL);
    END;
    Process.Exit (0);
  END PrintHelp;

CONST
  HelpMsg = ARRAY OF TEXT {
    &quot;command line options:&quot;,
    &quot;&quot;,
    &quot;modes:  (default: -build)&quot;,
    &quot;  -build         compile and link&quot;,
    &quot;  -ship          install package&quot;,
    &quot;  -clean         delete derived files&quot;,
    &quot;  -find          locate source files&quot;,
    &quot;&quot;,
    &quot;compile options:  (default: -g -w1)&quot;,
    &quot;  -g             produce symbol table information for debugger&quot;,
    &quot;  -O             optimize code&quot;,
    &quot;  -A             disable code generation for assertions&quot;,
    &quot;  -once          don't recompile to improve opaque object code&quot;,
    &quot;  -w0 .. -w3     limit compiler warning messages&quot;,
    &quot;  -Z             generate coverage analysis code&quot;,
    &quot;&quot;,
    &quot;program and library options:  (default: -o prog)&quot;,
    &quot;  -c             compile only, produce no program or library&quot;,
    &quot;  -a &lt;foo&gt;       build library &lt;foo&gt;&quot;,
    &quot;  -o &lt;foo&gt;       build program &lt;foo&gt;&quot;,
    &quot;  -skiplink      skip the final link step&quot;,
    &quot;&quot;,
    &quot;messages:  (default: -why)&quot;,
    &quot;  -silent        produce no diagnostic output&quot;,
    &quot;  -why           explain why code is being recompiled&quot;,
    &quot;  -commands      list system commands as they are performed&quot;,
    &quot;  -verbose       list internal steps as they are performed&quot;,
    &quot;  -debug         dump internal debugging information&quot;,
    &quot;&quot;,
    &quot;information and help:&quot;,
    &quot;  -help          print this help message&quot;,
    &quot;  -?             print this help message&quot;,
    &quot;  -version       print the version number header&quot;,
    &quot;  -config        print the version number header&quot;,
    &quot;&quot;,
    &quot;misc:&quot;,
    &quot;  -keep          preserve intermediate and temporary files&quot;,
    &quot;  -times         produce a dump of elapsed times&quot;,
    &quot;  -override      include the \&quot;.m3overrides\&quot; file&quot;,
    &quot;  -x             include the \&quot;.m3overrides\&quot; file&quot;,
    &quot;  -D&lt;symbol&gt;     define &lt;symbol&gt; with the value TRUE&quot;,
    &quot;  -D&lt;sym&gt;=&lt;val&gt;  define &lt;sym&gt; with the value &lt;val&gt;&quot;,
    &quot;  -console       produce a Windows CONSOLE subsystem program&quot;,
    &quot;  -gui           produce a Windows GUI subsystem program&quot;,
    &quot;  -windows       produce a Windows GUI subsystem program&quot;,
    &quot;&quot;
  };
</PRE>---------------------------------------------------------- misc ---

<P><PRE>PROCEDURE <A NAME="Out"><procedure>Out</procedure></A> (wr: Wr.T;  a, b, c, d, e: TEXT := NIL)
  RAISES {Wr.Failure, Thread.Alerted} =
  BEGIN
    IF (a # NIL) THEN Wr.PutText (wr, a); END;
    IF (b # NIL) THEN Wr.PutText (wr, b); END;
    IF (c # NIL) THEN Wr.PutText (wr, c); END;
    IF (d # NIL) THEN Wr.PutText (wr, d); END;
    IF (e # NIL) THEN Wr.PutText (wr, e); END;
    Wr.PutText (wr, Wr.EOL);
  END Out;

BEGIN
END Makefile.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface Msg is in:
</A><UL>
<LI><A HREF="Msg.i3.html#0TOP0">cm3/src/Msg.i3</A>
<LI><A HREF="../../m3tohtml/src/Msg.i3.html#0TOP0">m3tohtml/src/Msg.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
