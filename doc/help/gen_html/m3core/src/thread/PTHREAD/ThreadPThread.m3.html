<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3core/src/thread/PTHREAD/ThreadPThread.m3</TITLE>
</HEAD>
<BODY bgcolor="#ffffff">
<A NAME="0TOP0">
<H2>m3core/src/thread/PTHREAD/ThreadPThread.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 2005, Purdue Research Foundation                  
 All rights reserved.                                            
 See the file COPYRIGHT-PURDUE for a full description.           

<P><PRE>UNSAFE MODULE <module>ThreadPThread</module>
EXPORTS
<A HREF="../Common/Thread.i3.html"><implements>Thread</A></implements>, <A HREF="ThreadF.i3.html"><implements>ThreadF</A></implements>, <A HREF="../Common/Scheduler.i3.html"><implements>Scheduler</A></implements>, <A HREF="../Common/SchedulerPosix.i3.html"><implements>SchedulerPosix</A></implements>, <A HREF="../../runtime/common/RTOS.i3.html"><implements>RTOS</A></implements>, <A HREF="../../runtime/common/RTHooks.i3.html"><implements>RTHooks</A></implements>, <A HREF="ThreadPThread.i3.html"><implements>ThreadPThread</A></implements>;

IMPORT <A HREF="../../C/Common/Cerrno.i3.html">Cerrno</A>, <A HREF="../../float/IEEE-default/FloatMode.i3.html">FloatMode</A>, <A HREF="../Common/MutexRep.i3.html">MutexRep</A>,
       <A HREF="../../runtime/common/RTCollectorSRC.i3.html">RTCollectorSRC</A>, <A HREF="../../runtime/common/RTError.i3.html">RTError</A>, <A HREF="../../runtime/common/RTHeapRep.i3.html">RTHeapRep</A>, <A HREF="../../runtime/common/RTIO.i3.html">RTIO</A>, <A HREF="#x1">RTMachine</A>, <A HREF="../../runtime/common/RTParams.i3.html">RTParams</A>,
       <A HREF="../../runtime/POSIX/RTPerfTool.i3.html">RTPerfTool</A>, <A HREF="../../runtime/common/RTProcess.i3.html">RTProcess</A>, <A HREF="../Common/ThreadEvent.i3.html">ThreadEvent</A>, <A HREF="../../time/Common/Time.i3.html">Time</A>,
       <A HREF="#x2">Unix</A>, <A HREF="#x3">Utime</A>, <A HREF="../../word/Word.i3.html">Word</A>, <A HREF="#x4">Upthread</A>, <A HREF="#x5">Usched</A>,
       <A HREF="#x6">Uerror</A>, <A HREF="#x7">Uexec</A>;
FROM <A HREF="#x4">Upthread</A> IMPORT pthread_t;
FROM <A HREF="../../../derived/Compiler.i3.html">Compiler</A> IMPORT ThisFile, ThisLine;
FROM <A HREF="../../C/Common/Ctypes.i3.html">Ctypes</A> IMPORT int;
IMPORT <A HREF="../../runtime/common/RuntimeError.i3.html">RuntimeError</A> AS RTE;
</PRE>----------------------------------------------------- types and globals ---

<P><PRE>VAR
  stack_grows_down: BOOLEAN;
  nextId: CARDINAL := 1;

REVEAL
  <A NAME="Mutex">Mutex</A> = MutexRep.Public BRANDED &quot;Mutex Pthread-1.0&quot; OBJECT
    mutex: pthread_mutex_t := NIL;
  OVERRIDES
    acquire := LockMutex;
    release := UnlockMutex;
  END;

  <A NAME="Condition">Condition</A> = BRANDED &quot;Thread.Condition Pthread-1.0&quot; OBJECT
    mutex: pthread_mutex_t := NIL;
    waiters: T := NIL;                  (* LL = mutex *)
  END;

  <A NAME="T">T</A> = MUTEX BRANDED &quot;Thread.T Pthread-1.6&quot; OBJECT
    (* live thread data *)
    act: Activation := NIL;		 (* LL = mutex *)

    (* our work and its result *)
    closure: Closure := NIL;		 (* LL = mutex *)
    result: REFANY := NIL;		 (* LL = mutex *)

    (* wait here to join *)
    cond: Condition := NIL;		 (* LL = mutex *)

    (* CV that we're blocked on *)
    waitingOn: Condition := NIL;	 (* LL = waitingOn.mutex *)
    (* queue of threads waiting on the same CV *)
    nextWaiter: T := NIL;		 (* LL = waitingOn.mutex *)

    (* condition for blocking during &quot;Wait&quot; *)
    waitCond: pthread_cond_t := NIL;

    (* the alert flag *)
    alerted : BOOLEAN := FALSE;		 (* LL = mutex *)

    (* indicates that &quot;result&quot; is set *)
    completed: BOOLEAN := FALSE;	 (* LL = mutex *)

    (* unique Id of this thread *)
    id: Id := 0;			 (* LL = mutex *)
  END;

TYPE
  ActState = { Starting, Started, Stopping, Stopped };
  Activation = UNTRACED REF RECORD
    (* exception handling support *)
    frame: ADDRESS := NIL;
    (* global doubly-linked, circular list of all active threads *)
    next, prev: Activation := NIL;	 (* LL = activeMu *)
    (* thread handle *)
    handle: pthread_t;			 (* LL = activeMu *)
    (* base of thread stack for use by GC *)
    stackbase: ADDRESS := NIL;		 (* LL = activeMu *)
    sp: ADDRESS := NIL;			 (* LL = activeMu *)
    size: INTEGER;			 (* LL = activeMu *)

    state := ActState.Started;		 (* LL = activeMu *)

    (* index into global array of active, slotted threads *)
    slot: INTEGER;			 (* LL = slotMu *)

    (* state that is available to the floating point routines *)
    floatState : FloatMode.ThreadState;

    (* state that is available to the heap routines *)
    heapState : RTHeapRep.ThreadState;
  END;

PROCEDURE <A NAME="SetState"><procedure>SetState</procedure></A> (act: Activation;  state: ActState) =
  CONST text = ARRAY ActState OF TEXT
    { &quot;Starting&quot;, &quot;Started&quot;, &quot;Stopping&quot;, &quot;Stopped&quot; };
  BEGIN
    act.state := state;
    IF DEBUG THEN
      RTIO.PutText(text[state]);
      RTIO.PutText(&quot; act=&quot;);
      RTIO.PutAddr(act);
      RTIO.PutText(&quot;\n&quot;);
      RTIO.Flush();
    END;
  END SetState;
</PRE>----------------------------------------------------------------- Mutex ---
         
<P><PRE>PROCEDURE <A NAME="Acquire"><procedure>Acquire</procedure></A> (m: Mutex) =
  BEGIN
    m.acquire ();
  END Acquire;

PROCEDURE <A NAME="Release"><procedure>Release</procedure></A> (m: Mutex) =
  BEGIN
    m.release ();
  END Release;

PROCEDURE <A NAME="CleanMutex"><procedure>CleanMutex</procedure></A> (r: REFANY) =
  VAR m := NARROW(r, Mutex);
  BEGIN
    pthread_mutex_delete(m.mutex);
    m.mutex := NIL;
  END CleanMutex;

PROCEDURE <A NAME="InitMutexHelper"><procedure>InitMutexHelper</procedure></A> (root: REFANY; VAR result: pthread_mutex_t;
                           Clean: PROCEDURE(r: REFANY)) =
  VAR mutex := pthread_mutex_new();
  BEGIN
    WITH r = pthread_mutex_lock_init() DO &lt;*ASSERT r=0*&gt; END;
    IF result = NIL THEN (* We won the race. *)
      IF mutex = NIL THEN (* But we failed. *)
        WITH r = pthread_mutex_unlock_init() DO &lt;*ASSERT r=0*&gt; END;
        RTE.Raise (RTE.T.OutOfMemory);
      ELSE (* We won the race and succeeded. *)
        result := mutex;
        WITH r = pthread_mutex_unlock_init() DO &lt;*ASSERT r=0*&gt; END;
        RTHeapRep.RegisterFinalCleanup (root, Clean);
      END;
    ELSE (* another thread beat us in the race, ok *)
      WITH r = pthread_mutex_unlock_init() DO &lt;*ASSERT r=0*&gt; END;
      pthread_mutex_delete(mutex);
    END;
  END InitMutexHelper;

PROCEDURE <A NAME="InitMutex"><procedure>InitMutex</procedure></A> (m: Mutex) =
  BEGIN
    InitMutexHelper(m, m.mutex, CleanMutex);
  END InitMutex;

PROCEDURE <A NAME="LockMutex"><procedure>LockMutex</procedure></A> (m: Mutex) =
  VAR self := Self();
  BEGIN
    IF self = NIL THEN
      Die(ThisLine(), &quot;LockMutex called from a non-Modula-3 thread&quot;);
    END;
    IF m.mutex = NIL THEN InitMutex(m) END;
    IF perfOn THEN PerfChanged(self.id, State.locking) END;
    WITH r = pthread_mutex_lock(m.mutex) DO
      IF r # 0 THEN
        RTError.MsgI(ThisFile(), ThisLine(),
                     &quot;Thread client error: pthread_mutex_lock error: &quot;, r);
      END;
    END;
    IF perfOn THEN PerfRunning(self.id) END;
  END LockMutex;

PROCEDURE <A NAME="UnlockMutex"><procedure>UnlockMutex</procedure></A> (m: Mutex) =
  (* LL = m *)
  VAR self := Self();
  BEGIN
    IF self = NIL THEN
      Die(ThisLine(), &quot;UnlockMutex called from a non-Modula-3 thread&quot;);
    END;
    WITH r = pthread_mutex_unlock(m.mutex) DO
      IF r # 0 THEN
        RTError.MsgI(ThisFile(), ThisLine(),
                     &quot;Thread client error: pthread_mutex_unlock error: &quot;, r);
      END;
    END;
  END UnlockMutex;
</PRE>---------------------------------------- Condition variables and Alerts ---

<P><PRE>PROCEDURE <A NAME="CleanCondition"><procedure>CleanCondition</procedure></A> (r: REFANY) =
  VAR c := NARROW(r, Condition);
  BEGIN
    pthread_mutex_delete(c.mutex);
    c.mutex := NIL;
  END CleanCondition;

PROCEDURE <A NAME="InitCondition"><procedure>InitCondition</procedure></A> (c: Condition) =
  BEGIN
    InitMutexHelper(c, c.mutex, CleanCondition);
  END InitCondition;

PROCEDURE <A NAME="XWait"><procedure>XWait</procedure></A> (self: T; m: Mutex; c: Condition; alertable: BOOLEAN)
  RAISES {Alerted} =
  (* LL = m *)
  VAR next, prev: T;
  BEGIN
    IF c.mutex = NIL THEN InitCondition(c) END;
    TRY
      &lt;*ASSERT self.waitingOn = NIL*&gt;
      &lt;*ASSERT self.nextWaiter = NIL*&gt;
      IF perfOn THEN PerfChanged(self.id, State.waiting) END;
      WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
      BEGIN
        self.waitingOn := c;
        next := c.waiters;
        IF next = NIL THEN
          c.waiters := self;
        ELSE
          (* put me on the list of waiters *)
          prev := NIL;
          WHILE next # NIL DO prev := next; next := next.nextWaiter; END;
          prev.nextWaiter := self;
        END;
      END;
      WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
      IF alertable AND XTestAlert(self) THEN RAISE Alerted; END;
      LOOP
        WITH r = pthread_cond_wait(self.waitCond, m.mutex) DO
          IF r # 0 THEN
            RTError.MsgI(ThisFile(), ThisLine(),
                         &quot;Thread client error: pthread_cond_wait error &quot;, r);
          END;
        END;
        IF alertable AND XTestAlert(self) THEN RAISE Alerted; END;
        IF self.waitingOn = NIL THEN RETURN END;
      END;
    FINALLY
      WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
      IF self.waitingOn # NIL THEN
        &lt;*ASSERT self.waitingOn = c*&gt;
        (* alerted: dequeue from condition *)
        next := c.waiters; prev := NIL;
        WHILE next # self DO
          &lt;*ASSERT next # NIL*&gt;
          prev := next; next := next.nextWaiter;
        END;
        IF prev = NIL
          THEN c.waiters := self.nextWaiter;
          ELSE prev.nextWaiter := self.nextWaiter;
        END;
        self.nextWaiter := NIL;
        self.waitingOn := NIL;
      END;
      WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
      IF perfOn THEN PerfRunning(self.id) END;
      &lt;*ASSERT self.waitingOn = NIL*&gt;
      &lt;*ASSERT self.nextWaiter = NIL*&gt;
    END;
  END XWait;

PROCEDURE <A NAME="AlertWait"><procedure>AlertWait</procedure></A> (m: Mutex; c: Condition) RAISES {Alerted} =
  (* LL = m *)
  VAR self := Self();
  BEGIN
    IF self = NIL THEN
      Die(ThisLine(), &quot;AlertWait called from non-Modula-3 thread&quot;);
    END;
    XWait(self, m, c, alertable := TRUE);
  END AlertWait;

PROCEDURE <A NAME="Wait"><procedure>Wait</procedure></A> (m: Mutex; c: Condition) =
  &lt;*FATAL Alerted*&gt;
  (* LL = m *)
  VAR self := Self();
  BEGIN
    IF self = NIL THEN
      Die(ThisLine(), &quot;Wait called from non-Modula-3 thread&quot;);
    END;
    XWait(self, m, c, alertable := FALSE);
  END Wait;

PROCEDURE <A NAME="DequeueHead"><procedure>DequeueHead</procedure></A>(c: Condition) =
  (* LL = c.mutex *)
  VAR t: T;
  BEGIN
    t := c.waiters; c.waiters := t.nextWaiter;
    t.nextWaiter := NIL;
    t.waitingOn := NIL;
    WITH r = pthread_cond_signal(t.waitCond) DO &lt;*ASSERT r=0*&gt; END;
  END DequeueHead;

PROCEDURE <A NAME="Signal"><procedure>Signal</procedure></A> (c: Condition) =
  BEGIN
    IF c.mutex = NIL THEN InitCondition(c) END;
    WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
    IF c.waiters # NIL THEN DequeueHead(c) END;
    WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
  END Signal;

PROCEDURE <A NAME="Broadcast"><procedure>Broadcast</procedure></A> (c: Condition) =
  BEGIN
    IF c.mutex = NIL THEN InitCondition(c) END;
    WITH r = pthread_mutex_lock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
    WHILE c.waiters # NIL DO DequeueHead(c) END;
    WITH r = pthread_mutex_unlock(c.mutex) DO &lt;*ASSERT r=0*&gt; END;
  END Broadcast;

PROCEDURE <A NAME="Alert"><procedure>Alert</procedure></A> (t: T) =
  BEGIN
    LOCK t DO
      t.alerted := TRUE;
      IF t.waitCond # NIL THEN
        WITH r = pthread_cond_signal(t.waitCond) DO &lt;*ASSERT r=0*&gt; END;
      END;
    END;
  END Alert;

PROCEDURE <A NAME="XTestAlert"><procedure>XTestAlert</procedure></A> (self: T): BOOLEAN =
  BEGIN
    LOCK self DO
      IF self.alerted THEN
        self.alerted := FALSE;
        RETURN TRUE;
      ELSE
        RETURN FALSE;
      END;
    END;
  END XTestAlert;

PROCEDURE <A NAME="TestAlert"><procedure>TestAlert</procedure></A> (): BOOLEAN =
  VAR self := Self();
  BEGIN
    IF self = NIL THEN
      Die(ThisLine(), &quot;TestAlert called from non-Modula-3 thread&quot;);
    END;
    RETURN XTestAlert(self);
  END TestAlert;
</PRE>------------------------------------------------------------------ Self ---

<P><PRE>VAR (* LL = slotMu *)
  n_slotted := 0;
  next_slot := 1;
  slots: REF ARRAY OF T;		 (* NOTE: we don't use slots[0] *)

PROCEDURE <A NAME="InitActivations"><procedure>InitActivations</procedure></A> (): Activation =
  VAR me := NEW(Activation);
  BEGIN
    &lt;* ASSERT me.frame = NIL *&gt;
    &lt;* ASSERT me.next = NIL *&gt;
    &lt;* ASSERT me.prev = NIL *&gt;
    &lt;* ASSERT me.stackbase = NIL *&gt;
    &lt;* ASSERT me.sp = NIL *&gt;
    &lt;* ASSERT me.state = ActState.Started *&gt;
    me.handle := Upthread.self();
    me.next := me;
    me.prev := me;
    WITH r = pthread_key_create_activations() DO &lt;*ASSERT r=0*&gt; END;
    WITH r = pthread_setspecific_activations(me) DO &lt;*ASSERT r=0*&gt; END;
    WITH r = pthread_mutex_lock_active() DO &lt;*ASSERT r=0*&gt; END;
      &lt;* ASSERT next_slot = 1 *&gt; (* no threads created yet *)
      &lt;* ASSERT slots = NIL *&gt; (* no threads created yet *)
      &lt;* ASSERT n_slotted = 0 *&gt; (* no threads created yet *)
      &lt;* ASSERT allThreads = NIL *&gt; (* no threads created yet *)
      allThreads := me;
    WITH r = pthread_mutex_unlock_active() DO &lt;*ASSERT r=0*&gt; END;
    RETURN me;
  END InitActivations;

PROCEDURE <A NAME="SetActivation"><procedure>SetActivation</procedure></A> (act: Activation) =
  (* LL = 0 *)
  VAR v: ADDRESS := act;
  BEGIN
    WITH r = pthread_setspecific_activations(v) DO &lt;*ASSERT r=0*&gt; END;
  END SetActivation;

PROCEDURE <A NAME="GetActivation"><procedure>GetActivation</procedure></A> (): Activation =
  (* If not the initial thread and not created by Fork, returns NIL *)
  (* LL = 0 *)
  BEGIN
    RETURN pthread_getspecific_activations();
  END GetActivation;

PROCEDURE <A NAME="Self"><procedure>Self</procedure></A> (): T =
  (* If not the initial thread and not created by Fork, returns NIL *)
  (* LL = 0 *)
  VAR
    me: Activation;
    t: T;
  BEGIN
    IF allThreads = NIL THEN RETURN NIL END;
    me := pthread_getspecific_activations();
    IF me = NIL THEN RETURN NIL END;
    WITH r = pthread_mutex_lock_slot() DO &lt;*ASSERT r=0*&gt; END;
      t := slots[me.slot];
    WITH r = pthread_mutex_unlock_slot() DO &lt;*ASSERT r=0*&gt; END;
    IF (t.act # me) THEN Die(ThisLine(), &quot;thread with bad slot!&quot;) END;
    RETURN t;
  END Self;

PROCEDURE <A NAME="AssignSlot"><procedure>AssignSlot</procedure></A> (t: T) =
  (* LL = 0, cause we allocate stuff with NEW! *)
  VAR n: CARDINAL;  new_slots: REF ARRAY OF T;
  BEGIN
    WITH r = pthread_mutex_lock_slot() DO &lt;*ASSERT r=0*&gt; END;

      (* make sure we have room to register this guy *)
      IF (slots = NIL) THEN
        WITH r = pthread_mutex_unlock_slot() DO &lt;*ASSERT r=0*&gt; END;
          slots := NEW (REF ARRAY OF T, 20);
        WITH r = pthread_mutex_lock_slot() DO &lt;*ASSERT r=0*&gt; END;
      END;
      IF (n_slotted &gt;= LAST (slots^)) THEN
        n := NUMBER (slots^);
        WITH r = pthread_mutex_unlock_slot() DO &lt;*ASSERT r=0*&gt; END;
          new_slots := NEW (REF ARRAY OF T, n+n);
        WITH r = pthread_mutex_lock_slot() DO &lt;*ASSERT r=0*&gt; END;
        IF (n = NUMBER (slots^)) THEN
          (* we won any races that may have occurred. *)
          SUBARRAY (new_slots^, 0, n) := slots^;
          slots := new_slots;
        ELSIF (n_slotted &lt; LAST (slots^)) THEN
          (* we lost a race while allocating a new slot table,
             and the new table has room for us. *)
        ELSE
          (* ouch, the new table is full too!   Bail out and retry *)
          WITH r = pthread_mutex_unlock_slot() DO &lt;*ASSERT r=0*&gt; END;
          AssignSlot (t);
        END;
      END;

      (* look for an empty slot *)
      WHILE (slots [next_slot] # NIL) DO
        INC (next_slot);
        IF (next_slot &gt;= NUMBER (slots^)) THEN next_slot := 1; END;
      END;

      INC (n_slotted);
      t.act.slot := next_slot;
      slots [next_slot] := t;

    WITH r = pthread_mutex_unlock_slot() DO &lt;*ASSERT r=0*&gt; END;
  END AssignSlot;

PROCEDURE <A NAME="FreeSlot"><procedure>FreeSlot</procedure></A> (t: T) =
  (* LL = 0 *)
  BEGIN
    WITH r = pthread_mutex_lock_slot() DO &lt;*ASSERT r=0*&gt; END;

      DEC (n_slotted);
      WITH z = slots [t.act.slot] DO
        IF (z # t) THEN Die (ThisLine(), &quot;unslotted thread!&quot;); END;
        z := NIL;
      END;
      t.act.slot := 0;

    WITH r = pthread_mutex_unlock_slot() DO &lt;*ASSERT r=0*&gt; END;
  END FreeSlot;

PROCEDURE <A NAME="DumpThread"><procedure>DumpThread</procedure></A> (t: T) =
  BEGIN
    RTIO.PutText(&quot;Thread: &quot;); RTIO.PutAddr(LOOPHOLE(t, ADDRESS)); RTIO.PutChar('\n');
    RTIO.PutText(&quot;  act:        &quot;); RTIO.PutAddr(LOOPHOLE(t.act, ADDRESS));           RTIO.PutChar('\n');
    RTIO.PutText(&quot;  closure:    &quot;); RTIO.PutAddr(LOOPHOLE(t.closure, ADDRESS));       RTIO.PutChar('\n');
    RTIO.PutText(&quot;  result:     &quot;); RTIO.PutAddr(LOOPHOLE(t.result, ADDRESS));        RTIO.PutChar('\n');
    RTIO.PutText(&quot;  cond:       &quot;); RTIO.PutAddr(LOOPHOLE(t.cond, ADDRESS));          RTIO.PutChar('\n');
    RTIO.PutText(&quot;  waitingOn:  &quot;); RTIO.PutAddr(LOOPHOLE(t.waitingOn, ADDRESS));     RTIO.PutChar('\n');
    RTIO.PutText(&quot;  nextWaiter: &quot;); RTIO.PutAddr(LOOPHOLE(t.nextWaiter, ADDRESS));    RTIO.PutChar('\n');
    RTIO.PutText(&quot;  waitCond:   &quot;); RTIO.PutAddr(t.waitCond);      RTIO.PutChar('\n');
    RTIO.PutText(&quot;  alerted:    &quot;); RTIO.PutInt(ORD(t.alerted));   RTIO.PutChar('\n');
    RTIO.PutText(&quot;  completed:  &quot;); RTIO.PutInt(ORD(t.completed)); RTIO.PutChar('\n');
    RTIO.PutText(&quot;  id:         &quot;); RTIO.PutInt(t.id);             RTIO.PutChar('\n');
    RTIO.Flush();
  END DumpThread;

&lt;*UNUSED*&gt;
PROCEDURE <A NAME="DumpThreads"><procedure>DumpThreads</procedure></A> () =
  VAR t: T;
  BEGIN
    FOR i := 1 TO LAST(slots^) DO
      t := slots[i];
      IF t # NIL THEN
        DumpThread(t);
      END;
    END;
  END DumpThreads;
</PRE>------------------------------------------------------------ Fork, Join ---

<P><PRE>VAR (* LL=activeMu *)
  allThreads: Activation := NIL;	 (* global list of active threads *)

PROCEDURE <A NAME="CreateT"><procedure>CreateT</procedure></A> (act: Activation): T =
  (* LL = 0, because allocating a traced reference may cause
     the allocator to start a collection which will call &quot;SuspendOthers&quot;
     which will try to acquire &quot;activeMu&quot;. *)
  VAR
    t := NEW(T, act := act);
    cond := pthread_cond_new();
  BEGIN
    IF cond = NIL THEN RTE.Raise(RTE.T.OutOfMemory); END;
    t.waitCond := cond;
    t.cond     := NEW(Condition);
    FloatMode.InitThread (act.floatState);
    AssignSlot (t);
    RETURN t;
  END CreateT;
</PRE> ThreadBase calls RunThread after finding (approximately) where
   its stack begins.  This dance ensures that all of ThreadMain's
   traced references are within the stack scanned by the collector. 

<P><PRE>PROCEDURE <A NAME="ThreadBase"><procedure>ThreadBase</procedure></A> (param: ADDRESS): ADDRESS =
  VAR
    xx: INTEGER;
    me: Activation := param;
  BEGIN
    SetActivation (me);
    (* We need to establish this binding before this thread touches any
       traced references.  Otherwise, it may trigger a heap page fault,
       which would call SuspendOthers, which requires an Activation. *)

    me.stackbase := ADR(xx);          (* enable GC scanning of this stack *)
    RunThread(me);
    me.stackbase := NIL;              (* disable GC scanning of my stack *)

    &lt;*ASSERT allThreads # me*&gt;
    DISPOSE (me);
    RETURN NIL;
  END ThreadBase;

PROCEDURE <A NAME="RunThread"><procedure>RunThread</procedure></A> (me: Activation) =
  VAR self: T;  cl: Closure;
  BEGIN
    WITH r = pthread_mutex_lock_slot() DO &lt;*ASSERT r=0*&gt; END;
      self := slots [me.slot];
    WITH r = pthread_mutex_unlock_slot() DO &lt;*ASSERT r=0*&gt; END;

    (* Let parent know we are running *)
    LOCK self DO
      cl := self.closure;
      self.closure := NIL;
      Signal(self.cond);
    END;

    (* Run the user-level code. *)
    IF perfOn THEN PerfRunning(self.id) END;
    self.result := cl.apply();
    IF perfOn THEN PerfChanged(self.id, State.dying) END;

    LOCK self DO
      (* mark &quot;self&quot; done and clean it up a bit *)
      self.completed := TRUE;
      Broadcast(self.cond); (* let everybody know that &quot;self&quot; is done *)
      pthread_cond_delete(self.waitCond);
      self.waitCond := NIL;
    END;

    IF perfOn THEN PerfDeleted(self.id) END;

    (* we're dying *)
    RTHeapRep.FlushThreadState(me.heapState);

    FreeSlot(self);  (* note: needs self.act ! *)
    (* Since we're no longer slotted, we cannot touch traced refs. *)

    (* remove ourself from the list of active threads *)
    WITH r = pthread_mutex_lock_active() DO &lt;*ASSERT r=0*&gt; END;
      &lt;*ASSERT allThreads # me*&gt;
      me.next.prev := me.prev;
      me.prev.next := me.next;
      me.next := NIL;
      me.prev := NIL;
      WITH r = Upthread.detach(me.handle) DO &lt;*ASSERT r=0*&gt; END;
    WITH r = pthread_mutex_unlock_active() DO &lt;*ASSERT r=0*&gt; END;
  END RunThread;

PROCEDURE <A NAME="Fork"><procedure>Fork</procedure></A> (closure: Closure): T =
  VAR
    act := NEW(Activation);
    t := CreateT(act);
    size := defaultStackSize;
  BEGIN
    (* determine the initial size of the stack for this thread *)
    TYPECASE closure OF
    | SizedClosure (scl) =&gt; size := scl.stackSize;
    ELSE (*skip*)
    END;

    WITH r = pthread_mutex_lock_active() DO &lt;*ASSERT r=0*&gt; END;
      t.closure := closure;
      t.id := nextId;  INC(nextId);
      IF perfOn THEN PerfChanged(t.id, State.alive) END;

      act.next := allThreads;
      act.prev := allThreads.prev;
      act.size := size;
      allThreads.prev.next := act;
      allThreads.prev := act;
      WITH r = thread_create(act.handle, size * ADRSIZE(Word.T), ThreadBase, act) DO
        IF r # 0 THEN
          RTError.MsgI(ThisFile(), ThisLine(),
                       &quot;Thread client error: Fork failed with error: &quot;, r);
        END;
      END;
    WITH r = pthread_mutex_unlock_active() DO &lt;*ASSERT r=0*&gt; END;
    LOCK t DO
      WHILE t.closure # NIL DO Wait(t, t.cond) END;
    END;
    RETURN t;
  END Fork;

PROCEDURE <A NAME="Join"><procedure>Join</procedure></A> (t: T): REFANY =
  VAR res: REFANY;
  BEGIN
    LOCK t DO
      IF t.cond = NIL THEN
        Die(ThisLine(), &quot;attempt to join with thread twice&quot;);
      END;
      WHILE NOT t.completed DO Wait(t, t.cond) END;
      res := t.result;
      t.result := NIL;
      t.cond := NIL;
      IF perfOn THEN PerfChanged(t.id, State.dead) END;
    END;
    RETURN res;
  END Join;

PROCEDURE <A NAME="AlertJoin"><procedure>AlertJoin</procedure></A> (t: T): REFANY RAISES {Alerted} =
  VAR res: REFANY;
  BEGIN
    LOCK t DO
      IF t.cond = NIL THEN
        Die(ThisLine(), &quot;attempt to join with thread twice&quot;);
      END;
      WHILE NOT t.completed DO AlertWait(t, t.cond) END;
      res := t.result;
      t.result := NIL;
      t.cond := NIL;
      IF perfOn THEN PerfChanged(t.id, State.dead) END;
    END;
    RETURN res;
  END AlertJoin;
</PRE>---------------------------------------------------- Scheduling support ---

<P><PRE>PROCEDURE <A NAME="ToNTime"><procedure>ToNTime</procedure></A> (n: LONGREAL; VAR ts: Utime.struct_timespec) =
  BEGIN
    ts.tv_sec := TRUNC(n);
    ts.tv_nsec := ROUND((n - FLOAT(ts.tv_sec, LONGREAL)) * 1.0D9);
  END ToNTime;

PROCEDURE <A NAME="XPause"><procedure>XPause</procedure></A> (self: T; n: LONGREAL; alertable: BOOLEAN) RAISES {Alerted} =
  VAR amount, remaining: Utime.struct_timespec;
  BEGIN
    IF n &lt;= 0.0d0 THEN RETURN END;
    ToNTime(n, amount);
    IF alertable AND XTestAlert(self) THEN RAISE Alerted END;
    LOOP
      WITH r = Utime.nanosleep(amount, remaining) DO
        IF alertable AND XTestAlert(self) THEN RAISE Alerted END;
        IF r = 0 THEN EXIT END;
        amount := remaining;
      END;
    END;
  END XPause;

PROCEDURE <A NAME="Pause"><procedure>Pause</procedure></A> (n: LONGREAL) =
  &lt;*FATAL Alerted*&gt;
  VAR self := Self();
  BEGIN
    IF self = NIL THEN
      Die(ThisLine(), &quot;Pause called from a non-Modula-3 thread&quot;);
    END;
    TRY
      IF perfOn THEN PerfChanged(self.id, State.pausing) END;
      XPause(self, n, alertable := FALSE);
    FINALLY
      IF perfOn THEN PerfRunning(self.id) END;
    END;
  END Pause;

PROCEDURE <A NAME="AlertPause"><procedure>AlertPause</procedure></A> (n: LONGREAL) RAISES {Alerted} =
  VAR self := Self();
  BEGIN
    IF self = NIL THEN
      Die(ThisLine(), &quot;AlertPause called from a non-Modula-3 thread&quot;);
    END;
    TRY
      IF perfOn THEN PerfChanged(self.id, State.pausing) END;
      XPause(self, n, alertable := TRUE);
    FINALLY
      IF perfOn THEN PerfRunning(self.id) END;
    END;
  END AlertPause;

PROCEDURE <A NAME="Yield"><procedure>Yield</procedure></A> () =
  BEGIN
    WITH r = Usched.yield() DO
      IF r # 0 THEN
        RTError.MsgI(ThisFile(), ThisLine(),
                     &quot;Thread client error: Yield failed with error: &quot;,
                     Cerrno.GetErrno());
      END;
    END;
  END Yield;

CONST FDSetSize = BITSIZE(INTEGER);

TYPE
  FDSet = SET OF [0 .. FDSetSize-1];
  FDS = REF ARRAY OF FDSet;

PROCEDURE <A NAME="IOWait"><procedure>IOWait</procedure></A> (fd: CARDINAL; read: BOOLEAN;
                  timeoutInterval: LONGREAL := -1.0D0): WaitResult =
  &lt;*FATAL Alerted*&gt;
  VAR self := Self();
  BEGIN
    TRY
      IF perfOn THEN PerfChanged(self.id, State.blocking) END;
      RETURN XIOWait(self, fd, read, timeoutInterval, alertable := FALSE);
    FINALLY
      IF perfOn THEN PerfRunning(self.id) END;
    END;
  END IOWait;

PROCEDURE <A NAME="IOAlertWait"><procedure>IOAlertWait</procedure></A> (fd: CARDINAL; read: BOOLEAN;
                       timeoutInterval: LONGREAL := -1.0D0): WaitResult
  RAISES {Alerted} =
  VAR self := Self();
  BEGIN
    TRY
      IF perfOn THEN PerfChanged(self.id, State.blocking) END;
      RETURN XIOWait(self, fd, read, timeoutInterval, alertable := TRUE);
    FINALLY
      IF perfOn THEN PerfRunning(self.id) END;
    END;
  END IOAlertWait;

PROCEDURE <A NAME="XIOWait"><procedure>XIOWait</procedure></A> (self: T; fd: CARDINAL; read: BOOLEAN; interval: LONGREAL;
                   alertable: BOOLEAN): WaitResult
  RAISES {Alerted} =
  VAR
    res: INTEGER;
    fdindex := fd DIV FDSetSize;
    fdset := FDSet{fd MOD FDSetSize};
    gReadFDS, gWriteFDS, gExceptFDS: FDS := NEW(FDS, fdindex+1);
    subInterval: LONGREAL := 1.0d0;

  PROCEDURE TestFDS (index: CARDINAL; set: FDSet; read: BOOLEAN): WaitResult =
    BEGIN
      IF (set * gExceptFDS[index]) # FDSet{} THEN
        IF read THEN
          IF (set * gReadFDS[index]) # FDSet{} THEN
            RETURN WaitResult.Ready;
          END;
          IF (set * gWriteFDS[index]) = FDSet{} THEN
            RETURN WaitResult.FDError;
          END;
        ELSE
          IF (set * gWriteFDS[index]) # FDSet{} THEN
            RETURN WaitResult.Ready;
          END;
          IF (set * gReadFDS[index]) = FDSet{} THEN
            RETURN WaitResult.FDError;
          END;
        END;
      END;
      RETURN WaitResult.Timeout;
    END TestFDS;

  PROCEDURE CallSelect (nfd: CARDINAL; timeout: UNTRACED REF UTime): INTEGER =
    TYPE FDSPtr = UNTRACED REF Unix.FDSet;
    VAR res: INTEGER;
    BEGIN
      FOR i := 0 TO fdindex DO
        gExceptFDS[i] := gReadFDS[i] + gWriteFDS[i];
      END;
      res := Unix.select(nfd,
                         LOOPHOLE (ADR(gReadFDS[0]), FDSPtr),
                         LOOPHOLE (ADR(gWriteFDS[0]), FDSPtr),
                         LOOPHOLE (ADR(gExceptFDS[0]), FDSPtr),
                         timeout);
      IF res &gt; 0 THEN
        FOR i := 0 TO fdindex DO
          gExceptFDS[i] := gExceptFDS[i] + gReadFDS[i] + gWriteFDS[i];
        END;
      END;
      RETURN res;
    END CallSelect;

  BEGIN
    IF NOT alertable THEN
      subInterval := interval;
    ELSIF interval &lt; 0.0d0 THEN
      interval := LAST(LONGREAL);
    ELSIF interval &lt; subInterval THEN
      subInterval := interval;
    END;

    IF alertable AND XTestAlert(self) THEN RAISE Alerted END;
    LOOP
      FOR i := 0 TO fdindex-1 DO
        gReadFDS[i] := FDSet{};
        gWriteFDS[i] := FDSet{};
      END;
      IF read
        THEN gReadFDS[fdindex] := fdset;
        ELSE gWriteFDS[fdindex] := fdset;
      END;

      IF subInterval &gt;= 0.0D0 THEN
        VAR utimeout := UTimeFromTime(subInterval);
        BEGIN
          res := CallSelect(fd+1, ADR(utimeout));
        END;
      ELSE
        res := CallSelect(fd+1, NIL);
      END;

      IF alertable AND XTestAlert(self) THEN RAISE Alerted END;

      IF    res &gt; 0 THEN RETURN TestFDS(fdindex, fdset, read);
      ELSIF res = 0 THEN
        interval := interval - subInterval;
        IF interval &lt;= 0.0d0 THEN RETURN WaitResult.Timeout END;
        IF interval &lt; subInterval THEN
          subInterval := interval;
        END;
      ELSE
        IF Cerrno.GetErrno() = Uerror.EINTR THEN
          (* spurious wakeups are OK *)
        ELSE
          RETURN WaitResult.Error;
        END;
      END;
    END;
  END XIOWait;

TYPE UTime = Utime.struct_timeval;

PROCEDURE <A NAME="UTimeFromTime"><procedure>UTimeFromTime</procedure></A> (time: Time.T): UTime =
  VAR floor := FLOOR(time);
  BEGIN
    RETURN UTime{floor, FLOOR(1.0D6 * (time - FLOAT(floor, LONGREAL)))};
  END UTimeFromTime;

PROCEDURE <A NAME="WaitProcess"><procedure>WaitProcess</procedure></A> (pid: int; VAR status: int): int =
  (* ThreadPThread.m3 and ThreadPosix.m3 are very similar. *)
  BEGIN
    LOOP
      WITH r = Uexec.waitpid(pid, ADR(status), 0) DO
        &lt;*ASSERT r # 0*&gt;
        IF r &gt; 0 THEN RETURN r END;
        IF Cerrno.GetErrno() # Uerror.EINTR THEN RETURN r END;
      END;
    END;
  END WaitProcess;
</PRE>--------------------------------------------------- Stack size controls ---

<P><PRE>VAR defaultStackSize := 4096;

PROCEDURE <A NAME="GetDefaultStackSize"><procedure>GetDefaultStackSize</procedure></A> (): CARDINAL =
  BEGIN
    RETURN defaultStackSize;
  END GetDefaultStackSize;

PROCEDURE <A NAME="MinDefaultStackSize"><procedure>MinDefaultStackSize</procedure></A> (size: CARDINAL) =
  BEGIN
    defaultStackSize := MAX(defaultStackSize, size);
  END MinDefaultStackSize;

PROCEDURE <A NAME="IncDefaultStackSize"><procedure>IncDefaultStackSize</procedure></A> (inc: CARDINAL) =
  BEGIN
    INC(defaultStackSize, inc);
  END IncDefaultStackSize;
</PRE>--------------------------------------------- Garbage collector support ---
 NOTE: These routines are called indirectly by the low-level page fault
   handler of the garbage collector.  So, if they touched traced references,
   they could trigger indefinite invocations of the fault handler. 

<P> In versions of SuspendOthers prior to the addition of the incremental
   collector, it acquired 'cm' to guarantee that no suspended thread held it.
   That way when the collector tried to acquire a mutex or signal a
   condition, it wouldn't deadlock with the suspended thread that held cm.
<P>
   With the VM-synchronized, incremental collector this design is inadequate.
   Here's a deadlock that occurred:
      Thread.Broadcast held cm,
      then it touched its condition argument,
      the page containing the condition was protected by the collector,
      another thread started running the page fault handler,
      the handler called SuspendOthers,
      SuspendOthers tried to acquire cm.
<P>
   So, SuspendOthers does not grab <CODE>cm</CODE> before shutting down the other
   threads.  If the collector tries to use any of the thread functions
   that acquire <CODE>cm</CODE>, it'll be deadlocked.


<P><PRE>VAR suspended: BOOLEAN := FALSE;	 (* LL=activeMu *)

PROCEDURE <A NAME="SuspendOthers"><procedure>SuspendOthers</procedure></A> () =
  (* LL=0. Always bracketed with ResumeOthers which releases &quot;activeMu&quot; *)
  BEGIN
    WITH r = pthread_mutex_lock_active() DO &lt;*ASSERT r=0*&gt; END;
    StopWorld();
    &lt;*ASSERT NOT suspended*&gt;
    suspended := TRUE;
  END SuspendOthers;

PROCEDURE <A NAME="ResumeOthers"><procedure>ResumeOthers</procedure></A> () =
  (* LL=activeMu.  Always preceded by SuspendOthers. *)
  BEGIN
    &lt;*ASSERT suspended*&gt;
    suspended := FALSE;
    StartWorld();
    WITH r = pthread_mutex_unlock_active() DO &lt;*ASSERT r=0*&gt; END;
  END ResumeOthers;

PROCEDURE <A NAME="ProcessStacks"><procedure>ProcessStacks</procedure></A> (p: PROCEDURE (start, stop: ADDRESS)) =
  (* LL=activeMu.  Only called within {SuspendOthers, ResumeOthers} *)
  VAR
    me := GetActivation();
    act: Activation;
  BEGIN
    ProcessMe(me, p);
    act := me.next;
    WHILE act # me DO
      ProcessOther(act, p);
      act := act.next;
    END;
  END ProcessStacks;

PROCEDURE <A NAME="ProcessEachStack"><procedure>ProcessEachStack</procedure></A> (p: PROCEDURE (start, stop: ADDRESS)) =
  (* LL=0 *)
  CONST
    WAIT_UNIT = 1000000;
  VAR
    me := GetActivation();
    act: Activation;
    acks: int;
    wait, remaining: Utime.struct_timespec;
  BEGIN
    WITH r = pthread_mutex_lock_active() DO &lt;*ASSERT r=0*&gt; END;

    ProcessMe(me, p);

    act := me.next;
    WHILE act # me DO
      (* stop *)
      LOOP
        IF StopThread(act) THEN EXIT END;
        IF SignalThread(act, ActState.Stopping) THEN
          WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
          IF acks &gt; 0 THEN
            WHILE sem_wait() # 0 DO
              &lt;*ASSERT Cerrno.GetErrno() = Uerror.EINTR*&gt;
            END;
            EXIT;
          END;
        END;
        wait.tv_sec := 0;
        wait.tv_nsec := WAIT_UNIT;
        WHILE Utime.nanosleep(wait, remaining) # 0 DO wait := remaining END;
      END;
      (* process *)
      ProcessOther(act, p);
      (* start *)
      LOOP
        IF StartThread(act) THEN EXIT END;
        IF SignalThread(act, ActState.Starting) THEN
          WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
          IF acks &gt; 0 THEN
            WHILE sem_wait() # 0 DO
              &lt;*ASSERT Cerrno.GetErrno() = Uerror.EINTR*&gt;
            END;
            EXIT;
          END;
        END;
        wait.tv_sec := 0;
        wait.tv_nsec := WAIT_UNIT;
        WHILE Utime.nanosleep(wait, remaining) # 0 DO wait := remaining END;
      END;
      act := act.next;
    END;

    WITH r = pthread_mutex_unlock_active() DO &lt;*ASSERT r=0*&gt; END;
  END ProcessEachStack;

PROCEDURE <A NAME="ProcessMe"><procedure>ProcessMe</procedure></A> (me: Activation;  p: PROCEDURE (start, stop: ADDRESS)) =
  (* LL=activeMu *)
  VAR
    sp: ADDRESS;
    state: RTMachine.State;
    xx: INTEGER;
  BEGIN
    &lt;*ASSERT me.state # ActState.Stopped*&gt;
    IF DEBUG THEN
      RTIO.PutText(&quot;Processing act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;
    (* process my registers *)
    IF RTMachine.SaveRegsInStack # NIL
      THEN sp := RTMachine.SaveRegsInStack();
      ELSE sp := ADR(xx);
    END;
    RTHeapRep.FlushThreadState(me.heapState);
    IF stack_grows_down
      THEN p(sp, me.stackbase);
      ELSE p(me.stackbase, sp);
    END;
    EVAL RTMachine.SaveState(state);
    WITH z = state DO p(ADR(z), ADR(z) + ADRSIZE(z)) END;
  END ProcessMe;

PROCEDURE <A NAME="ProcessOther"><procedure>ProcessOther</procedure></A> (act: Activation;  p: PROCEDURE (start, stop: ADDRESS)) =
  (* LL=activeMu *)
  VAR
    sp: ADDRESS;
    state: RTMachine.ThreadState;
  BEGIN
    &lt;*ASSERT act.state = ActState.Stopped*&gt;
    IF DEBUG THEN
      RTIO.PutText(&quot;Processing act=&quot;); RTIO.PutAddr(act); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;
    IF act.stackbase = NIL THEN RETURN END;
    IF RTMachine.GetState # NIL THEN
      (* process explicit state *)
      sp := RTMachine.GetState(act.handle, state);
    ELSE
      (* assume registers are saved in suspended thread's stack *)
      sp := act.sp;
    END;
    RTHeapRep.FlushThreadState(act.heapState);
    IF stack_grows_down
      THEN p(sp, act.stackbase);
      ELSE p(act.stackbase, sp);
    END;
    WITH z = state DO p(ADR(z), ADR(z) + ADRSIZE(z)) END;
  END ProcessOther;
</PRE> Signal based suspend/resume 

<P><PRE>PROCEDURE <A NAME="SignalThread"><procedure>SignalThread</procedure></A>(act: Activation; state: ActState): BOOLEAN =
  BEGIN
    IF SIG_SUSPEND = 0 THEN RETURN FALSE END;
    SetState(act, state);
    LOOP
      WITH z = Upthread.kill(act.handle, SIG_SUSPEND) DO
        IF z = 0 THEN RETURN TRUE END;
        &lt;*ASSERT z = Uerror.EAGAIN*&gt;
        (* try it again... *)
      END;
    END;
  END SignalThread;

PROCEDURE <A NAME="StopThread"><procedure>StopThread</procedure></A> (act: Activation): BOOLEAN =
  BEGIN
    &lt;*ASSERT act.state # ActState.Stopped*&gt;
    IF RTMachine.SuspendThread = NIL THEN RETURN FALSE END;
    SetState(act, ActState.Stopping);
    IF NOT RTMachine.SuspendThread(act.handle) THEN RETURN FALSE END;
    IF act.heapState.inCritical # 0 THEN
      RTMachine.RestartThread(act.handle);
      RETURN FALSE;
    END;
    act.state := ActState.Stopped;
    RETURN TRUE;
  END StopThread;

PROCEDURE <A NAME="StartThread"><procedure>StartThread</procedure></A> (act: Activation): BOOLEAN =
  BEGIN
    &lt;*ASSERT act.state = ActState.Stopped*&gt;
    IF RTMachine.RestartThread = NIL THEN RETURN FALSE END;
    SetState(act, ActState.Starting);
    RTMachine.RestartThread(act.handle);
    act.state := ActState.Started;
    RETURN TRUE;
  END StartThread;

PROCEDURE <A NAME="StopWorld"><procedure>StopWorld</procedure></A> () =
  (* LL=activeMu *)
  CONST
    WAIT_UNIT = 1000000;
    RETRY_INTERVAL = 10000000;
  VAR
    me := GetActivation();
    act: Activation;
    acks: int;
    nLive, newlySent: INTEGER;
    retry: BOOLEAN;
    wait_nsecs := RETRY_INTERVAL;
    wait, remaining: Utime.struct_timespec;
  BEGIN
    IF DEBUG THEN
      RTIO.PutText(&quot;Stopping from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;

    nLive := 0;
    LOOP
      retry := FALSE;
      act := me.next;
      WHILE act # me DO
        IF act.state # ActState.Stopped THEN
          IF StopThread(act) THEN
            (* good *)
          ELSIF SignalThread(act, ActState.Stopping) THEN
            INC(nLive);
          ELSE
            (* try again *)
            retry := TRUE;
          END;
        END;
        act := act.next;
      END;
      IF NOT retry THEN EXIT END;
      wait.tv_sec := 0;
      wait.tv_nsec := WAIT_UNIT;
      WHILE Utime.nanosleep(wait, remaining) # 0 DO
        wait := remaining;
      END;
    END;
    WHILE nLive &gt; 0 DO
      WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
      IF acks = nLive THEN EXIT END;
      &lt;*ASSERT acks &lt; nLive*&gt;
      IF wait_nsecs &lt;= 0 THEN
        newlySent := 0;
        act := me.next;
        WHILE act # me DO
          IF act.state = ActState.Stopped THEN
            (* good *)
          ELSIF SignalThread(act, ActState.Stopping) THEN
            INC(newlySent);
          ELSE
            &lt;*ASSERT FALSE*&gt;
          END;
          act := act.next;
        END;
        IF newlySent &lt; nLive - acks THEN
          (* how did we manage to lose some? *)
          nLive := acks + newlySent;
        END;
        wait_nsecs := RETRY_INTERVAL;
      ELSE
        wait.tv_sec := 0;
        wait.tv_nsec := WAIT_UNIT;
        WHILE Utime.nanosleep(wait, remaining) # 0 DO
          wait := remaining;
        END;
        DEC(wait_nsecs, WAIT_UNIT);
      END;
    END;
    (* drain semaphore *)
    FOR i := 0 TO nLive-1 DO
      LOOP
        WITH r = sem_wait() DO
          IF r = 0 THEN EXIT END;
          IF Cerrno.GetErrno() = Uerror.EINTR THEN
            (*retry*)
          ELSE
            &lt;*ASSERT FALSE*&gt;
          END;
        END;
      END;
    END;

    IF DEBUG THEN
      RTIO.PutText(&quot;Stopped from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;
  END StopWorld;

PROCEDURE <A NAME="StartWorld"><procedure>StartWorld</procedure></A> () =
  (* LL=activeMu *)
  CONST
    WAIT_UNIT = 1000000;
    RETRY_INTERVAL = 10000000;
  VAR
    me := GetActivation();
    act: Activation;
    acks: int;
    nDead, newlySent: INTEGER;
    retry: BOOLEAN;
    wait_nsecs := RETRY_INTERVAL;
    wait, remaining: Utime.struct_timespec;
  BEGIN
    IF DEBUG THEN
      RTIO.PutText(&quot;Starting from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;

    nDead := 0;
    LOOP
      retry := FALSE;
      act := me.next;
      WHILE act # me DO
        IF act.state # ActState.Started THEN
          IF StartThread(act) THEN
            (* good *)
          ELSIF SignalThread(act, ActState.Starting) THEN
            INC(nDead);
          ELSE
            (* try again *)
            retry := TRUE;
          END;
        END;
        act := act.next;
      END;
      IF NOT retry THEN EXIT END;
      wait.tv_sec := 0;
      wait.tv_nsec := WAIT_UNIT;
      WHILE Utime.nanosleep(wait, remaining) # 0 DO
        wait := remaining;
      END;
    END;
    WHILE nDead &gt; 0 DO
      WITH r = sem_getvalue(acks) DO &lt;*ASSERT r=0*&gt; END;
      IF acks = nDead THEN EXIT END;
      &lt;*ASSERT acks &lt; nDead*&gt;
      IF wait_nsecs &lt;= 0 THEN
        newlySent := 0;
        act := me.next;
        WHILE act # me DO
          IF act.state = ActState.Started THEN
            (* good *)
          ELSIF SignalThread(act, ActState.Starting) THEN
            INC(newlySent);
          ELSE
            &lt;*ASSERT FALSE*&gt;
          END;
          act := act.next;
        END;
        IF newlySent &lt; nDead - acks THEN
          (* how did we manage to lose some? *)
          nDead := acks + newlySent;
        END;
        wait_nsecs := RETRY_INTERVAL;
      ELSE
        wait.tv_sec := 0;
        wait.tv_nsec := WAIT_UNIT;
        WHILE Utime.nanosleep(wait, remaining) # 0 DO
          wait := remaining;
        END;
        DEC(wait_nsecs, WAIT_UNIT);
      END;
    END;
    (* drain semaphore *)
    FOR i := 0 TO nDead-1 DO
      LOOP
        WITH r = sem_wait() DO
          IF r = 0 THEN EXIT END;
          IF Cerrno.GetErrno() = Uerror.EINTR THEN
            (*retry*)
          ELSE
            &lt;*ASSERT FALSE*&gt;
          END;
        END;
      END;
    END;

    IF DEBUG THEN
      RTIO.PutText(&quot;Started from act=&quot;); RTIO.PutAddr(me); RTIO.PutText(&quot;\n&quot;); RTIO.Flush();
    END;
  END StartWorld;

PROCEDURE <A NAME="SignalHandler"><procedure>SignalHandler</procedure></A> (sig: int; &lt;*UNUSED*&gt; sip, uap: ADDRESS) =
  VAR
    errno := Cerrno.GetErrno();
    xx: INTEGER;
    me := GetActivation();
  BEGIN
    &lt;*ASSERT sig = SIG_SUSPEND*&gt;
    IF me # NIL
      AND me.state = ActState.Stopping
      AND me.heapState.inCritical = 0 THEN
      IF RTMachine.SaveRegsInStack # NIL
        THEN me.sp := RTMachine.SaveRegsInStack();
        ELSE me.sp := ADR(xx);
      END;
      me.state := ActState.Stopped;
      WITH r = sem_post() DO &lt;*ASSERT r=0*&gt; END;
      REPEAT EVAL sigsuspend() UNTIL me.state = ActState.Starting;
      me.sp := NIL;
      me.state := ActState.Started;
      WITH r = sem_post() DO &lt;*ASSERT r=0*&gt; END;
    END;
    Cerrno.SetErrno(errno);
  END SignalHandler;
</PRE>----------------------------------------------------------- misc. stuff ---

<P><PRE>PROCEDURE <A NAME="MyId"><procedure>MyId</procedure></A> (): Id RAISES {} =
  VAR self := Self();
  BEGIN
    RETURN self.id;
  END MyId;

PROCEDURE <A NAME="GetMyFPState"><procedure>GetMyFPState</procedure></A> (reader: PROCEDURE(READONLY s: FloatMode.ThreadState)) =
  VAR me := GetActivation();
  BEGIN
    reader(me.floatState);
  END GetMyFPState;

PROCEDURE <A NAME="SetMyFPState"><procedure>SetMyFPState</procedure></A> (writer: PROCEDURE(VAR s: FloatMode.ThreadState)) =
  VAR me := GetActivation();
  BEGIN
    writer(me.floatState);
  END SetMyFPState;

PROCEDURE <A NAME="MyHeapState"><procedure>MyHeapState</procedure></A> (): UNTRACED REF RTHeapRep.ThreadState =
  VAR me := GetActivation();
  BEGIN
    RETURN ADR(me.heapState);
  END MyHeapState;

PROCEDURE <A NAME="DisableSwitching"><procedure>DisableSwitching</procedure></A> () =
  BEGIN
    (* no user-level thread switching *)
  END DisableSwitching;

PROCEDURE <A NAME="EnableSwitching"><procedure>EnableSwitching</procedure></A> () =
  BEGIN
    (* no user-level thread switching *)
  END EnableSwitching;
</PRE>---------------------------------------------------------------- errors ---

<P><PRE>PROCEDURE <A NAME="Die"><procedure>Die</procedure></A> (lineno: INTEGER; msg: TEXT) =
  BEGIN
    RTError.Msg (ThisFile(), lineno, &quot;Thread client error: &quot;, msg);
  END Die;
</PRE>------------------------------------------------------ ShowThread hooks ---

<P><PRE>VAR
  perfW : RTPerfTool.Handle;
  perfOn: BOOLEAN := FALSE;		 (* LL = perfMu *)

PROCEDURE <A NAME="PerfStart"><procedure>PerfStart</procedure></A> () =
  BEGIN
    IF RTPerfTool.Start (&quot;showthread&quot;, perfW) THEN
      perfOn := TRUE;
      RTProcess.RegisterExitor (PerfStop);
    END;
  END PerfStart;

PROCEDURE <A NAME="PerfStop"><procedure>PerfStop</procedure></A> () =
  BEGIN
    (* UNSAFE, but needed to prevent deadlock if we're crashing! *)
    RTPerfTool.Close (perfW);
  END PerfStop;

CONST
  EventSize = (BITSIZE(ThreadEvent.T) + BITSIZE(CHAR) - 1) DIV BITSIZE(CHAR);

TYPE
  TE = ThreadEvent.Kind;

PROCEDURE <A NAME="PerfChanged"><procedure>PerfChanged</procedure></A> (id: Id; s: State) =
  VAR e := ThreadEvent.T {kind := TE.Changed, id := id, state := s};
  BEGIN
    WITH r = pthread_mutex_lock_perf() DO &lt;*ASSERT r=0*&gt; END;
      perfOn := RTPerfTool.Send (perfW, ADR (e), EventSize);
    WITH r = pthread_mutex_unlock_perf() DO &lt;*ASSERT r=0*&gt; END;
  END PerfChanged;

PROCEDURE <A NAME="PerfDeleted"><procedure>PerfDeleted</procedure></A> (id: Id) =
  VAR e := ThreadEvent.T {kind := TE.Deleted, id := id};
  BEGIN
    WITH r = pthread_mutex_lock_perf() DO &lt;*ASSERT r=0*&gt; END;
      perfOn := RTPerfTool.Send (perfW, ADR (e), EventSize);
    WITH r = pthread_mutex_unlock_perf() DO &lt;*ASSERT r=0*&gt; END;
  END PerfDeleted;

PROCEDURE <A NAME="PerfRunning"><procedure>PerfRunning</procedure></A> (id: Id) =
  VAR e := ThreadEvent.T {kind := TE.Running, id := id};
  BEGIN
    WITH r = pthread_mutex_lock_perf() DO &lt;*ASSERT r=0*&gt; END;
      perfOn := RTPerfTool.Send (perfW, ADR (e), EventSize);
    WITH r = pthread_mutex_unlock_perf() DO &lt;*ASSERT r=0*&gt; END;
  END PerfRunning;
</PRE>-------------------------------------------------------- Initialization ---

<P><PRE>PROCEDURE <A NAME="Init"><procedure>Init</procedure></A> ()=
  VAR
    xx: INTEGER;
    self: T;
    me := InitActivations();
  BEGIN
    IF RTMachine.SuspendThread = NIL OR RTMachine.RestartThread = NIL THEN
      &lt;*ASSERT RTMachine.SuspendThread = NIL*&gt;
      &lt;*ASSERT RTMachine.RestartThread = NIL*&gt;
      SetupHandlers();
    END;

    (* cm, activeMu, slotMu: initialized statically *)
    self := CreateT(me);
    self.id := nextId;  INC(nextId);

    stack_grows_down := ADR(xx) &gt; XX();

    WITH r = pthread_mutex_lock_active() DO &lt;*ASSERT r=0*&gt; END;
      me.stackbase := ADR(xx);
    WITH r = pthread_mutex_unlock_active() DO &lt;*ASSERT r=0*&gt; END;
    PerfStart();
    IF perfOn THEN PerfRunning(self.id) END;
    IF RTParams.IsPresent(&quot;backgroundgc&quot;) THEN
      RTCollectorSRC.StartBackgroundCollection();
    END;
    IF RTParams.IsPresent(&quot;foregroundgc&quot;) THEN
      RTCollectorSRC.StartForegroundCollection();
    END;
  END Init;

PROCEDURE <A NAME="XX"><procedure>XX</procedure></A> (): ADDRESS =
  VAR xx: INTEGER;
  BEGIN
    RETURN ADR(xx);
  END XX;
</PRE>------------------------------------------------------------- collector ---
 These procedures provide synchronization primitives for the allocator
   and collector. 

<P><PRE>VAR
  holder: ADDRESS;
  inCritical := 0;

PROCEDURE <A NAME="LockHeap"><procedure>LockHeap</procedure></A> (VAR me: RTHeapRep.ThreadState) =
  BEGIN
    IF holder # ADR(me) THEN
      WITH r = pthread_mutex_lock_heap() DO &lt;*ASSERT r=0*&gt; END;
      holder := ADR(me);
    END;
    INC(inCritical);
    INC(me.inCritical);
  END LockHeap;

PROCEDURE <A NAME="UnlockHeap"><procedure>UnlockHeap</procedure></A> (VAR me: RTHeapRep.ThreadState) =
  BEGIN
    &lt;*ASSERT holder = ADR(me)*&gt;
    DEC(me.inCritical);
    DEC(inCritical);
    IF inCritical = 0 THEN
      holder := NIL;
      WITH r = pthread_mutex_unlock_heap() DO &lt;*ASSERT r=0*&gt; END;
    END;
  END UnlockHeap;

PROCEDURE <A NAME="WaitHeap"><procedure>WaitHeap</procedure></A> (VAR me: RTHeapRep.ThreadState) =
  BEGIN
    &lt;*ASSERT holder = ADR(me)*&gt;
    DEC(me.inCritical);
    DEC(inCritical);
    &lt;*ASSERT inCritical = 0*&gt;
    WITH r = pthread_cond_wait_heap() DO &lt;*ASSERT r=0*&gt; END;
    holder := ADR(me);
    &lt;*ASSERT inCritical = 0*&gt;
    INC(inCritical);
    INC(me.inCritical);
  END WaitHeap;

PROCEDURE <A NAME="BroadcastHeap"><procedure>BroadcastHeap</procedure></A> () =
  BEGIN
    WITH r = pthread_cond_broadcast_heap() DO &lt;*ASSERT r=0*&gt; END;
  END BroadcastHeap;
</PRE>--------------------------------------------- exception handling support --

<P><PRE>PROCEDURE <A NAME="GetCurrentHandlers"><procedure>GetCurrentHandlers</procedure></A> (): ADDRESS =
  BEGIN
    WITH me = GetActivation() DO
      RETURN me.frame;
    END;
  END GetCurrentHandlers;

PROCEDURE <A NAME="SetCurrentHandlers"><procedure>SetCurrentHandlers</procedure></A> (h: ADDRESS) =
  BEGIN
    WITH me = GetActivation() DO
      me.frame := h;
    END;
  END SetCurrentHandlers;
</PRE>RTHooks.PushEFrame
<PRE>PROCEDURE <A NAME="PushEFrame"><procedure>PushEFrame</procedure></A> (frame: ADDRESS) =
  TYPE Frame = UNTRACED REF RECORD next: ADDRESS END;
  VAR f: Frame := frame;
  BEGIN
    WITH me = GetActivation() DO
      f.next := me.frame;
      me.frame := f;
    END;
  END PushEFrame;
</PRE>RTHooks.PopEFrame
<PRE>PROCEDURE <A NAME="PopEFrame"><procedure>PopEFrame</procedure></A> (frame: ADDRESS) =
  BEGIN
    WITH me = GetActivation() DO
      me.frame := frame;
    END;
  END PopEFrame;

VAR DEBUG := RTParams.IsPresent(&quot;debugthreads&quot;);

BEGIN
END ThreadPThread.
</PRE>
</inModule>
<HR>
<A NAME="x1">interface RTMachine is in:
</A><UL>
<LI><A HREF="../../runtime/AMD64_LINUX/RTMachine.i3.html#0TOP0">m3core/src/runtime/AMD64_LINUX/RTMachine.i3</A>
<LI><A HREF="../../runtime/common/RTMachine.i3.html#0TOP0">m3core/src/runtime/common/RTMachine.i3</A>
</UL>
<P>
<HR>
<A NAME="x2">interface Unix is in:
</A><UL>
<LI><A HREF="../../unix/Common/Unix.i3.html#0TOP0">m3core/src/unix/Common/Unix.i3</A>
<LI><A HREF="../../unix/linux-common/Unix.i3.html#0TOP0">m3core/src/unix/linux-common/Unix.i3</A>
</UL>
<P>
<HR>
<A NAME="x3">interface Utime is in:
</A><UL>
<LI><A HREF="../../unix/Common/Utime.i3.html#0TOP0">m3core/src/unix/Common/Utime.i3</A>
<LI><A HREF="../../unix/linux-common/Utime.i3.html#0TOP0">m3core/src/unix/linux-common/Utime.i3</A>
</UL>
<P>
<HR>
<A NAME="x4">interface Upthread is in:
</A><UL>
<LI><A HREF="../../unix/Common/Upthread.i3.html#0TOP0">m3core/src/unix/Common/Upthread.i3</A>
<LI><A HREF="../../unix/linux-common/Upthread.i3.html#0TOP0">m3core/src/unix/linux-common/Upthread.i3</A>
</UL>
<P>
<HR>
<A NAME="x5">interface Usched is in:
</A><UL>
<LI><A HREF="../../unix/Common/Usched.i3.html#0TOP0">m3core/src/unix/Common/Usched.i3</A>
<LI><A HREF="../../unix/linux-common/Usched.i3.html#0TOP0">m3core/src/unix/linux-common/Usched.i3</A>
</UL>
<P>
<HR>
<A NAME="x6">interface Uerror is in:
</A><UL>
<LI><A HREF="../../unix/Common/Uerror.i3.html#0TOP0">m3core/src/unix/Common/Uerror.i3</A>
<LI><A HREF="../../unix/linux-common/Uerror.i3.html#0TOP0">m3core/src/unix/linux-common/Uerror.i3</A>
</UL>
<P>
<HR>
<A NAME="x7">interface Uexec is in:
</A><UL>
<LI><A HREF="../../unix/Common/Uexec.i3.html#0TOP0">m3core/src/unix/Common/Uexec.i3</A>
<LI><A HREF="../../unix/linux-common/Uexec.i3.html#0TOP0">m3core/src/unix/linux-common/Uexec.i3</A>
</UL>
<P>
<PRE>























</PRE>
</BODY>
</HTML>
