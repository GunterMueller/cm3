<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3core/src/runtime/POSIX/RTOS.m3</TITLE>
</HEAD>
<BODY bgcolor="#eeeeee">
<A NAME="0TOP0">
<H2>m3core/src/runtime/POSIX/RTOS.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1994, Digital Equipment Corporation           
 All rights reserved.                                        
 See the file COPYRIGHT for a full description.              
 Last modified on Fri Nov 18 16:00:55 PST 1994 by kalsow     
      modified on Wed Jan 27 22:49:37 PST 1993 by mjordan    

<P><PRE>UNSAFE MODULE <module><implements><A HREF="../common/RTOS.i3.html">RTOS</A></implements></module>;

IMPORT <A HREF="../../unix/linux-libc6/Unix.i3.html">Unix</A>, <A HREF="../../unix/linux-libc6/Uuio.i3.html">Uuio</A>, <A HREF="../../C/Common/Cstdlib.i3.html">Cstdlib</A>, <A HREF="RT0u.i3.html">RT0u</A>, <A HREF="../../thread/Common/Thread.i3.html">Thread</A>;
IMPORT <A HREF="../common/RTIO.i3.html">RTIO</A>, <A HREF="../common/RTParams.i3.html">RTParams</A>;

VAR
  debugAlloc := FALSE;
  use_sbrk   := FALSE;
</PRE>--------------------------------------------------- process termination ---

<P><PRE>PROCEDURE <A NAME="Exit"><procedure>Exit</procedure></A> (n: INTEGER) =
  BEGIN
    Unix.exit (n);
  END Exit;

PROCEDURE <A NAME="Crash"><procedure>Crash</procedure></A> () =
  BEGIN
    Cstdlib.abort ();
    LOOP END; (* wait *)
  END Crash;
</PRE>------------------------------------------------------------- allocator ---

<P><PRE>PROCEDURE <A NAME="GetMemory"><procedure>GetMemory</procedure></A> (size: INTEGER): ADDRESS =
  (* Return the address of &quot;size&quot; bytes of unused storage *)
  (* It seems that on modern Unix systems sbrk is considered to be
     an anachronism that is supported for compatibility reasons at least,
     The 4.4BSD manual page says:

     The brk() and sbrk() functions are legacy interfaces from before the
     advent of modern virtual memory management.

     Indeed, on some systems (like Darwin), sbrk is not supported at all,
     i.e. its implementation is broken or it is not implemented at all.
     So I think it may be time to switch to malloc even for the traced
     heap. If we need the old behaviour on some systems, we must
     introduce another Target parameter. (ow 2003-02-02)
  *)
  VAR res : ADDRESS;
  BEGIN
    IF use_sbrk THEN
      res := LOOPHOLE(Unix.sbrk(size), ADDRESS);
    ELSE
      LockHeap();
      res := LOOPHOLE(Cstdlib.malloc(size), ADDRESS);
      UnlockHeap();
    END;
    IF debugAlloc THEN
      RTIO.PutText(&quot;GetMemory(&quot;);
      RTIO.PutInt(size, 0);
      RTIO.PutText(&quot;) --&gt; &quot;);
      RTIO.PutAddr(res, 0);
      RTIO.PutText(&quot;\r\n&quot;);
      RTIO.Flush();
    END;
    RETURN res;
  END GetMemory;
</PRE>------------------------------------------------------------- collector ---
 These procedures provide synchronization primitives for the allocator
   and collector.  This is the Ultrix version, and depends on the Ultrix
   user-level thread implementation. 

<P> LockHeap() enters a critical section; the same thread may enter the
   critical section multiple times.  It could be written at user level
   as:
<P>
<PRE>
      VAR
        mutex    : MUTEX            := NEW(MUTEX);
        condition: Thread.Condition := NEW(Thread.Condition);
        thread   : Thread.T         := NIL;
        count    : CARDINAL         := 0;
</PRE>
<PRE>
      PROCEDURE LockHeap () =
        BEGIN
          LOCK mutex DO
            IF count = 0 THEN
              thread := Thread.Self();
              INC(count);
            ELSIF thread = Thread.Self() THEN
              INC(count);
            ELSE
              Thread.Wait(mutex, condition);
            END;
          END;
        END LockHeap;
</PRE>
   However, it must be possible to call it from anywhere in the
   collector. 

<P> UnlockHeap() leaves the critical section.  It could be written at user
   level as:
<P>
<PRE>
      PROCEDURE UnlockHeap () =
        BEGIN
          LOCK mutex DO DEC(count); END;
          IF count = 0 THEN Thread.Signal(condition); END;
        END UnlockHeap;
</PRE>
   However, it must be possible to call it from anywhere inside the
   collector. 

<P><PRE>VAR
  lock_cnt  := 0;      (* LL = RT0u.inCritical *)
  do_signal := FALSE;  (* LL = RT0u.inCritical *)
  mutex     := NEW(MUTEX);
  condition := NEW(Thread.Condition);

PROCEDURE <A NAME="LockHeap"><procedure>LockHeap</procedure></A> () =
  BEGIN
    INC(RT0u.inCritical);
    INC(lock_cnt);
  END LockHeap;

PROCEDURE <A NAME="UnlockHeap"><procedure>UnlockHeap</procedure></A> () =
  VAR sig := FALSE;
  BEGIN
    DEC(lock_cnt);
    IF (lock_cnt = 0) AND (do_signal) THEN sig := TRUE; do_signal := FALSE; END;
    DEC(RT0u.inCritical);
    IF (sig) THEN Thread.Broadcast(condition); END;
  END UnlockHeap;

PROCEDURE <A NAME="WaitHeap"><procedure>WaitHeap</procedure></A> () =
  (* LL = 0 *)
  BEGIN
    LOCK mutex DO Thread.Wait(mutex, condition); END;
  END WaitHeap;

PROCEDURE <A NAME="BroadcastHeap"><procedure>BroadcastHeap</procedure></A> () =
  (* LL = RT0u.inCritical *)
  BEGIN
    do_signal := TRUE;
  END BroadcastHeap;
</PRE>------------------------------------------------------------------- I/O ---

<P><PRE>PROCEDURE <A NAME="Write"><procedure>Write</procedure></A> (a: ADDRESS;  n: INTEGER) =
  BEGIN
    EVAL Uuio.write (2, a, n);
  END Write;

BEGIN
  IF RTParams.IsPresent(&quot;alloc&quot;) THEN debugAlloc := TRUE; END;
END RTOS.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
