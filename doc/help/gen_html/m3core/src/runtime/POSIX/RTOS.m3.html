<HTML>
<HEAD>
<TITLE>Critical Mass Modula-3: m3core/src/runtime/POSIX/RTOS.m3</TITLE>
</HEAD>
<BODY bgcolor="#eeeeee">
<A NAME="0TOP0">
<H2>m3core/src/runtime/POSIX/RTOS.m3</H2></A><HR>
<inModule>
<PRE></PRE> Copyright (C) 1994, Digital Equipment Corporation           
 All rights reserved.                                        
 See the file COPYRIGHT for a full description.              
 Last modified on Fri Nov 18 16:00:55 PST 1994 by kalsow     
      modified on Wed Jan 27 22:49:37 PST 1993 by mjordan    

<P><PRE>UNSAFE MODULE <module><implements><A HREF="../common/RTOS.i3.html">RTOS</A></implements></module>;

IMPORT <A HREF="../../unix/freebsd-3/Unix.i3.html">Unix</A>, <A HREF="../../unix/freebsd-3/Uuio.i3.html">Uuio</A>, <A HREF="../../C/Common/Cstdlib.i3.html">Cstdlib</A>, <A HREF="RT0u.i3.html">RT0u</A>, <A HREF="../../thread/Common/Thread.i3.html">Thread</A>;
</PRE>--------------------------------------------------- process termination ---

<P><PRE>PROCEDURE <A NAME="Exit"><procedure>Exit</procedure></A> (n: INTEGER) =
  BEGIN
    Unix.exit (n);
  END Exit;

PROCEDURE <A NAME="Crash"><procedure>Crash</procedure></A> () =
  BEGIN
    Cstdlib.abort ();
    LOOP END; (* wait *)
  END Crash;
</PRE>------------------------------------------------------------- allocator ---

<P><PRE>PROCEDURE <A NAME="GetMemory"><procedure>GetMemory</procedure></A> (size: INTEGER): ADDRESS =
  (* Return the address of &quot;size&quot; bytes of unused storage *)
  BEGIN
    RETURN LOOPHOLE(Unix.sbrk(size), ADDRESS);
  END GetMemory;
</PRE>------------------------------------------------------------- collector ---
 These procedures provide synchronization primitives for the allocator
   and collector.  This is the Ultrix version, and depends on the Ultrix
   user-level thread implementation. 

<P> LockHeap() enters a critical section; the same thread may enter the
   critical section multiple times.  It could be written at user level
   as:
<P>
<PRE>
      VAR
        mutex    : MUTEX            := NEW(MUTEX);
        condition: Thread.Condition := NEW(Thread.Condition);
        thread   : Thread.T         := NIL;
        count    : CARDINAL         := 0;
</PRE>
<PRE>
      PROCEDURE LockHeap () =
        BEGIN
          LOCK mutex DO
            IF count = 0 THEN
              thread := Thread.Self();
              INC(count);
            ELSIF thread = Thread.Self() THEN
              INC(count);
            ELSE
              Thread.Wait(mutex, condition);
            END;
          END;
        END LockHeap;
</PRE>
   However, it must be possible to call it from anywhere in the
   collector. 

<P> UnlockHeap() leaves the critical section.  It could be written at user
   level as:
<P>
<PRE>
      PROCEDURE UnlockHeap () =
        BEGIN
          LOCK mutex DO DEC(count); END;
          IF count = 0 THEN Thread.Signal(condition); END;
        END UnlockHeap;
</PRE>
   However, it must be possible to call it from anywhere inside the
   collector. 

<P><PRE>VAR
  lock_cnt  := 0;      (* LL = RT0u.inCritical *)
  do_signal := FALSE;  (* LL = RT0u.inCritical *)
  mutex     := NEW(MUTEX);
  condition := NEW(Thread.Condition);

PROCEDURE <A NAME="LockHeap"><procedure>LockHeap</procedure></A> () =
  BEGIN
    INC(RT0u.inCritical);
    INC(lock_cnt);
  END LockHeap;

PROCEDURE <A NAME="UnlockHeap"><procedure>UnlockHeap</procedure></A> () =
  VAR sig := FALSE;
  BEGIN
    DEC(lock_cnt);
    IF (lock_cnt = 0) AND (do_signal) THEN sig := TRUE; do_signal := FALSE; END;
    DEC(RT0u.inCritical);
    IF (sig) THEN Thread.Broadcast(condition); END;
  END UnlockHeap;

PROCEDURE <A NAME="WaitHeap"><procedure>WaitHeap</procedure></A> () =
  (* LL = 0 *)
  BEGIN
    LOCK mutex DO Thread.Wait(mutex, condition); END;
  END WaitHeap;

PROCEDURE <A NAME="BroadcastHeap"><procedure>BroadcastHeap</procedure></A> () =
  (* LL = RT0u.inCritical *)
  BEGIN
    do_signal := TRUE;
  END BroadcastHeap;
</PRE>------------------------------------------------------------------- I/O ---

<P><PRE>PROCEDURE <A NAME="Write"><procedure>Write</procedure></A> (a: ADDRESS;  n: INTEGER) =
  BEGIN
    EVAL Uuio.write (2, a, n);
  END Write;

BEGIN
END RTOS.
</PRE>
</inModule>
<PRE>























</PRE>
</BODY>
</HTML>
