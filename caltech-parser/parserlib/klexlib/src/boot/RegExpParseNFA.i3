INTERFACE RegExpParseNFA;
(* generated by kext *)
(* extended parser definition *)
IMPORT RegExpParse;
IMPORT RegExpLexStd;
IMPORT NFA;
TYPE
  expr = RegExpParse.expr BRANDED "RegExpParseNFA.expr" OBJECT
    val: NFA.T
  END;
  COUNT = RegExpLexStd.COUNT;
  CHAR_RANGE = RegExpLexStd.CHAR_RANGE;
  STRING = RegExpLexStd.STRING;
  IDENTIFIER = RegExpLexStd.IDENTIFIER;

  T <: Public;
  Public = RegExpParse.T OBJECT
  METHODS
    init(): T;
    parseText(t: TEXT): NFA.T;
    putMacro(name: TEXT; n: NFA.T);
  END;

  (* And now, for a hack to allow compatible methods *)
  (* ... without importing the original parser *)
  Original_Parser = RegExpParse.Original_Parser;
  Original_expr = RegExpParse.Original_expr;
  (* ... and without importing the original token *)
  Original_COUNT = RegExpParse.Original_COUNT;
  Original_IDENTIFIER = RegExpParse.Original_IDENTIFIER;
  Original_CHAR_RANGE = RegExpParse.Original_CHAR_RANGE;
  Original_STRING = RegExpParse.Original_STRING;

  (* Make this interface as good as any token interface *)
  Token = RegExpLexStd.Token;
  ConstToken = RegExpLexStd.ConstToken;
  ParseType = RegExpLexStd.ParseType;
  Allocator = RegExpLexStd.Allocator;
  Lexer = RegExpLexStd.Lexer;
  RdLexer = RegExpLexStd.RdLexer;
CONST
  NewPT = RegExpLexStd.NewPT;
  Purge = RegExpLexStd.Purge;
  NewConstToken = RegExpLexStd.NewConstToken;
END RegExpParseNFA.
