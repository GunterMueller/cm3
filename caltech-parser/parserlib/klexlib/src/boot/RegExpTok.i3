INTERFACE RegExpTok;
(* Generated by ktok *)
(* original token definition *)
IMPORT Rd;
TYPE
  ParseType <: ParseTypePublic;
  Token = ParseType BRANDED "RegExpTok.Token" OBJECT END;

  Lexer = OBJECT METHODS
    get(): Token RAISES {Rd.EndOfFile};
    (* get next token, or raise Rd.EndOfFile if token cannot be formed
       from remaining input *)

    unget();
    (* will be called at most once after get(), and only when lookahead is
       required after last token when parsing without exhausting input *)

    error(message: TEXT);
    (* might print file name, line number, and message, and exit *)
  END;

  RdLexer = Lexer OBJECT METHODS
    init(rd: Rd.T): RdLexer;
    (* prepare to read tokens starting at cur(rd).
       reader is always positionned after last gotten token *)
    
    rewind();
    (* equivalent to Rd.Seek(rd, 0) followed by init(rd) again *) 

    fromText(t: TEXT): Lexer;
    (* calls init with a textReader *)

    getRd(): Rd.T;
    (* get reader  *)

    getText(): TEXT;
    (* get TEXT of last token *)

    purge(): INTEGER;
    (* Allow any internally allocated ParseTypes to be garbage collected,
       even if the lexer itself remains in scope. Return number of ParseType
       objects allocated but not discarded (not the number of purged objects).
       Can be called at any time by the thread calling get. *)
  END;

  (* token types *)
  ConstTokenCode = [1..256]; (* < 256 means char code *)
  ConstToken = Token BRANDED "RegExpTok.ConstToken" OBJECT
    val: ConstTokenCode;
  END; (* neither extend this object nor reassign val *)
  COUNT = Token BRANDED "RegExpTok.COUNT" OBJECT END;
  IDENTIFIER = Token BRANDED "RegExpTok.IDENTIFIER" OBJECT END;
  CHAR_RANGE = Token BRANDED "RegExpTok.CHAR_RANGE" OBJECT END;
  STRING = Token BRANDED "RegExpTok.STRING" OBJECT END;

  (* ParseType allocation *)
  Allocator = BRANDED "RegExpTok.Allocator" OBJECT END;
  ParseTypePublic = OBJECT METHODS
    discard();
    detach(): ParseType;
  END;

CONST
  LegalConstTokenCodes = SET OF ConstTokenCode{
    10, 40, 41, 42, 43, 45, 63, 91, 93, 94, 124, 256};
    ERROR = 256;

PROCEDURE NewPT(VAR a: Allocator; m3type: INTEGER): ParseType;
(* IF a = NIL, then let a = new allocator for m3type.
   regardless, return a new ParseType specifically of type m3type *)

PROCEDURE Purge(VAR a: Allocator): INTEGER;
(* set a=NIL. return number of objects allocated using
   New(a, ...) which were not discarded using discard(). *)

PROCEDURE NewConstToken(val: ConstTokenCode): ConstToken;
(* return a constToken with val=val (well it might not be so new) *)
(* discard() will fail for a constToken *)

PROCEDURE Test(lex: Lexer);
(* get tokens and print their names to stdout until Rd.EndOfFile *)

END RegExpTok.
