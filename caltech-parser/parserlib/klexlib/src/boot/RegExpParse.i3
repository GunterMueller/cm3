INTERFACE RegExpParse;
(* Generated by kyacc *)
(* original parser definition *)
IMPORT RegExpTok;
TYPE
  (* additional parse types *)
  StartType = RegExpTok.ParseType BRANDED "RegExpParse.StartType" OBJECT END;
  OtherType = RegExpTok.ParseType;
  expr = StartType BRANDED "RegExpParse.expr" OBJECT END;

  (* import tokens *)
  ConstToken = RegExpTok.ConstToken;
  COUNT = RegExpTok.COUNT;
  IDENTIFIER = RegExpTok.IDENTIFIER;
  CHAR_RANGE = RegExpTok.CHAR_RANGE;
  STRING = RegExpTok.STRING;

  (* the parser *)
  T <: Public;
  Public = OBJECT
  METHODS
    setLex(lex: RegExpTok.Lexer): T;
    parse(exhaustInput: BOOLEAN := TRUE): StartType;

    (* rules *)
    paren_expr(VAR result: expr; p1: expr);
    concat_expr(VAR result: expr; p1: expr; p2: expr);
    or_expr(VAR result: expr; p1: expr; p2: expr);
    plus_expr(VAR result: expr; p1: expr);
    star_expr(VAR result: expr; p1: expr);
    quest_expr(VAR result: expr; p1: expr);
    repeat_expr(VAR result: expr; p1: expr; p2: COUNT);
    ident_expr(VAR result: expr; p1: IDENTIFIER);
    string_expr(VAR result: expr; p1: STRING);
    charRange_expr(VAR result: expr; p1: CHAR_RANGE);

    purge(): INTEGER;
    (* Allow any internally allocated ParseTypes to be garbage collected,
       even if the parser itself remains in scope. Return number of ParseType
       objects allocated but not discarded (not the number of purged objects).
       Can be called at any time by the thread calling get. *)
  END;

  (* And now, for a hack to allow compatible methods *)
  (* ... without importing the original parser *)
  Original_Parser = T;
  Original_expr = expr;
  (* ... and without importing the original token *)
  Original_COUNT = COUNT;
  Original_IDENTIFIER = IDENTIFIER;
  Original_CHAR_RANGE = CHAR_RANGE;
  Original_STRING = STRING;

END RegExpParse.
