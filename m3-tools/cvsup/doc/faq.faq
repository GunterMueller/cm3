!# Copyright 1998-2003 John D. Polstra.
!# All rights reserved.
!#
!# Redistribution and use in source and binary forms, with or without
!# modification, are permitted provided that the following conditions
!# are met:
!# 1. Redistributions of source code must retain the above copyright
!#    notice, this list of conditions and the following disclaimer.
!# 2. Redistributions in binary form must reproduce the above copyright
!#    notice, this list of conditions and the following disclaimer in the
!#    documentation and/or other materials provided with the distribution.
!# 3. All advertising materials mentioning features or use of this software
!#    must display the following acknowledgement:
!#      This product includes software developed by John D. Polstra.
!# 4. The name of the author may not be used to endorse or promote products
!#    derived from this software without specific prior written permission.
!#
!# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
!# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
!# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
!# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
!# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
!# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
!# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
!# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
!# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
!# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
!#
!i $Id$
!s The Basics
!q whatisit
What is CVSup?

CVSup is a software package for transferring and updating
collections of files across a network.  It consists of a server
called <tt>cvsupd</tt> and a client called <tt>cvsup</tt>.

<p>CVSup was written by John Polstra, a software consultant who
lives in Seattle.
!q features
What makes CVSup different from other network update packages such as
rdist and sup?

CVSup is faster (often by an order of magnitude) and more flexible
than traditional network update packages.
!q filekinds
What kinds of files can be updated using CVSup?

CVSup can efficiently update any kind of file.  It can even update
Unix device nodes, symbolic links, and hard links.  CVSup supports
several different algorithms for updating various kinds of files.  It
tries to use the most efficient method for each file.  For example, <a
href="#RCS">RCS</a> files are updated using a specialized algorithm
that takes advantage of their structure to greatly reduce the update
time.  Log files (which are changed only by appending new text at the
end) are likewise updated by a special algorithm that transmits only
the new text.  Other text and binary files can be updated efficiently
by the <a href="http://samba.anu.edu.au/rsync/">rsync</a> algorithm,
which is built into CVSup.
!q obtaining
Where can I get CVSup?

CVSup is free software, distributed under a BSD-style license.
You can obtain CVSup from
<a href="ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/">
ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/</a>,
and from FreeBSD's
<a href="http://www.freebsd.org/handbook/mirrors-ftp.html">FTP mirror
sites</a> all over the world.

<p>The <a href="ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/sources/">
sources</a> subdirectory contains the full sources for CVSup.  Be sure
to read <a href="#notc">this</a> before fetching the source
distribution.

<p>The <a href="ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/binaries/">
binaries</a> subdirectory contains precompiled statically-linked
executables for various platforms:

<p>
<ul>
<li>BSD/OS-ix86
<li>Digital Unix 4.0d
<li>FreeBSD-Alpha
<li>FreeBSD-ix86
<li>Linux-ix86-libc5
<li>Linux-ix86-libc6
<li>NetBSD-ix86
<li>OpenBSD-ix86
<li>Solaris-2-Sparc
<li>SunOS-4-Sparc
</ul>

<p>Be sure to read the appropriate README file for your target
platform.
!q bugreports
How can I report bugs or ask questions?

Please address all mail regarding CVSup to <tt>cvsup-bugs@polstra.com</tt>.

<p>If you are reporting a problem with CVSup, provide as much detail
as possible.  Specifically:

<p>
<ul>
<li>Include the output from running <tt>cvsup -v</tt>.
<li>Include the output from running <tt>uname -a</tt> on the client
machine, and on the server too, if possible.
<li>Include a copy of your supfile.
<li>Include copies of any "refuse" files you are using.
<li>Provide the exact command line you used to run CVSup.
<li>If CVSup produced any error messages, include them verbatim.
<li>Describe how you obtained your CVSup installation.  Did you
build it from sources, or did you get a pre-built binary from somewhere?
If you are using a binary distribution, where did it come from?
<li>Include the cvsupd server configuration files, if possible.
</ul>
!q pronounce
How should one pronounce the word "CVSup"?

The author of the program pronounces it <em>see vee supp</em>.  It rhymes
(more or less) with "beam me up."
!s Some Terminology
!q RCS
What is an RCS file?

An RCS file stores many versions of a single source file, all in
one place.  During the lifetime of a project, its source files evolve.
Each source file starts with an initial version.  Over time, changes
are made to the source files to fix bugs and add features.  At key
moments, a programmer might wish to save the current version of a source
file.  He can do this by checking it into its corresponding RCS file.
From a given RCS file, one can later extract any desired version of
the source file.  This makes it easy to undo changes that turned out
to be ill-advised, or to recreate an earlier release of the
software.
!q CVS
What is a CVS repository?

A CVS repository is a collection of RCS files that are managed
together.  For example, the RCS files for all of the sources in a
project would typically be stored together in a CVS repository.
!s Recipes
!q cvsupit
Is there an easy way to get started using CVSup to update my FreeBSD
sources?

Yes, try Jordan Hubbard's "cvsupit" package.  You'll find it
at <a href="ftp://ftp3.freebsd.org/pub/FreeBSD/CVSup/cvsupit.tgz">
ftp://ftp3.freebsd.org/pub/FreeBSD/CVSup/cvsupit.tgz</a>.
!q getcurrent
I just want to get the latest version of the main FreeBSD source tree.
What do I have to do?

Make a cvsupfile that looks something like this:

<pre>
    *default host=cvsup3.freebsd.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs
    *default delete use-rel-suffix
    *default tag=.
    src-all
</pre>

<p>This cvsupfile will create a directory tree "/usr/src" and populate
it with all of the main FreeBSD sources.
It will also create a tree "/usr/sup" containing
the checkouts files that CVSup uses to
maintain state between updates.  If you want your source tree to be
somewhere other than "/usr/src", change the "prefix=" clause.  If
you want the checkouts files to be located somewhere other than
"/usr/sup", change the "base=" clause.

<p>Be sure not to leave out the "tag=." clause.  That tells CVSup to
use checkout mode to send you the most recent version of each source
file.
!q caniadopt
When I installed FreeBSD months ago, I installed the sources too.  Now
I want to begin using CVSup to keep my sources completely up to date.
Do I have to throw out my existing sources and transfer everything
over the network again using CVSup?

No, you don't.  CVSup is capable of "adopting" your existing
sources and bringing them up to date.  If you think about it, your
situation is the same as if you had been updating with CVSup all
along but had lost your checkouts files.  And CVSup uses the same
technique to deal with both situations.  It uses checksums to
determine which revisions of the files you have currently, and then
updates them in the appropriate ways to transform them into the
latest versions.

<p>Look <a href="#adopt">here</a> for the safest way to do this.
!q adopt
But you said above that CVSup won't delete any files if I don't have a
checkouts file.  If I adopt my existing files as you describe, don't I
run a risk that some files which should be deleted won't be deleted?

Yes, you do.  The greater the distance between the revisions
you have and the revisions you want to get, the greater the chance
that you'll miss some important file deletions.  Luckily, if you
know approximately or exactly which versions of the files you are
starting with, you can reduce or eliminate this risk.  You do this by
updating twice.  First, you tell CVSup to "update" you to the versions
that you already have.  This won't change any of your files, but it
will create a checkouts file that precisely reflects what you have
currently.  Second, you update again, this time telling CVSup which
version you really want.  On the second update, CVSup will have all
the information it needs in order to know which files to delete.

<p>This is a little tricky and there are a couple of important details we
haven't mentioned yet.  So we'd better give you an example.  Suppose
you installed FreeBSD-2.2.5, including sources, from the CD-ROM.  Now
you decide you want to use CVSup to track the 2.2-stable sources.
For your first update only, use a cvsupfile like this:

<pre>
    *default host=cvsup2.freebsd.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs
    *default delete use-rel-suffix
    src-all tag=RELENG_2_2_5_RELEASE list=cvs:RELENG_2_2
</pre>

<p>For subsequent updates, change the last line to:

<pre>
    src-all tag=RELENG_2_2
</pre>

<p>The unmentioned details are in this last line.  First of all, how
do you know what to use for the tag?  The answer is, you have to
consult a list.  See the "Configuration" section of the CVSup chapter
in the <a href="http://www.freebsd.org/handbook/cvsup.html">FreeBSD
Handbook</a> for a list of tags that are valid for the FreeBSD
sources.  The important point is that the tag for your first update
should correspond to the version of the sources that you already have.
And the tag for your second and subsequent updates should correspond
to the version of the sources that you want to receive.

<p>Second, what is this business with the "list" keyword?  It is rarely
used, but this is a situation where it is necessary.  When CVSup
creates or consults one of its checkouts files, it uses a filename
which by default is based on the "release" and "tag" values for the
collection.  Specifically, the usual name of a checkouts file is
"checkouts.RELEASE:TAG", where RELEASE and TAG are the "release" and
"tag" settings in your cvsupfile.

<p>In the rather special situation we are addressing here, the
naming conventions for the checkouts files cause a problem.
By default, our first update would produce a file named
"checkouts.cvs:RELENG_2_2_5_RELEASE", while the second update would
look for a file named "checkouts.cvs:RELENG_2_2".  In order for
the second update to benefit from the information garnered in the
first, both updates must use the same checkouts file.  The "list"
specification in the first cvsupfile allows us to accomplish this.  It
overrides the default suffix in the name of the checkouts file, and
forces it to have the same name as will be used in subsequent updates.

<p>Admittedly, this is arcane.  But you only have to do it once.
!q adoptupgrade
How can I adopt my FreeBSD-2.2.5 sources, and update them directly to
FreeBSD-current?

Follow the <a href="#adopt">previous instructions</a>, except change
the <tt>src-all</tt> lines as follows.  In the first update, use:

<pre>
    src-all tag=RELENG_2_2_5_RELEASE list=cvs:.
</pre>

In subsequent updates, use:

<pre>
    src-all tag=.
</pre>

Note carefully: that's a period following the <tt>tag=</tt> part.
Don't leave it out.
!s Understanding cvsupfiles
!q default
Which things belong on "*default" lines in the cvsupfile, and which
belong on the lines for individual collections?

It doesn't make any difference.  This cvsupfile:

<pre>
    *default host=cvsup3.freebsd.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs
    *default delete use-rel-suffix
    *default tag=.
    src-all
</pre>

could just as well be expressed as a single line, like this:

<pre>
    src-all host=cvsup3.freebsd.org base=/usr prefix=/usr release=cvs delete use-rel-suffix tag=.
</pre>

<p>Using the "*default" lines can make your cvsupfile easier to read,
by shortening the lines.  They can also make your cvsupfile more
concise if you are receiving several collections.
!q delete
What does the cvsupfile's "delete" keyword do?

It gives CVSup permission to remove files on your machine.  For
example, suppose you have a file "foo" which you originally received
using CVSup.  Now the maintainer of the server host deletes "foo".
When you next run CVSup, if "delete" is specified in your cvsupfile
then CVSup will delete "foo" on your machine.  Otherwise it will leave
it alone.

<p>Except for a few unusual applications, you should always specify
"delete" in your cvsupfile.
!q delnotdflt
If I should always specify "delete", then why isn't it the default?

Originally CVSup was designed to be a drop-in replacement for sup.
Because of that, the defaults had to be the same whether they made
sense or not.
!s Refuse Files
!q refuse
Help! I can't get "refuse" files to work.

Don't feel bad.  Many people find them confusing.  But they really
do work.

<p>
The most common errors people make with refuse files are:

<p>
<ol>
<li>Specifying the patterns incorrectly.
<li>Putting the refuse file in the wrong directory.
<li>Giving the refuse file the wrong name.
</ol>

<p>
We cover these problems in the following items.
!q refuse-patterns
How do I specify the patterns in a refuse file?

The most important thing to remember is that the patterns in refuse
files are relative to the <em>prefix</em>, which is often not what
you think of as the logical root of a particular collection.  To
determine the prefix, look at your cvsupfile.  Does it contain
something like this?

<pre>
    *default prefix=<em>/some/directory</em>
</pre>

Usually it will.  In that case <em>/some/directory</em> is the prefix.
Otherwise, the prefix is the same as the <em>base</em>.  To determine
the base, see <a href="#refuse-where">this</a>.

<p>
Once you have determined your prefix, put yourself in that
directory.  Then figure out the relative paths of the files and/or
directories you want to block, and make patterns that match them.
Put these patterns into your refuse file separated by whitespace.
You can put each pattern on a separate line, or put several on each
line.  Either way works.
!q refuse-example
How about an example of a refuse file?

OK.  Suppose you use CVSup to receive the FreeBSD documentation
files (the "doc-all" collection), using the <em>doc-supfile</em>
example from <em>/usr/share/examples/cvsup</em>.  Here's what that
cvsupfile looks like, stripped of comments:

<pre>
    *default host=CHANGE_THIS.FreeBSD.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs tag=.
    *default delete use-rel-suffix
    *default compress
    doc-all
</pre>

As you can see, the prefix is <em>/usr</em>.  Relative to there, the
entire "doc-all" collection is placed into a subdirectory named
<em>doc</em>, which itself contains these files and subdirectories:

<pre>
    FAQ/                    handbook/               ru_SU.KOI8-R/
    Makefile                ja/                     sgml/
    en/                     ja_JP.EUC/              share/
    en_US.ISO_8859-1/       ja_JP.eucJP/            zh/
    es/                     ru/                     zh_TW.Big5/
    es_ES.ISO_8859-1/       ru_RU.KOI8-R/
</pre>

Now let's suppose you're not interested in the Spanish, Japanese,
Russian, or Taiwanese versions of the documentation.  So you want to
refuse the directories whose names begin with "es", "ja", "ru", and
"zh".  The correct patterns <em>relative to the prefix</em> are:

<pre>
    doc/es*
    doc/ja*
    doc/ru*
    doc/zh*
</pre>
!q refuse-blockfiles
My refuse file works for directories, but I can't seem to make it
block individual files.

The patterns you specify must match the names of the files on the
<em>server</em>.  If the files are coming from a CVS repository (the
usual case), then on the server they are RCS files.  And RCS files
always have names that end in ",v".  Your patterns must take that
into account.

<p>
For example, suppose you want to block the <em>Makefile</em> in
the example above.  The pattern "<tt>doc/Makefile</tt>" won't work,
because on the server the file's name has a ",v" appended to it.
The correct pattern to use is

<pre>
    doc/Makefile,v
</pre>

or better still

<pre>
    doc/Makefile*
</pre>

which will match the file on the server whether it is an RCS file or
not.
!q refuse-comments
Why does my refuse file block some files which don't match any of the
patterns in it?

You probably tried to put a comment into your refuse file.  But
(surprise!) refuse files have no provision for comments.  Thus your
"comment" is actually interpreted as a bunch of patterns, some of
which may match files that you want to receive.

<p>Consider this <b>incorrect</b> refuse file:

<pre>
    # We accept the entire src and ports trees except for the games
    src/games
</pre>

That innocuous-looking first line is <em>not</em> a comment!  It is
13 separate patterns, including "#", "src", and "ports".  That is
almost certainly not what you intended.

<p>Some day it will probably be possible to put comments into refuse
files.  But for now they are not allowed.
!q refuse-where
Where should I put my refuse files?

First you must determine your <em>base</em> directory.

<p>
<ol>
<li>When you run the "cvsup" program, do you use the "-b
<em>pathname</em>" option?  (Most users don't.)  If so, that
<em>pathname</em> is your base.  Otherwise ...</li>
<li>Does your cvsupfile contain a "base=<em>pathname</em>"
specification?  (Many of them do.)  If so, that <em>pathname</em> is
your base.  Otherwise ...</li>
<li>Your base is the built-in default, "/usr/local/etc/cvsup".</li>
</ol>

<p>
Next you must determine your <em>collDir</em>, the subdirectory of
<em>base</em> where CVSup keeps track of your collections.

<p>
<ol>
<li>When you run the "cvsup" program, do you use the "-c
<em>directory</em>" option?  (Must users don't.)  If so, that
<em>directory</em> is your <em>collDir</em>.  Otherwise ...</li>
<li>Your <em>collDir</em> is the built-in default, "sup".</li>
</ol>

<p>
Finally, you must know the name of the collection you want to
restrict, for example, "doc-all".

<p>
Combine those three items with a slash after each one, and then tack
"refuse" on the end.  That's where to put your refuse file.  For the
<a href="#refuse-example">example</a> we've been using, it works
out to

<pre>
    /usr/sup/doc-all/refuse
</pre>

assuming you don't use the "-b" or "-c" option when you run CVSup.
!q refuse-global
Is there a way to create a global refuse file that will apply to all
collections?

Yes.  Simply leave out the name of the collection and the slash
that follows it when you formulate the name of the file.  In the
previous example, the global refuse file would be named

<pre>
    /usr/sup/refuse
</pre>
!s CVSup and Firewalls
!q fwtk
How can I make CVSup work through my TIS FWTK firewall?

The following instructions were kindly submitted by Alan Strassberg:
<p>
<ol>
<li>Add this line to /etc/services:
<pre>
    cvsup   5999/tcp        # CVSup
</pre>
<p>
<li>Add the following to /etc/inetd.conf:
<pre>
    cvsup stream tcp nowait root /usr/local/etc/plug-gw plug-gw cvsup
</pre>
and send a SIGHUP to inetd.
<p>
<li>Add the following to /usr/local/etc/netperm-table (or whatever
the file is named on your system):
<pre>
    cvsup: port cvsup <em>A.B.C.D</em> -plug-to <em>W.X.Y.Z</em> -port cvsup
</pre>
where <em>A.B.C.D</em> is the IP address of the internal machine,
and <em>W.X.Y.Z</em> is the IP address of the CVSup server.
<p>
<li>In your cvsupfile, set the CVSup server to be your firewall:
<pre>
    *default  host=gatekeeper.foo.com
</pre>
<p>
<li>When you invoke the cvsup client, include "<tt>-P m</tt>" on the
command line.
</ol>

<p>
Troubleshooting: you should be able to telnet from the internal
machine to the firewall on port 5999 and see the CVS server greeting:
<pre>
    % telnet gatekeeper.foo.com 5999
    OK 16 1 REL_16_1 CVSup server ready
</pre>
If the greeting does not appear, run <tt>netstat -na</tt> on the
firewall and verify that it is listening on port 5999:
<pre>
    % netstat -na | grep 5999
    ...
    tcp  0  0  *.5999        *.*                    LISTEN
</pre>
!s Problems Using CVSup
!q cksum
Why has CVSup suddenly started giving me lots of messages saying,
"Checksum mismatch -- will transfer entire file"?  Every file gets a
"fixup" and that is really slowing down my updates.

Both you and your friendly server administrator need to upgrade to
CVSup 15.4 or later.  That will solve this problem.

<p> CVSup upgrades an RCS file by deconstructing it on the server,
sending only the pieces that have changed to the client, and
reconstructing the file on the client.  (It's roughly patterned after
the transporter on the starship Enterprise.)  CVSup then compares the
MD5 checksum of the reconstructed file with that of the original on
the server, to make sure that the process worked correctly.

<p> Unfortunately, recent releases of CVS have introduced some
gratuitous changes in the format of the RCS files that they write.
These are simply changes in white space, which have no bearing on
the logical meaning of the file.  However, the result is that an RCS
file constructed by the CVSup client no longer matches the original
file byte-by-byte as before.  Even though the reconstructed file
is logically identical to the original, it does not have the same
checksum.  This causes older versions of CVSup to reject the updated
file and use a fixup to re-transfer the entire file.

<p> To solve this problem, CVSup 15.4 introduces a <em>logical</em>
checksum which is used only for RCS files.  Instead of blindly
computing a byte-by-byte checksum over the entire file, the new
checksum algorithm carefully canonicalizes the file so that irrelevant
white space differences are ignored.  The logical checksum should
make CVSup immune to any future problems of this nature.
!q fwhang
When I try to run CVSup, it says it has connected to the server, but
then it just hangs.  What's wrong?

You are behind a firewall which is blocking attempts by the CVSup
server to establish a second TCP connection to your client.  Add
the option "<tt>-P m</tt>" to your <tt>cvsup</tt> command line, and
everything should work fine.
!q debugkernel
Whenever I run CVSup under FreeBSD, I get zillions of messages like
this: <tt>fatal process exception: page fault, fault VA =
0x11a610</tt>.

When you built your FreeBSD kernel, you included the undocumented
"<tt>options DEBUG</tt>" in the kernel config file.  Don't do that.
!q bsdos
I tried to run the FreeBSD binary of CVSup under BSD/OS, but it dumped
core right away.  Isn't that supposed to work?

Yes, the statically linked FreeBSD binaries work fine under other
BSD-derived operating systems.  But for some of them, including
BSD/OS, you have to add "<tt>@M3novm</tt>" to the command line.

<p>
CVSup is written in Modula-3, and its runtime system uses a
sophisticated garbage collector which exploits hooks into the VM
subsystem of the operating system to gain better interactive
performance.  This feature stumbles upon an incompatibility between
BSD/OS and FreeBSD, causing the core dumps.  The cryptic argument
"<tt>@M3novm</tt>" disables the VM hooks and makes it possible to
run FreeBSD binaries under other BSD-derived operating systems.

<p>Also, recent versions (4.0 and later) of BSD/OS cannot run ELF
format FreeBSD executables.  But they can run the older
<tt>a.out</tt> executables without problems.
!q gui-dns
The CVSup client dies with a segmentation violation when I try to use
the GUI.

The message looks like this, right?
<pre>
    ***
    *** runtime error:
    ***    Segmentation violation - possible attempt to dereference NIL
    ***    pc = 0x81f0708 = Cat + 0x18 in /b/jdp/pm3/pm3/libs/m3core/src/text/Text.m3
    ***
      use option @M3stackdump to get a stack trace
    Abort trap (core dumped)
</pre>
There is a bug in the Modula-3 graphics library that causes this
failure if your DNS setup isn't correct.  In particular, the failure
happens if there is no reverse DNS record for your system's IP address.
Try commands like these to check your DNS setup.  (If your system
doesn't have the "host" command, look for "dig" or "nslookup"
instead.)
<pre>
    $ hostname
    bogus.example.com

    $ host bogus.example.com
    bogus.example.com has address 192.168.1.1

    $host 192.168.1.1
    Host not found, try again.
</pre>
That last line shows the problem.  If your DNS setup were correct,
the output would say
<pre>
    1.1.168.192.IN-ADDR.ARPA domain name pointer bogus.example.com
</pre>
The best way to fix this problem is to correct your DNS setup.  (You
might need to get some help from your system administrator.)  If that
is not possible, you might be able to work around the problem by
adding a line to your "/etc/hosts" file.  Finally, if all else fails,
you can run the CVSup client without the GUI by adding "-g" to the
command line.

<p>
Someday I will fix the bug in the graphics library so that this
won't be a problem any more.
!q linux-dns
The Linux binary from the CVSup FTP site can't do DNS lookups on my
Linux system.

Check the FTP site again for a newer binary.  This problem was caused
by binary incompatibilities between certain Linux kernels and certain
versions of glibc.  The newer binary (distributed since 20 Febuary
2000) links the C library dynamically, so it should work on any recent
version of Linux.
!q nomem
CVSup (client or server) dies with the message "gc: Could not extend
the traced heap".

That's its quaint way of telling you it is out of memory.  Make sure
your resource limits are set high enough.  Under a sh-like shell,
use "ulimit -Sa" to check the "datasize" and "memoryuse" limits.
Under a csh-like shell, use the "limit" command to check "data seg
size" and "max memory size".
!q dragonint
CVSup client dies at random times with a subscript out of range in
DragonInt.m3.

That is caused by a bug in the SRC Modula-3 runtime system.  Grab an
up-to-date CVSup binary from the CVSup FTP site.  Or apply
<a
href="http://www.research.digital.com/SRC/modula-3/html/patches.html#dragonInt">
this patch</a> to your SRC Modula-3 sources, and rebuild and reinstall them.

<p>
For a quick work-around, just run the CVSup client without the GUI
by adding "-g" to the command line.
!q os-change
I moved a CVSup mirror site which I manage to a different OS, and now
CVSup (client and/or server) keeps crashing.

If you moved your site from FreeBSD, NetBSD, OpenBSD, or BSD/OS to
a non-BSD system, the problem is in the "checkouts" files which you
brought along.  They contain some information which non-BSD versions
of CVSup don't understand.  This tickles a bug which is present in
versions 16.1 and earlier.  The bug has been fixed, and this problem
will disappear starting with version 16.2.  Until then, you can easily
eliminate the problem by deleting the "checkouts*" files under your
<em>base</em> directory and letting cvsup regenerate them.
!q setattrs
Sometimes when I run the CVSup client, it spews a "SetAttrs" message
for every file.

This generally happens when CVSup thinks it needs to update one or
more file attributes (owner, group, permissions, etc.) but isn't
able to do so.  The actual file attributes may be incorrect, or
their recorded values in the "checkouts" file may be incorrect.
Check for any of the following situations:

<p>
<ul>
<li>You run some updates as root (e.g., from a cron job) and other
updates as a different user.  The root updates may cause some files
to be owned by root.  Later, your normal user updates won't be able
to modify the files.
<p>
<li>You have different umask settings at various times when you run
CVSup.  This is easy to fix in modern versions of CVSup.  Just add
"*default umask=2" (pick your desired value) at the top of your supfile.
<p>
<li>Your "checkouts" files under the "base" directory have
permissions that make it impossible for CVSup to write them.
</ul>
!q missingtag
I tried to update my files with CVSup, but all I got were a bunch of
strange looking files whose names all ended with ",v".  Why?

Those strange files are <a href="#RCS">RCS</a> files, and CVSup
sent them to you because your cvsupfile told it to.  When you ask
CVSup to send you updates from a CVS repository, there are two
different things you can ask for.  First, you can ask for the source
files to be extracted from the repository and sent to you.  That is
apparently what you wanted in this case.  Second, you can ask for the
raw RCS files (containing all versions of the sources) to be sent to
you.

<p>These two modes of operation are fundamentally different.  Both work
from RCS files in a CVS repository on the server host.  But they use
the RCS files in different ways.  The first mode, called "checkout
mode," extracts a particular version of the sources from the RCS
files, and sends you that version.  The second mode, called "CVS
mode," sends you the RCS files themselves, in the same form as on the
server.  In the cvsupfile, the "tag" and "date" keywords control which
mode is used.  If either of these keywords is present, then CVSup
uses checkout mode to send you a set of source files.  If neither
"tag" nor "date" is present, then CVSup uses CVS mode to send you
the RCS files.

<p>Assuming you want the most recent version of the sources, you simply
need to add "tag=." to your supfile.
!q s1gbug
Suddenly CVSup has started setting the timestamps of updated files to
the year 1970!

This is caused by a long-dormant bug in CVSup which has only now
made itself apparent.  The bug is present in all versions prior to
<tt>SNAP_16_1d</tt>.  You will need to update both your client and
your server to <tt>SNAP_16_1d</tt> in order to fix this problem.
(Future versions released after <tt>SNAP_16_1d</tt> will of course also
contain the bug fix.)

For more information and for distributions of <tt>SNAP_16_1d</tt> in
source and binary forms, please visit
<a
href="http://people.freebsd.org/~jdp/s1g/">http://people.freebsd.org/~jdp/s1g/</a>.
!s Checkouts Files
!q whatarecheckouts
What are these "checkouts" files I hear about occasionally?

In order to update your files efficiently, CVSup needs to know
what you've already got.  It stores this information in files called
"checkouts" files.  Each time you run cvsup, it reads your checkouts
files to see which files (and which revisions of them) you have.  As
it updates your files, it also updates the information in the
checkouts files.

<p>Confusingly, checkouts files are also sometimes referred to as
"list" files.
!q lostcheckouts
This sounds dangerous.  What if I accidentally delete one of my
checkouts files?

It is not a big problem.  If CVSup can't find a checkouts file
that it needs, it falls back on other methods of determining which
files you have.  One such method is to compute checksums (MD5 file
signatures) for each of your files, and use those to figure out
which file revisions you have.  This is perfectly safe, but it is
inefficient.  It slows down your update and also puts a heavier load
on the server.
!q badcheckouts
What if my checkouts file gets corrupted somehow?

CVSup will detect the problem and quit, with a message suggesting
that you delete the corrupted file and try again.  If you follow the
suggestion, it will complete your update using the fallback methods
mentioned above, and recreate your checkouts file for next time.
!q extrafiles
Is there anything at all that can go wrong if I lose a checkouts file?

There is just one thing that can go wrong, and it's not very
serious.  CVSup will only delete files that are listed in its
checkouts file.  Thus if you lose your checkouts file, and then a
file "foo" is deleted on the server host, and then you run CVSup,
your file "foo" will not be deleted.

<p>Files are never supposed to be deleted from a CVS repository, so
this isn't much of a problem in real life.  But to be safe, you
should run CVSup sooner rather than later, if you find that you've
lost a checkouts file.
!s Local Modifications in your CVS Repository
!q canilocal
Can I check my own local changes into a CVS repository that I update
with CVSup from a master site?

If you are careful and if you understand what is going on behind the
scenes, you can make this work.  CVSup was designed to allow extra
locally checked-in revisions to coexist in the RCS files along with
the revisions taken from the master repository on the server.  Because
CVSup understands the structure of RCS files, it is able to bring in
new revisions from the server without disturbing your own revisions
that you have checked in locally.  Unfortunately, certain logistical
issues make this capability awkward to use in practical situations.

<p>
To keep local revisions in your copy of the CVS repository, you have
to:

<ul>
<li>Instruct CVSup not to delete them.</li>
<li>Ensure that revision numbers of your local revisions don't
conflict with the numbers of current or future revisions in the
master copy of each RCS file at the server.</li>
</ul>

<p>
We cover these topics separately below.
!q nodelete
How can I keep CVSup from deleting the revisions I have checked in
locally?

Simply remove the "delete" keyword from your cvsupfile.  When present,
this keyword gives CVSup permission to delete extra revisions from the
RCS files.  It also permits CVSup to delete entire RCS files, provided
that it created them in the first place.  By removing the "delete"
keyword, you can prevent CVSup from removing extra revisions as well
as entire RCS files.  However, it is very important to understand the
consequences of removing the "delete" keyword.

<p>
First, suppose that one or more RCS files are intentionally removed
from the CVS repository at the master site.  Without the "delete"
keyword, CVSup will not propagate these file removals to your site.
Thus you will have some RCS files in your repository that otherwise
shouldn't be there.

<p>
In an ideal world, this would not be a problem.  That is because, in
an ideal world, one <em>never</em> deletes an RCS file from a CVS
repository.  Thus, the situation should never arise.

<p>
Unfortunately, most administrators don't manage their repositories
quite so idealistically.  Committers make mistakes and check files
into the wrong locations.  Most administrators will manually repair
such errors by moving the files in the repository, rather than
live with the mistake forever.  As another example, in any large
repository, some files eventually become completely obsolete.
Eventually, developers will complain about the wasted disk space and
the clutter in the repository, and the repository administrator will
respond by deleting the files.

<p>
Usually, undeleted RCS files don't cause any problems, and they can
be safely ignored.  This is especially true if the repository
administrator at the master site has taken care to mark the files
"dead" on all branches with "cvs remove" a few weeks before completely
removing the unwanted RCS files.  Nevertheless, extra RCS files can
cause problems in some cases, and you need to be aware of that.
!q revconflicts
How can I keep the revision numbers of my local check-ins from
conflicting with revision numbers originating at the master site?

It is difficult, because CVS chooses the revision numbers itself.
One way around this is to modify CVS slightly.  Before discussing
that, though, the first rule of thumb is to create a new branch to
hold your local changes.  Don't try to check your local changes into
the main branch or a branch that exists in the master repository.
Doing so would make revision number collisions very likely, sooner
or later.

<p>
If your local revisions are on their own branch, then the problem is
reduced to ensuring that your branch has a unique revision number
which will never be duplicated in the master repository.  The
easiest way to accomplish this is to modify CVS.  The version of CVS
released with FreeBSD includes such a modification.  In that
version, you can influence the revision numbers of branches by
setting the environment variable <tt>CVS_LOCAL_BRANCH_NUM</tt>.
This variable should be set to an integer value, and CVS will use
that as the starting point when choosing revision numbers for new
branches.  By default, CVS allocates branch numbers starting with 1.
So a high value such as 1000 makes a good choice.  New branches at
the master site will receive low revision numbers, while your own
local branches will receive high revision numbers.  Thus the two
won't conflict.

<p>
When using this method, it is of the utmost importance that
committers do <strong>not</strong> set <tt>CVS_LOCAL_BRANCH_NUM</tt>
when creating branches in the master repository.

<p>
If you don't have a version of CVS that supports
<tt>CVS_LOCAL_BRANCH_NUM</tt>, it is still possible to avoid
conflicts with little cooperation from the master site.  Simply
create a branch in the master repository, declare it to be reserved
for local modifications, and leave it unused in the master
repository.
!s Setting Up a CVSup Server
!q testserver
How can I set up a simple collection to test the CVSup server?

Make an empty directory somewhere.  We'll call that directory
<em>base</em>.  Cd into <em>base</em> and do a <tt>mkdir -p
sup/test</tt>.

<p>
Next, cd into <tt>sup/test</tt> and create a file named <tt>releases</tt>
with one line in it like this:

<pre>
    cvs list=list.cvs prefix=<em>prefix</em>
</pre>

In the above, replace <em>prefix</em> with the absolute path to some
CVS repository on your machine, e.g., <tt>/usr/cvs</tt>.  If you don't
have a CVS repository, you can use any directory that has some files
in it.  But RCS files are the best for testing purposes.

<p>
In the same directory as the <tt>releases</tt> file, make a file named
<tt>list.cvs</tt>.  It should contain a single line:

<pre>
    upgrade src/bin
</pre>

Here, replace <tt>src/bin</tt> with the path to some reasonably-sized
subtree of your CVS repository, relative to <em>prefix</em>.
For example, if <em>prefix</em> is <tt>/usr/cvs</tt> in your
<tt>releases</tt> file, and the line in <tt>list.cvs</tt> is as above,
then the transferred subtree will be <tt>/usr/cvs/src/bin</tt>.

<p>
You have just created a CVSup collection named "test" with a release
named "cvs".  You can run the server like this:

<pre>
    cvsupd -b <em>base</em>
</pre>

replacing <em>base</em> appropriately with the pathname of the
base directory that you created above.  If you run it this way,
<tt>cvsupd</tt> will print its log messages to stdout.  It will serve
exactly one client and then exit.  To run multiple tests, you have to
restart the server each time.  Alternatively, you can run the server
like this:

<pre>
    cvsupd -b <em>base</em> -C 1 -l /dev/stdout
</pre>

and it will become a daemon and serve clients indefinitely until you
kill it manually.  Note, it doesn't matter what your working directory
is when you start the server.

<p>
Now, create a separate empty directory where you'll run the client
to receive the updates from the server.  We'll call that directory
<em>dest</em>.  In <em>dest</em>, make a file <tt>supfile</tt> that
looks like this:

<pre>
    *default host=localhost
    *default base=.
    *default release=cvs
    *default delete use-rel-suffix
    test
</pre>

(Notice that there is a "." in "<tt>base=.</tt>".)

Make sure the server is running, and then, still in <em>dest</em>, run
<tt>cvsup</tt> in the usual way.  The simplest command is this:

<pre>
    cvsup supfile
</pre>

but you can add <tt>-g -L 2</tt> to disable the GUI if you wish.

<p>
If your CVSup client was built with the GUI, press the start button.
The non-GUI client starts automatically.  At this point, your disk
light will turn into a 50-watt beacon and your hard drive will make
that noise that says, "I'm really really <em>really</em> busy."  When
it's done, you should find the updated files under your <em>dest</em>
directory.  There will also be a directory <tt>sup</tt> which is used
by <tt>cvsup</tt> to record its state.

<p>
Assuming that worked, you can get arbitrarily thorough in testing
the rest of it.  By manipulating the source RCS files, you can add
deltas and/or tags, and then make sure they propagate when you do
another update.  You can also try deleting RCS files entirely, and
adding new ones.  On the client side, you can add <tt>tag=</tt>
and/or <tt>date=</tt> specifications to the supfile.  Generally,
if the software works at all on a given platform, it's likely to
work completely.  Almost all of the functionality is contained in
OS-independent code.

<p>
One caveat:  Doing an update all on one machine via localhost really
hammers a system, particularly the disk subsystem and the network
stack.  It can expose OS bugs that nobody knew existed before.  If
you run into networking-related problems, it might help to use <tt>-P
m</tt> on the <tt>cvsup</tt> command line when you do your updates.
!q serversample
Where can I find a set of CVSup server configuration files to use as
an example?

The server configuration files used by the FreeBSD project are
available via CVSup from any FreeBSD mirror site.  To fetch a copy, get
into an empty directory and make a file named <tt>supfile</tt>
containing this text:

<pre>
    *default host=<em>a.mirror.site</em> compress
    *default release=cvs tag=.
    *default base=.
    *default delete use-rel-suffix norsync
    distrib
</pre>

Replace <em>a.mirror.site</em> with any <a
href="http://www.freebsd.org/doc/en_US.ISO8859-1/books/handbook/cvsup.html#CVSUP-MIRRORS">CVSup
site listed in the FreeBSD Handbook</a>.  Run the CVSup client using this
<tt>supfile</tt>.  When it finishes, you'll find the configuration
files in the subdirectory <tt>distrib/cvsup</tt>.  If you wanted to
use these configuration files directly, you'd use that subdirectory as
your <em>base</em> directory, like this:

<pre>
    cvsupd -b distrib/cvsup <em>...</em>
</pre>

In a real setup, you'd specify the base directory as an absolute
pathname, of course.
!s Building CVSup from the Sources
!q notc
I've heard lots of horror stories about building CVSup from the
sources.  Why is that?

The basic problem is that CVSup is written in the programming language
NotC.  What is NotC?  Well, to most people, it really doesn't
matter.  The important thing is that NotC is <strong>not C</strong>.
Consequently, it takes a little extra work to use it.

<p>
In the case of CVSup, NotC means Modula-3.  Modula-3 is an
efficient compiled programming language with excellent built-in
support for important features such as garbage collection
and threads.  For more information about Modula-3, see the
<a href="http://www.research.digital.com/SRC/modula-3/html/home.html">
Modula-3 Home Page</a>.

<p>
Fortunately, Modula-3 ports exist for
<a href="http://www.research.digital.com/SRC/modula-3/html/platforms.html">
many platforms</a>.  If there is already a port for your platform of
choice, then you've already cleared the biggest hurdle to building
CVSup.

<p>
A second problem that many people run into is that building the
Modula-3 compiler and runtime system requires a lot of virtual
memory.  You will need on the order of 64 MB of available virtual
memory to build it.  (Building CVSup itself requires less than
that.)  You will also need to ensure that your resource limits are
set high enough.  These are controlled by the "ulimit" command in
<tt>sh</tt>-like shells, or by the "limit" command in <tt>csh</tt>.

<p>
Third, by default you have to have X11 on your system to build the
Modula-3 runtime.  It is possible to build Modula-3 without X11, but
to do so you have to edit the file <tt>m3/src/m3makefile</tt> and
comment out the packages that depend on X11.
!q fromsource
What steps are involved in building CVSup from the sources?

<ol type="A">

<li>Build and install the Modula-3 compiler and runtime.  This is
the hardest part of the process.</li>

<li>Build and install the "zlib" compression library.  This is
quite painless.  See the
<a href="http://www.gzip.org/zlib/">zlib home page</a>
for details.</li>

<li>Build and install CVSup.  This also is relatively painless.</li>
</ol>
!q mswin
Has CVSup been ported to Windows 95 or NT?

No, CVSup does not currently work on Windows platforms.  It relies
on a number of features which are specific to POSIX-like operating
systems.
!s Compatibility
!q verscompat
When a new version of CVSup comes out, do the clients and the server
have to be upgraded at the same time?

Traditionally, all publicly released versions of CVSup have been able
to interoperate with each other.  However, that became undesirable
with the discovery of the unfortunate <a href="#s1gbug">s1g
bug</a>, which was present in all versions of CVSup prior to
<tt>SNAP_16_1d</tt>.  CVSup clients which contain the s1g bug
create very heavy loads on CVSup servers.

<p>To protect the servers from this problem, checks were added to
them beginning with version <tt>SNAP_16_1e</tt>.  These newer servers
refuse to provide service to any CVSup client which contains the s1g
bug.  When such a client connects to a <tt>SNAP_16_1e</tt> or later
server, the server terminates the connection immediately and causes
the client to display a message explaining the problem.  The message
includes information about obtaining updated versions of CVSup.

<p>CVSup clients also need protection from old servers which would
deliver files with incorrect timestamps.  Therefore, similar checks
were added to the clients, beginning with version <tt>SNAP_16_1e</tt>.
If one of these newer clients connects to a CVSup server which has the
s1g bug, the client displays an error message and quits immediately.
The error message explains the problem, and urges the user to notify
the maintainer of the site which is still running the obsolete server.
!q supcompat
Can I use the CVSup client to get updates from a SUP server?

No.  Although the CVSup client can use supfiles written for SUP,
the two packages are otherwise incompatible.
!s Bidirectional Mirroring
!n bidirectional-cani
How can I use CVSup to mirror changes in both directions between two
CVS repositories?

I'm sorry, but CVSup is the wrong tool for that.  CVSup is
designed for unidirectional mirroring only.  If you try to use it
bidirectionally, you will encounter some difficult problems.  For
example, if conflicting changes are committed to a file, how shall the
conflicts be resolved?  There may be an ad hoc solution that fits your
particular situation, but you will have to discover it on your own.

<p>However, there is a modified and extended version of CVSup available
in <A HREF="http://www.elegosoft.com/dcvs/">
DCVS (Distributed Concurrent Versions System)</A> that will enable you
to setup a network of DCVS servers (using the extended CVSup version),
each serving only dedicated ranges of revision numbers which
correspond to certain lines of development (CVS branches).  See
<A HREF="#bidirectional-tools">the next answer</A> for details.
!n bidirectional-tools
What other tools are available for bidirectional mirroring of CVS
repositories?

It is not possible to mirror CVS repositories bidirectionally without
special provisions for protection and uniqueness of elements.
There is a project called <A HREF="http://www.elegosoft.com/dcvs/">
DCVS (Distributed Concurrent Versions System)</A> which
consists of modified and extended versions of CVS and CVSup that
enable you to synchronize a network of DCVS servers with dedicated
lines of development.  DCVS is available in source and binary packages
for several platforms from <A HREF="http://www.elegosoft.com/">elego
Software Solutions GmbH, Berlin</A>.

<p>You can also <A HREF="http://www.elegosoft.com/dcvs/cvsup-dcvs.php3">
download DCVS via CVSup</A> or read an 
<A HREF="http://www.elegosoft.com/dcvs/doc/dcvs_overview.html">overview
of DCVS</A>.
