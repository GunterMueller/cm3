!# Copyright 1998-2003 John D. Polstra.
!# Russian translation Copyright 1999-2002 Sergey Osokin.
!# All rights reserved.
!#
!# Redistribution and use in source and binary forms, with or without
!# modification, are permitted provided that the following conditions
!# are met:
!# 1. Redistributions of source code must retain the above copyright
!#    notice, this list of conditions and the following disclaimer.
!# 2. Redistributions in binary form must reproduce the above copyright
!#    notice, this list of conditions and the following disclaimer in the
!#    documentation and/or other materials provided with the distribution.
!# 3. All advertising materials mentioning features or use of this software
!#    must display the following acknowledgement:
!#      This product includes software developed by John D. Polstra.
!# 4. The name of the author may not be used to endorse or promote products
!#    derived from this software without specific prior written permission.
!#
!# THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
!# IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
!# OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
!# IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
!# INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
!# NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
!# DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
!# THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
!# (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
!# THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
!#
!i $Id$
!s Основы
!q whatisit
Что такое - CVSup?

CVSup - пакет программ для передачи и обновления коллекций файлов через сеть. Он состоит из сервера называющегося <tt>cvsupd</tt> и клиента называемого <tt>cvsup</tt>.

<p>CVSup написал Джон Полстра (John Polstra), консультант по программному обеспечению,
проживает в Сиэтле.
!q features
Чем отличается CVSup от других сетевых пакетов коррекции, таких как, например, rdist и sup?

CVSup более быстрый и более гибкий, чем традиционные пакеты сетевой коррекции. 

!q filekinds
Файлы каких типов могут быть скорректированы, используя CVSup?

CVSup может эффективно корректировать файлы любых типов. Это могут быть даже ноды Unix-устройств, символические связи и жесткие связи. CVSup поддерживает несколько различных алгоритмов для обновления различных файлов и пытается использовать наиболее эффективный метод для каждого файла. Например, файлы <a href="#RCS">RCS</a> корректируются, используя специализированный алгоритм, который пользуется преимуществом их структуры, чтобы существенно уменьшить время коррекции. Регистрационные файлы (которые изменяются, в конечном счете, только посредством добавления нового текста) корректируются специальным алгоритмом, который передаёт только новый текст. Другие текстовые и двоичные файлы могут быть эффективно скорректированы <a href="http://samba.anu.edu.au/rsync/">rsync</a> алгоритмом, который встроен в CVSup.

!q obtaining
Где я могу получить CVSup?

CVSup - свободное программное обеспечение, распространяемое по BSD лицензии. Вы можете получить CVSup на <a href="ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/">ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/</a>, и с <a href="http://www.freebsd.org/handbook/mirrors-ftp.html">FreeBSD-зеркал FTP</a> во всем мире. 

<p>В <a href="ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/sources/">source</a> директории содержит полные исходные тексты для CVSup.
Прочитайте этот <a href="#compiling">текст</a> прежде, чем забирать исходные тексты.

<p>Директория <a href="ftp://ftp3.FreeBSD.org/pub/FreeBSD/development/CVSup/binaries/">binaries</a> содержит статически скомпилированные модули для различных платформ:
<p>
<ul>
<li>BSD/OS-ix86
<li>Digital Unix 4.0d
<li>FreeBSD-Alpha
<li>FreeBSD-ix86
<li>Linux-ix86-libc5
<li>Linux-ix86-libc6
<li>NetBSD-ix86
<li>OpenBSD-ix86
<li>Solaris-2-Sparc
<li>SunOS-4-Sparc
</ul>

<p>Обязательно прочтите соответствующий файл README для вашей платформы.
!q bugreports
Кому я могу задать вопросы и куда я могу сообщить об ошибках?

Пожалуйста, адресуйте всю почту относительно CVSup на <tt>cvsup-bugs@polstra.com</tt>.

<p>Сообщая о проблеме с CVSup, пожалуйста, укажите как можно больше
подробностей. Спецификация:

<p>
<ul>
<li>Укажите вывод команды <tt>cvsup -v</tt>.
<li>Укажите вывод команды <tt>uname -a</tt> на вашей машине-клиенте и,
если это возможно, на машине-сервере.
<li>Включите в письмо ваш supfile.
<li>Включите в письмо "refuse" файлы, если вы их используете.
<li>Укажите командную строку, используемую для запуска CVSup.
<li>Если CVSup говорит о каких-либо ошибках, укажите эти сообщения.
<li>Опишите ваш процесс установки CVSup. Программа была
собрана из исходных текстов или вы где-то раздобыли "бинарник"?
Если вы используете "бинарник" - укажите каким образом он попал к вам.
<li>Если возможно - включите конфигурационные файлы cvsupd.
</ul>
!q pronounce
Как следует произносить слово "CVSup"?

Автор программы произносит как <em>си ви сапп</em>. Это более или менее
рифмуется с "beam me up".
!s Немного Терминологии
!q RCS
Что такое RCS файл?

Файл RCS содержит множество версий единственного исходного файла, всё в одном месте. В течение срока службы проекта, исходные файлы развиваются. Каждый исходный файл имеет начальную версию. Со временем изменения сделаны в исходных файлах, для того чтобы исправить ошибки и добавить новые (:-))) характеристики. В ключевых моментах, программист хочет сохранить текущие версии исходного файла. Он может сделать это с помощью проверки этого файла с соответствующим ему файлом RCS. Из данного файла RCS в последствии может быть извлечена любая желаемая версия исходного файла. Это облегчает как отмену изменений, которые оказались опрометчивыми, так и воссоздание более ранних версий программного обеспечения.

!q CVS
Что такое CVS хранилище?

Хранилище CVS является местом хранения файлов RCS, которые управляются вместе. Например, файлы RCS для всех исходных текстов в проекте должны быть сохранены все вместе в хранилище CVS.

!s Рецепты
!q cvsupit
Существует ли простой путь, чтобы приступить к использованию CVSup, для того чтобы скорректировать мои исходные тексты FreeBSD?

Да, попробуйте пакет "cvsupit" от Jordan Hubbard. Вы можете найти этот пакет здесь: ftp://ftp3.freebsd.org/pub/FreeBSD/CVSup/cvsupit.tgz. 

!q getcurrent
Я просто хочу получить самую последнюю версию основного дерева исходных текстов FreeBSD.
Что я должен сделать?

Сделайте cvsupfile, который выглядит приблизительно так:

<pre>
    *default host=cvsup3.freebsd.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs
    *default delete use-rel-suffix
    *default tag=.
    src-all
</pre>

<p>Этот cvsupfile создаст дерево директорий "/usr/src" и заполнит его исходными текстами FreeBSD. Он также создаст дерево "/usr/sup" содержащее файлы <a href="#checkouts">checkouts</a>, которые CVSup использует, для поддержки состояния между коррекциями. Если Вы хотите, чтобы ваше дерево исходных текстов располагалось в месте, отличном от "/usr/src", измените описание "prefix=". Если Вы хотите, чтобы файлы checkouts располагались в другом месте (в описании это "/usr/sup"), измените  описание "base=".

<p>Убедитесь в том, что вы не пропустили описание "tag=.". Это описание сообщает CVSup, что следует использовать checkout режим, для получения самой последней версии каждого исходного файла. 

!q caniadopt
Когда я устанавливал FreeBSD несколько месяцев тому назад, я установил и исходные тексты. Теперь я хочу использовать CVSup, для того чтобы у меня были исходные тексты в "текущем состоянии". Правильно ли то, что мне следует выбросить(удалить) мои текущие исходные тексты и передать новые исходные тексты по сети заново, используя при этом CVSup?

<p>Нет, так делать не следует. CVSup способен воспринять существующие у вас исходные тексты и внедрить более новые. Если Вас это заинтересовало, то данная ситуация похожа на ту, как если бы Вы обновляли свои исходные тексты с помощью CVSup, но в конце концов почему-то потеряли ваши файлы checkouts. CVSup использует следующий способ, для того чтобы справиться с обеими ситуациями. CVSup использует контрольные суммы, чтобы определить какие исправленные издания файлов у Вас есть к настоящему времени, а затем корректирует их надлежащим образом, чтобы превратить их в самые последние версии. 

<p>Следуйте нашим <a href="#adopt">дальнейшим</a> инструкциям для того, чтобы узнать, как это сделать более безопасно.

!q adopt
Но Вы сказали выше, что CVSup не удалит файлы, если у меня нет checkouts файлов. Если я принимаю мои существующие файлы, как Вы это описываете, есть ли риск, что некоторые файлы, которые должны быть удалены, не будут удалены?

Да, так и есть. Версии файлов, которые вы хотите получить, намного новее тех, что вы имеете, и число изменений, которые претерпели новые файлы по сравнению с вашими, слишком велико, поэтому есть большой шанс, что Вы пропустите некоторые важные удаления "ненужных" файлов. К счастью, если Вы приблизительно или точно знаете, какие версии файлов Вы имеете, то Вы можете уменьшить или устранить этот риск. Вы делаете обновление дважды. Сначала, Вы сообщаете CVSup, чтобы он "скорректировал" версии тех файлов, которые Вы уже имеете. Эта процедура не изменит ваших файлов, а всего лишь создаст файлы checkouts, которые точно отражают что Вы имеете к настоящему времени. Следующим шагом Вы корректируете файлы, но на этот раз сообщаете CVSup, какая версия Вам действительно нужна. На втором шаге коррекции, CVSup будет иметь всю информацию, которая ему нужна, для того чтобы знать, какие файлы будут удаляться.

<p>В этом небольшом трюке есть пара важных деталей, о которых мы всё ещё не упомянули. Итак, мы лучше предоставим Вам пример. Полагаем, что Вы установили FreeBSD-2.2.5, включая исходные тексты с CD-ROM. Теперь Вам захотелось использовать CVSup, чтобы иметь исходные тексты версии 2.2-stable. Для вашей первой коррекции используйте cvsupfile подобный этому:

<pre>
    *default host=cvsup2.freebsd.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs
    *default delete use-rel-suffix
    src-all tag=RELENG_2_2_5_RELEASE list=cvs:RELENG_2_2
</pre>

<p>Для последующих коррекций, измените последнюю строку на:

<pre>
    src-all  tag=RELENG_2_2
</pre>

<p>Неупомянутые детали в этой последней строке. Прежде всего, где Вы можете узнать какой параметр описания tag следует использовать?
Ответ:  Вы должны обратиться к списку раздела CVSup главы "Конфигурация" в <a href="http://www.freebsd.org/handbook/cvsup.html">справочнике FreeBSD</a> для того, чтобы найти список описаний tag, которые можно указать для обновления исходных текстов FreeBSD. Важный момент в том, что описание tag для вашей первой коррекции должно соответствовать версии исходных текстов, которые Вы уже имеете.
Описание tag во время вашей второй и последующих коррекций должен соответствовать версии 
исходных текстов, которые Вы хотите получить.

<p>Второе, что это за дела с ключевым словом "list"? Это описание используется редко, но это - ситуация где это необходимо использовать. Когда CVSup создает или обращается к одному из своих файлов checkouts, он использует имя файла, который по умолчанию базируется на описаниях "release" и "tag". Обычное имя файла checkouts - "checkouts.RELEASE:TAG", где RELEASE и TAG - это "release" и "tag" установочные параметры в вашем cvsupfile.

<p>В достаточно специфической ситуации, которую мы описываем здесь, соглашения присваивания имен для файлов checkouts могут вызвать проблему. По умолчанию, наша первая коррекция должна произвести файл названный "checkouts.cvs:RELENG_2_2_5_RELEASE", а вторая коррекция должна найти файл названный "checkouts.cvs:RELENG_2_2". Для того чтобы вторая коррекция принесла пользу с информацией заложенной в первой коррекции, обе коррекции должны использовать один и тот же файл checkouts. Указание атрибута "list" в первом случае позволит нам выполнить именно это. Он аннулирует встроенный суффикс от имени файла checkouts, и заставляет использовать "специальное" имя, которое будет использоваться при последующих коррекциях.

<p>По всеобщему признанию, это заумно. Но Вы должны сделать это только один раз.

!q adoptupgrade
Как мне адаптировать мои исходные FreeBSD-2.2.5, и скорректировать их непосредственно в
FreeBSD-current?

Следуйте <a href="#adopt">вышеизложенным инструкциям</a>, но измените <tt>src-all</tt> строку на нижеследующую. При первой коррекции, используйте:

<pre>
    src-all tag=RELENG_2_2_5_RELEASE list=cvs:.
</pre>

При последующих коррекциях, используйте:

<pre>
    src-all tag=.
</pre>

Тщательно проверьте описание параметра tag=. Будьте внимательны!

!s Понимание cvsupfiles
!q default
Что это за "*default"-подстроки в cvsupfile?

Здесь нет ничего особенного. Вот cvsupfile:
<pre>
    *default host=cvsup3.freebsd.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs
    *default delete use-rel-suffix
    *default tag=.
    src-all
</pre>
Это описание можно записать и в одну строку:
<pre>
   src-all host=cvsup3.freebsd.org base=/usr prefix=/usr release=cvs delete use-rel-suffix tag=.
</pre>

<p>Использование "*default"-подстрок делает ваш cvsupfile более читаемым.
Эти подстроки сделают ваш cvsupfile более кратким, если Вы получаете различные наборы файлов.

!q delete
Что делает ключевое слово "delete" в cvsupfile?

Такая инструкция дает CVSup право удалять файлы на вашей машине.
Например, положим у вас есть файл "foo", который Вы первоначально получили,
используя CVSup. Теперь владелец сервера удаляет файл "foo". После этого, когда
Вы используете CVSup, если опция "delete" определена в вашем cvsupfile, то CVSup
удалит файл "foo" на вашей машине. В противном случае CVSup оставит этот файл.
<p>
Вы всегда должны указывать опцию "delete" в вашем cvsupfile, кроме некоторых
необычных случаев.
!q delnotdflt
Если я всегда должен определять "delete", тогда почему эта опция не выставлена по умолчанию?

Первоначально CVSup разрабатывался для замены sup. Поэтому, установки по-умолчанию
должны иметь такой же смысл.

!s "Ненужные" Файлы
!q refuse
Помогите! Я не могу отказаться от "ненужных" файлов.

Не огорчайтесь. Многие люди ошибаются. На самом деле эта штука работает.

<p>
Список наиболее частых ошибок, возникающих при работе с файлами-отказниками:

<p>
<ol>
<li>Определение образцов некорректно.
<li>Описания "ненужных" файлов находятся в неправильной директории.
<li>Описаниям "ненужных" файлов даны неправильные имена.
</ol>
<p>
Мы расскажем об этих проблемах в следующих пунктах. 
!q refuse-patterns
Как мне определить образцы в файле refuse?

Самое главное - запомнить, что образцы в файлах refuse следует описывать
относительно префикса, который чаще всего не является логическим корнем конкретного набора.
Для того чтобы определить префикс, посмотрите на ваш cvsupfile. Если он содержит 
что-то такое: 

<pre>
    *default prefix=<em>/some/directory</em>
</pre>

то это и будет префикс. В этом случае <em>/some/directory</em> - префикс.
В противном случае, префикс - такой же, как и <em>base</em>. Чтобы определить base,
прочтите <a href="#refuse-where">это</a>.

<p>
Как только Вы определили ваш префикс, зайдите в эту директорию. Вычислите относительные маршруты файлов и/или директорий, которые Вы хотите заблокировать, и сделайте образцы, которые сочетаются с префиксом. Установите эти образцы в ваш refuse-файл, разделяя их пробелом. Положите в refuse-файл каждый получившийся образец в отдельной строке или установите разделитель между образцами. Это точно будет работать. 
!q refuse-example
Что вы можете сказать о примере файла refuse?

<p>
OK. Полагаем, что Вы используете CVSup, для того, чтобы получить файлы документации FreeBSD
(наполнение "doc-all"), используя пример <em>doc-supfile</em> из <em>/usr/share/examples/cvsup</em>.
Вот так выглядит cvsupfile (комментарии удалены):

<pre>
    *default host=CHANGE_THIS.FreeBSD.org
    *default base=/usr
    *default prefix=/usr
    *default release=cvs tag=.
    *default delete use-rel-suffix
    *default compress
    doc-all
</pre>

Как Вы видите, префиксом является <em>/usr</em>. Относительно него,
наполнение "doc-all" устанавливается в поддиректорию <em>doc</em>, который содержит
следующие файлы и подкаталоги:

<pre>
    FAQ/                    handbook/               ru_SU.KOI8-R/
    Makefile                ja/                     sgml/
    en/                     ja_JP.EUC/              share/
    en_US.ISO_8859-1/       ja_JP.eucJP/            zh/
    es/                     ru/                     zh_TW.Big5/
    es_ES.ISO_8859-1/       ru_RU.KOI8-R/
</pre>

 Теперь будем полагать, что Вы не заинтересованы в испанской, японской, русской
 и тайваньской версиях документации. Итак, Вы хотите отказаться от директорий, 
 имена которых начинаются с "es", "ja", "ru", и "zh". Формируем корректировку
 относительно префикса:
<pre>
    doc/es*
    doc/ja*
    doc/ru*
    doc/zh*
</pre>
!q refuse-blockfiles
Мой refuse файл работает для директорий, но мне кажется, что я не могу
заблокировать индивидуальные файлы.

Образцы, которые Вы определяете, должны быть похожи на имена файлов на <em>сервере</em>.
Если файлы исходят из CVS хранилища (обычный случай), тогда на сервере
- файлы RCS. А файлы RCS всегда имеют имена, которые заканчиваются в ",v".
Вы должны иметь это в виду.

<p>
Например, полагаем, что Вы захотите заблокировать <em>Makefile</em>
в вышеуказанном примере. Образец "<tt>doc/Makefile</tt>" не будет работать,
поскольку на сервере файл имеет имя "<tt>doc/Makefile,v</tt>".
Правильный образец, чтобы использовать,

<pre>
    doc/Makefile,v
</pre>

или (что лучше)

<pre>
    doc/Makefile*
</pre>

Имя файла на сервере удовлетворяет последнему образцу независимо от того, файл RCS там или нет.
!q refuse-comments
Почему мой refuse файл блокирует некоторые файлы, образцы которых не содержатся
ни в одном из файлов?

Возможно вы попытались добавить комментарий в ваш refuse файл. Но
(сюрприз!) refuse файлы не понимают комментарии. Этот ваш
"комментарий" воспринимается за шаблоны, которые содержатся в именах файлов,
получаемых вами.

<p>Вот как выглядит <b>неправильный</b> refuse файл:

<pre>
    # Мы принимаем всё (src и ports), исключая games
    src/games
</pre>

Эта безвредно выглядящая строка <em>не</em> комментарий. Это
один из 13 шаблонов, включая "#", "src", и "ports". Это
скорее всего то, что вы искали.

<p>Может быть когда-нибудь добавить комментарий станет возможно, но
сейчас это запрещено.

!q refuse-where
Где я должен установить мои refuse файлы?

Сначала Вы должны определить вашу директорию <em>base</em>.

<p>
<ol>
<li>Когда Вы выполняете программу "cvsup", используете ли Вы опцию "-b
<em>pathname</em>"? (Большинство пользователей не используют.)
Если да, то - <em>pathname</em> является <em>base</em>.
В противном случае... 
<p>
<li>Содержит ли Ваш cvsupfile спецификацию "base=pathname"? (У многих именно так.)
Если да, то <em>pathname</em> является <em>base</em>.
В противном случае...
<p>
<li><em>base</em> - встроено по умолчанию, "/usr/local/etc/cvsup".
</ol>

<p>
Затем Вы должны определить <em>collDir</em>, поддиректорию
<em>base</em>, где CVSup ведёт историю ваших наборов.

<p>
<ol>
<li>Когда Вы исполняете программу "cvsup", используете ли Вы опцию "-c
<em>directory</em>"?  (Обычно нет.) Если да, то
<em>directory</em> является <em>collDir</em>. В противном случае...
<li>У вас <em>collDir</em> - встроено по умолчанию, т.е. "sup".
</ol>

<p>
Наконец, Вы должны знать имя набора, который Вы хотите ограничить, например, "doc-all".

<p>
Объедините эти три пункта с разделителем, напишите "refuse" в конце.
Здесь и следует держать файл refuse. Пример, которым воспользовались,
 работает с 
<pre>
 /usr/sup/doc-all/refuse
</pre>
 только тогда, когда Вы не используете опции "-b" или "-c".
!q refuse-global
Можно ли создать глобальный файл refuse, который будет относиться ко всем
наборам?

Да. Просто пропустите имя набора и разделитель "/", когда Вы формулируете
имя файла. В предшествующем примере, глобальный файл refuse должен быть

<pre>
    /usr/sup/refuse
</pre>

!s CVSup и Firewall'ы
!q fwtk
Как мне заставить работать CVSup, через мой TIS FWTK firewall?

Следуйте инструкции, любезно предоставленной Alan Strassberg:
<p>
<ol>
<li>Добавьте следующую строку к /etc/services:
<pre>
    cvsup 5999/tcp # CVSup
</pre>
<p>
<li>Следующую строку добавьте в /etc/inetd.conf:
<pre>
 cvsup stream tcp nowait root /usr/local/etc/plug-gw plug-gw cvsup
</pre>
 и пошлите сигнал SIGHUP демону inetd.
<pre>
# kill -HUP `ps ax | grep inetd | grep -v grep | awk '{ print $1; }'`
</pre>
<p>
<li>Добавьте следующую строку к /usr/local/etc/netperm-table
(или другому файлу в зависимости от вашей системы):
<pre>
    plug-gw: port cvsup A.B.C.D -plug-to W.X.Y.Z -port cvsup
</pre>
где <em>A.B.C.D</em> - IP адрес внутренней машины, а <em>W.X.Y.Z</em> - IP адрес CVSup сервера.
<p>
<li>Скажите в вашем cvsupfile, что CVSup сервер, это ваш firewall:
<pre>
    *default host=gatekeeper.foo.com
</pre>
<p>
<li>Когда Вы запускаете cvsup, добавьте опции "<em>-P m</em>" в командной строке.
</ol>

<p>
Диагностика: Запустите telnet с машины из внутренней сети на firewall:5999
и вы увидите приветствие сервера CVS:
<pre>
    % telnet gatekeeper.foo.com 5999
    OK 15 5 REL_15_4_2 CVSup server ready
</pre>
Если приветствие не появляется, выполните <tt>netstat -na</tt> на firewall
 и проверьте, слушает ли он порт 5999:
<pre>
    % netstat -na | grep 5999
    ...
    tcp   0  0  *.5999		*.*		LISTEN
 </pre>
!s Проблемы при использовании CVSup
!q cksum
Почему CVSup вдруг начинает выдавать мне массу сообщений,
таких как "Checksum mismatch -- will transfer entire file"
("несовпадение контрольной суммы - файл будет передан полностью")?
Каждый файл получает "fixup", и это действительно замедляет коррекцию моих
наборов файлов.

Вам и вашему дружественному (:-))) администратору сервера следует модернизировать CVSup до версии
15.4 или более поздней. Это решит эту проблему.

<p> CVSup модернизирует файл RCS следующим образом: деконструирует этот файл на сервере,
посылает изменившиеся части клиенту, и восстанавливает файл на стороне клиента.
(Это похоже на транспортер на предприятии межзвездных кораблей).
Затем CVSup сравнивает MD5-контрольную сумму восстановленного файла с
подлинником на сервере, чтобы убедиться, что процесс отработал правильно.

<p> К несчастью, последние версии CVS ввели некоторые безвозвратные изменения в формат
файлов RCS. Эти изменения касаются пробелов, которые никак не отражаются
на логическом значении файла. Тем не менее, как результат, файл RCS, созданный
CVSup-клиентом не соответствует побайтно исходному файлу.
Даже если восстановленный файл логически идентичен подлиннику, он имеет другую
контрольную сумму. Более старые версии CVSup отвергали скорректированный файл и
использовали fixup, для того чтобы вновь передать файл целиком.

<p> Для решения этой проблемы, в CVSup 15.4 введено понятие <em>логической</em> контрольной суммы,
которая используется только для RCS-файлов. Вместо слепой побайтной обработки
контрольной суммы над целым файлом, новый алгоритм контрольной суммы тщательно
канонизирует файл так, что несоответствующие различия интервала проигнорированы.
Логическая контрольная сумма должна сделать CVSup устойчивым к любым возможным
проблемах этого рода.

!q fwhang
Когда я пытаюсь запустить CVSup, он сообщает мне о подключении к серверу,
 но потом просто виснет. В чем дело?

Скорее всего, Вы находитесь за firewall, который блокирует попытки CVSup-сервера
установить второе TCP-соединение к вашему клиенту. Добавьте опцию "<tt>-P m</tt>" в командную
строку <tt>cvsup</tt>, и все должно заработать.

!q debugkernel
Всякий раз, когда я запускаю CVSup под FreeBSD, я получаю огромное количество
сообщений, подобных этому: <tt>fatal process exception: page fault, fault VA = 0x11a610</tt>.

<p>
Когда Вы собирали ядро для FreeBSD, Вы включили недокументированную "<tt>options DEBUG</tt>"
в конфигурационный файл. Больше так не делайте. 

!q bsdos
Я попытался запустить исполняемый файл CVSup-клиента для FreeBSD под BSD/OS,
но он падает в core. Почему он не работает?

Да, статически слинкованные исполняемые файлы FreeBSD работают на других
*BSD операционных системах. Но на некоторых из них, включая BSD/OS,
Вы должны добавить "<tt>@M3novm</tt>" в командной строке.

<p>
CVSup написан на Modula-3, и система использует умный мусорщик, который использует
захваты в подсистему VM операционной системы, чтобы приобрести
лучшее диалоговое исполнение. Эта характеристика спотыкается на несовместимости
между BSD/OS и FreeBSD, вызывая падение в core. Загадочный аргумент "<tt>@M3novm</tt>"
исключает захваты VM, что и делает возможным выполнять исполняемые файлы FreeBSD
под другими BSD-подобными операционными системами.

<P>Также, последние версии (4.0 и более поздние) BSD/OS не могут запускать
бинарные файлы FreeBSD в формате ELF. Но они могут выполнять старые файлы формата
<tt>a.out</tt> без каких-либо проблем.
!q gui-dns
CVSup-клиент умирает с сообщением о нарушении целостности (segmentation violation) когда я пытаюсь использовать ГПИ (aka GUI).

Сообщение выглядит так?
<pre>        
    ***
    *** runtime error:
    ***    Segmentation violation - possible attempt to dereference NIL
    ***    pc = 0x81f0708 = Cat + 0x18 in /b/jdp/pm3/pm3/libs/m3core/src/text/Text.m3
    ***      
      use option @M3stackdump to get a stack trace
    Abort trap (core dumped)
</pre>
Это ошибка в графической библиотеке Modula-3, которая сообщает
о неправильной настройке DNS. Если говорить детально, ошибка
говорит об отсутствии реверсивной записи в DNS вашего IP адреса.
Попробуйте выполнить нижеследующие команды для проверки установок
DNS. (Если в вашей системе отсутствует команда "host", используйте
"dig" или "nslookup".)
<pre>   
    $ hostname
    bogus.example.com
             
    $ host bogus.example.com
    bogus.example.com has address 192.168.1.1
             
    $ host 192.168.1.1
    Host not found, try again.
</pre>
Последняя строка указывает на проблему. Если ваш DNS установлен
правильно, вы должны увидеть следующее
<pre>        
    1.1.168.192.IN-ADDR.ARPA domain name pointer bogus.example.com
</pre>
Правильный путь для устранения этой проблемы - исправить установки DNS.
(Соответствующие рекомендации вы можете получить у системного администратора.) Если
это невозможно, вы можете устранить эту проблему добавив строку
в ваш "/etc/hosts" файл. И всё-таки, если эту проблему невозможно
устранить, запустите CVSup клиента без ГПИ (aka GUI) добавив "-g"
в командной строке.
<p>
Когда-нибудь я устраню эту проблему в графической библиотеке.
!q linux-dns
Исполняемый файл для Linux с CVSup ftp-сервера не может выполнить запрос к DNS на моей Linux системе.

Проверьте FTP сервер ещё раз на предмет новых исполняемых файлов. Эта
проблема возникает ввиду несовместимости между некоторыми Linux ядрами
и некоторыми версиями glibc. Новая версия (распространяется начиная с
20 февраля 2000 года) динамически слинкована с C библиотекой, и она
должна работать на разных версиях Linux. 
!q nomem
CVSup (как клиент, так и сервер) умирают с сообщением "gc: Could not extend the traced heap".

Это странное, на первый взгляд, сообщение говорит вам о том, что памяти не хватает. Попробуйте
уточнить лимиты на ресурсы и сделать их побольше. В шеллах, порождённых от sh, 
используйте "ulimit -Sa" для уточнения параметров "datasize" и "memoryuse".
В шеллах, порождённых от csh, используйте команду "limit" для
проверки параметров "data seg size" и "max memory size".
!q dragonint
CVSup клиент периодически умирает ввиду выхода за пределы DragonInt.m3

Это ошибка в исходных текстах Modula-3 runtime. Заберите новый
исполняемый файл с CVSup FTP-сервера. Или используйте
<a href="http://www.research.digital.com/SRC/modula-3/html/patches.html#dragonInt">это исправление</a>
для ваших исходных текстов Modula-3, затем пересоберите и переустановите Modula-3.

<p>
Для быстрого устранения проблемы просто запустите CVSup клиента без
ГПИ (aka GUI) добавив "-g" в командной строке.
!q os-change
Я переместил CVSup зеркало, которым я управляю, на другую ОС и теперь
CVSup (клиент и/или сервер) постоянно падают.

Если вы переместили ваш сайт с таким платформ как FreeBSD, NetBSD, OpenBSD или BSD/OS 
на не-BSD систему, проблема в файлах отладки ("checkouts"), о которых вы уже слышали.
Они содержат некоторую информацию которую не-BSD версии CVSup'а не поддерживают.
Эта фишка - ошибка и она присутствует в версиях 16.1 и ниже. Эта ошибка будет исправлена
и эта проблема устранится начиная с версии 16.2. До той поры, вам проще обойти эту проблему
путём удаления "checkouts*" файлов из вашей <em>base</em> директории, что заставит
CVSup переделать эти файлы.
!q setattrs
Иногда, когда я запускаю CVSup клиента, он выдаёт сообщение "SetAttrs" на каждом файле.

Обычно такое происходит, когда CVSup думает, что следует изменить
один или несколько атрибутов файла (права владельца, группы, разрешения и т.п.)
но не может этого сделать. Атрибуты файла могут быть неправильными, или
записи в файле отладки ("checkouts") могут быть неверными.
Проверьте следующее:
             
<p>
<ul>
<li>Вы иногда выполняете изменения от пользователя root (например, из cron'а),
а другие изменения вы производите от другого пользователя. Во время
исправления от пользователя root, владельцем файла становится root.
А позднее, вы под другим пользователем исправляете эти файлы.
<p>          
<li>Вы, используя  различные установки umask, иногда запускаете 
CVSup.  Простой выход обновить версию CVSup. Добавьте
"*default umask=2" (pick your desired value) в начало вашего supfile.
<p>          
<li>Ваши файлы отладки ("checkouts")  в каталоге "base" имеет разрешения,
запрещающие CVSup'у писать в них.
</ul>
!q missingtag
Я попытался скорректировать мои файлы с помощью CVSup, но все что я получил,
это мешок (вагон и маленькая тележка:-) странно выглядящих файлов, чьи имена
заканчиваются на ",v". Почему?

Эти странные файлы - файлы <a href="#RCS">RCS</a>, и CVSup прислал их Вам, поскольку ваш cvsupfile
сообщил ему об этом. Когда Вы просите CVSup прислать Вам коррекции из CVS-хранилища,
есть две абсолютно разные вещи, которые Вы можете потребовать.
Во-первых, Вы можете попросить исходные файлы, которые должны извлекаться из хранилища
и посылаться Вам. Это, очевидно, то, что Вы хотели. Во-вторых, Вы можете потребовать
"сырые" файлы RCS (содержащие все версии исходных текстов), которые также могут быть
присланы Вам.

<p>Эти два режима функционирования коренным образом различаются.
Оба работают на основе RCS-файлов в CVS-хранилище на стороне сервера.
Но они используют RCS-файлы по-разному. Первый режим называется "checkout режим":
вызывается конкретная версия исходных текстов из файлов RCS, и эта версия посылается Вам.
Второй режим называется "режим CVS". В этом режиме Вам посылаются сами файлы RCS, в той же форме,
как и на сервере. В cvsupfile, ключевые слова "tag"  и "date" контролируют
выбранный вами режим. Если любое из этих ключевых слов присутствует, то
CVSup использует checkout режим, чтобы прислать Вам комплект исходных файлов.
Если и "tag", и "date" отсутствуют, то CVSup использует режим CVS, чтобы послать Вам файлы RCS.

<p>Если вы хотите получить самые последние версии файлов, то вам следует добавить
ключевое слово "tag=." в ваш supfile.
!q s1gbug
CVSup неожиданно начал устанавливать дату на изменённых файлах в 1970 год!

Дело в ошибке, до этого момента находящейся в летаргическом сне.
Эта ошибка присутствует во всех версиях до <tt>SNAP_16_1d</tt>.
Вам необходимо обновить как клиентскую, так и серверную части до
версии <tt>SNAP_16_1d</tt> для того, чтобы устранить эту проблему.
(Новые версии, которые будут выпущены после <tt>SNAP_16_1d</tt>,
будут содержать исправление этой ошибки.)

Подробности и дистрибутив <tt>SNAP_16_1d</tt>, как в исходных текстах, так
и бинарной форме, вы можете получить посетив
<a href="http://people.freebsd.org/~jdp/s1g/">http://people.freebsd.org/~jdp/s1g/</a>.
!s Файлы отладки
!q whatarecheckouts
Что такое файлы отладки (checkouts), о которых я тут слышал?

Для эффективной корректировки ваших файлов,  CVSup должен знать что Вы хотите получить. Он загружает эту информацию в так называемые файлы "отладки" (checkouts). Всякий раз, когда Вы запускаете cvsup, он читает эти файлы, чтобы увидеть какие файлы (и какие исправленные версии этих файлов) Вы имеете. Как только он корректирует ваши файлы, он также корректирует и информацию в checkouts-файлах.

<p>Также checkouts-файлы иногда именуются как "списки" файлов.
!q lostcheckouts
Всё это страшно. Что если я случайно удалю один из файлов отладки?

Это небольшая проблема. Если CVSup не cможет найти checkout-файл, который ему нужен, он перейдёт к другим методам определения ваших файлов. Один из методов состоит в вычислении контрольных сумм (файловых подписей MD5) для каждого из ваших файлов, и использовании этих контрольных сумм, для вычисления какие исправленные версии файлов Вы имеете. Это действие вполне безопасное, но неэффективное. Оно замедляет скорость коррекции, а также серьёзно загружает сервер.
!q badcheckouts
Что если мои файлы отладки каким-то образом исказятся?

CVSup обнаружит проблему и завершит свою работу с предложением удалить повреждённый файл, а после этого снова попытаться запустить CVSup. Если Вы последуете этому предложению, он завершит вашу коррекцию, используя методы аварийного перехода, упомянутые выше, и воссоздаст ваш checkout-файл для следующего раза.
!q extrafiles
А что ещё "неправильного" может произойти, если я потеряю файлы отладки?

Есть ещё одна вещь, которая может произойти, но это не очень существенно.
CVSup удалит лишь файлы, которые указаны в его checkouts-файле. Таким образом, если Вы потеряете ваш checkouts-файл, а затем файл "foo" удаляется на стороне сервера, то после выполнения CVSup, ваш файл "foo" не будет удален.

<p>Файл никогда не будет удалён из CVS-хранилища, но, в действительности, это несущественно. Чтобы быть уверенным в полной мере, Вы должны выполнить CVSup как можно раньше, т.е. как только Вы узнали о потере checkouts-файла, немедленно приступите к процедуре коррекции.
!s Локальные изменения в вашем CVS хранилище
!q canilocal
Могу ли я как-то отслеживать мои собственные изменения в CVS хранилище, когда я произвожу накат из главного хранилища?

Если вы осторожны и если вы понимаете что происходит за сценой, вы можете сделать это. CVSup разрабатывался
для локальных проверок в соответствии с RCS файлами, взятыми из основного хранилища.
Поскольку CVSup понимает структуру RCS файлов, он может произвести новые исправленные
издания с сервера, не мешая вашим собственным исправленным изданиям, которые Вы изменили у себя.
К несчастью, определённые логические вопросы делают эту возможность неудобной, для того, чтобы использовать её в практических ситуациях.

<p>Для сохранения локальных исправленных версий в вашей копии хранилища CVS, Вы должны:

<p>
<ul>
 <li>Указать CVSup не удалять их.
 <li>Гарантировать, что номера версий ваших локальных исправлений не противоречат номерам текущих или будущих исправлений каждого RCS файла на сервере.
</ul>

<p>
 Ниже мы расскажем как это можно сделать.
!q nodelete
Как мне удержать CVSup от удаления локально исправленных изданий?

<p>Просто удалите ключевое слово "delete" из вашего cvsupfile. Присутствие
этого ключа даёт CVSup право удалять исправления из RCS файлов. Также этот
ключ разрешает CVSup удалять целиком файлы RCS, при условии, что он создаст
их заново. Если вы уберёте ключ "delete", вы предохранитесь от удаления
CVSup'ом локально исправленных изданий, а также RCS файлов.
Тем не менее, очень важно понимать последствия удаления ключевого слова "delete".

<p>Сначала, положим, что один из множества RCS файлов был удалён из хранилища CVS на стороне главного сервера. Без
ключа "delete" CVSup не сможет удалить соответствующий файл в вашей локальной копии. Таким образом Вы будете иметь
некоторые файлы RCS в вашем хранилище, которых, в противном случае, там не было бы.

<p>В идеальном мире, это не проблема. Потому что, в идеальном мире никто
не удаляет RCS файл из CVS хранилища. Таким образом, такая ситуация не должна возникать никогда.

<p>К несчастью, большинство администраторов управляют своим хранилищем не так идеально,
как хотелось бы. Коммиттеры делают ошибки и устанавливают файлы в неправильно.
Большинство администраторов вручную исправляют такие ошибки, перемещая
файлы в хранилище, а некоторые ошибки продолжают жить. Другой пример, в любом большом
хранилище, некоторые файлы в конечном счете становятся полностью устаревшими. В итоге,
разработчики пожалуются на неиспользуемое дисковое пространство
и бардак в хранилище, и администратор хранилища, в ответ на их запрос, удалит файлы.

<p>Обычно, восстановленные RCS файлы не вызывают никаких проблем и их можно благополучно игнорировать.
Это особенно верно если администратор хранилища основного сервера был осторожным, чтобы выделить "мёртвые" файлы
на всех ветках с выполнением команды "cvs remove" на несколько недель раньше, чем полностью удалить нежелательные файлы RCS.
Тем не менее, дополнительные файлы RCS могут вызвать проблемы в некоторых случаях, и Вы должны знать об этом.
!q revconflicts
Как мне защитить исправленные издания моих локальных регистраций от противоречий с номерами исправленных изданий, порождающимися на основном сервере?

Это трудно, поскольку CVS выбирает очередной номер версии сам. Один из путей - немного исправить CVS.
Прежде, чем обсуждать это, создайте новую ветку, где вы будете держать ваши локальные изменения.
Не пытайтесь проверить ваши локальные изменения в основной ветке или в ветке, которая существует в основном хранилище.
Если вы так сделаете, то, скорее всего, рано или поздно, возникнут коллизии.

<p>
Если ваши локальные исправленные издания находятся на своей собственной ветке, то проблема сводится к гарантии,
что ваша ветка имеет уникальный номер исправленного издания, который никогда не задублируется с номером в основном хранилище.
Наилегчайший путь - модифицировать CVS. Версия CVS (в составе дистрибутива FreeBSD) включает такую модификацию.
В этой версии, Вы можете влиять на номера исправленных изданий ответвлений, устанавливая внешнюю переменную CVS_LOCAL_BRANCH_NUM.

<p>
Эта переменная должна устанавливаться в целое, и CVS будет использовать её, как отправной пункт,
выбирая номер для исправленного издания в новых ветках. По умолчанию, CVS распределяет отраслевые номера начинаемые с 1.
Следовательно, много большее число, как например, 1000 - хороший выбор. Новые ветки получат меньшие номера,
когда ваши собственные локальные ветки получат большие номера исправленного издания. Таким образом эти ветки не будут противоречить друг другу.

<p>
Используя этот метод, коммиттеры не должны устанавливать CVS_LOCAL_BRANCH_NUM
создавая ветки в основном хранилище.

<p>
Если у Вас нет версии CVS, которая поддерживает CVS_LOCAL_BRANCH_NUM,
то можно избежать конфликтов с помощью сотрудничества с основным сервером.
Просто создайте ветку в основном хранилище, объявите что, она зарезервирована для локальных модификаций,
и не используйте её в основном хранилище.

!s Установка CVSup сервера
!q testserver
Как мне определить простой набор для тестирования CVSup сервера?

<p>
Создайте где-нибудь пустую директорию. Мы будем называть её <em>base</em>. Зайдите в <em>base</em>и выполните
команду <tt>mkdir -p sup/test</tt>.

<p>
Затем, зайдите в <tt>sup/test</tt> и создайте файл с названием <tt>releases</tt> с единственной
строкой, такой как эта:

<pre>
    cvs list=list.cvs prefix=<em>prefix</em>
</pre>

В дальнейшем, замените <em>prefix</em> на абсолютный путь к некоторому хранилищу CVS на вашей машине, <tt>/usr/cvs</tt>.
Если у Вас нет хранилища CVS, вы можете использовать любую директорию, содержащую несколько файлов. Но RCS файлы - лучшее
средство для тестирования.

<p>
В директории, где находится файл <tt>releases</tt>, создайте файл <tt>list.cvs</tt>. В нём должна содержаться
единственная строка:

<pre>
    upgrade src/bin
</pre>

Здесь, замените <tt>src/bin</tt> на некоторый путь к поддереву вашего хранилища CVS, родственному с <em>prefix</em>.
Например, если <em>prefix</em> это <tt>/usr/cvs</tt> в вашем <tt>releases</tt> файле, и строка в <tt>list.cvs</tt> такая,
как было сказано выше, то поддерево, которое можно будет "забрать", имеет вершину <tt>/usr/cvs/src/bin</tt>.

<p>
Вы только что создали коллекцию CVSup "test" c release названием "cvs". Вы можете запустить сервер так:
<pre>
    cvsupd -b <em>base</em>
</pre>
заменив <em>base</em> на путь к base директории, которая была создана ранее. Если Вы сделали всё правильно, то <tt>cvsupd</tt>
будет печатать сообщения на stdout, обслужит одного клиента и завершит работу. Для нескольких тестирований подряд,
Вам придётся рестартовать сервер несколько раз. Альтернативный путь, запустить сервер так:

<pre>
    cvsupd -b <em>base</em> -C 1 -l /dev/stdout
</pre>

Сервер станет даймоном и будет обслуживать клиентов до тех пор, пока Вы собственноручно его не убьёте. Замечание, 
местонахождение рабочей директории не зависит от места запуска сервера.

<p>
Сейчас, Вы можете создать отдельную пустую директорию для запуска
клиента, для получения дополнений с сервера. Мы назовём эту директорию
<em>dest</em>.  В <em>dest</em>, создайте файл <tt>supfile</tt>, который
будет выглядеть так:

<pre>
    *default host=localhost
    *default base=.
    *default release=cvs
    *default delete use-rel-suffix
    test
</pre>

(Замечу, что здесь "." в "<tt>base=.</tt>".)

Проверяем, что сервер запущен, а затем, находясь в <em>dest</em>, запускаем
<tt>cvsup</tt> как обычно.  Самый простой способ:

<pre>
    cvsup supfile
</pre>

но Вы, если хотите, можете добавить <tt>-g -L 2</tt> для подавления GUI.

<p>
Если вы запустили CVSup клиента, собранного с GUI, нажмите кнопку start.
Не-GUI клиент запустится автоматически. Индикатор диска включится
на 50 ватт и жёсткий диск начнёт шуметь, говоря вам "Я на самом деле, абсолютно
точно, <em>реально</em> занят." Когда шум прекратится, вы найдёте в директории
<em>dest</em> свежие файлы. Появится директория <tt>sup</tt>
в которой <tt>cvsup</tt> сделает записи состояния.

<p>
Надеюсь это сработает и вы сможете провести более тщательное
испытание, чем это. При манипулировании исходными RCS файлами,
вы можете добавлять дельты и/или таги, убеждаясь, что всё получается
как надо в момент следующего "наката". Вы также можете попробовать
удалить RCS файлы и добавить несколько новых. На стороне клиента
вы можете добавлять <tt>tag=</tt> и/или <tt>date=</tt> директивы в supfile.
Главное состоит в том, что если программное обеспечение работает на вашей платформе,
это значит, что работа по настройке сервера выполнена. Практически вся
функциональность базируется коде, независимом от операционной системы.

<p>
Одно предостережение: Выполнение "наката" на одной машине через localhost
очень сильно нагружает систему, особенно дисковую подсистему и сетевой стек.
Будут показаны все ошибки операционной системы, которые ранее были неизвестны.
Если у вас возникли околосетевые проблемы, возможно вам поможет использование
<tt>-P m</tt> в командной строке <tt>cvsup</tt>.

!q serversample
Где Я могу найти комплект CVSup файлов конфигурации сервера, чтобы использовать в качестве примера?

Файлы конфигурации сервера, используемые проектом FreeBSD доступны через CVSup с любого зеркала FreeBSD. Для того, чтобы сделать копию, зайдите в пустую директорию и создайте файл <tt>supfile</tt>, содержащий такой текст:

<pre>
    *default host=<em>a.mirror.site</em> compress
    *default release=cvs tag=.
    *default base=.
    *default delete use-rel-suffix norsync
    distrib
</pre>

Замените <em>a.mirror.site</em> любым <a href="http://www.freebsd.org/handbook/mirrors.html">CVSup, указанным в Справочнике FreeBSD</a>.
Запустите CVSup клиента, использующего этот <tt>supfile</tt>. Когда он завершит свою работу, Вы найдете файлы конфигурации
в поддиректории <tt>distrib/cvsup</tt>. Если Вы хотите использовать именно эти файлы конфигурации,
Вы должны использовать эту поддиректорию как вашу <em>base</em> директорию, подобно этому:

<pre>
    cvsupd -b distrib/cvsup <em>...</em>
</pre>

В реальной установке, Вы должны определить базовую директорию как полное составное имя.
!s Построение CVSup из исходных текстов
!q notc
Я слышал массу ужасных рассказов о построении CVSup из исходных текстов. Почему так?

Основная проблема в том, что CVSup написан на языке программирования NotC. Что такое NotC? Хорошо, для большинства людей,
это действительно не имеет значения. Самое главное то, что NotC <strong>не C</strong>. Следовательно, нужна
небольшая дополнительная работа, чтобы использовать это.
<p>

В случае CVSup, NotC это Modula-3. Modula-3 - эффективный язык программирования с отличной встроенной поддержкой
таких важных характеристик как, например, сборка мусора и нити (threads). За более подробной информацией о Modula-3,
обратитесь на <a href="http://www.research.digital.com/SRC/modula-3/html/home.html">
Modula-3 Home Page</a>.

<p>
К счастью, существуют порты Modula-3 для <a href="http://www.research.digital.com/SRC/modula-3/html/platforms.html">многих платформ</a>.
Если порт для вашей платформы уже есть, то тогда Вы уже прошли самый большой барьер в построении CVSup.

<p>
Вторая проблема, с которой встречаются многие люди, в том, что построение компилятора и runtime Modula-3 требует много виртуальной памяти.
Вам нужно порядка 64 MB доступной виртуальной памяти. (Построение CVSup менее требовательно.) Вы также должны
гарантировать, что ресурсов достаточно. Ими можно управлять с помощью команды "ulimit" в <tt>sh</tt>-подобных
оболочках, или командой "limit" в <tt>csh</tt>.

<p>
Третье, по умолчанию у Вас должны быть установлены X11 в вашей системе, чтобы сформировать runtime Modula-3.
Можно формировать Modula-3 без X11, и чтобы сделать так, Вы должны отредактировать файл <tt>m3/src/m3makefile</tt> и
закомментировать пакеты, которые зависят от X11.
<p>
!q fromsource
Какие шаги следует проделать для построения CVSup из исходных текстов?

<ol type="A">

<li>Соберите и установите компилятор и runtime Modula-3. Это самая тяжёлая часть процесса.</li>

<li>Соберите и установите библиотеку сжатия "zlib". Это совсем безболезненно. Подробности смотрите на <a href="http://www.gzip.org/zlib/">домашней странице zlib</a>.</li>

<li>Соберите и установите CVSup. Это также сравнительно безболезненное.</li>
</ol>
!q mswin
Портировали ли CVSup на Windows 95 или NT?

Нет, CVSup к настоящему времени не работает на платформах Windows.
В своей работе CVSup опирается на многие характеристики, которые характерны для POSIX-подобных операционных систем.
!s Совместимость
!q verscompat
Когда выходит новая версия CVSup, надо незамедлительно модернизировать и клиента, и сервер?

Обычно, все ранее вышедшие версии CVSup могли работать друг с другом.
Однако, это стало неприемлемо, в связи с обнаружением несчастной
<a href="#s1gbug">ошибки s1g</a>, которая присутствует во всех версиях
CVsup до <tt>SNAP_16_1d</tt>. CVSup-клиенты, в которых содержится
ошибка "s1g", создают огромную нагрузку на CVSup-серверы.

<p>Для защиты серверов от этой проблемы, начиная с версии <tt>SNAP_16_1e</tt>
была добавлена проверка. Теперь новые CVSup-серверы не разрешают воспользоваться
сервисом, если CVSup-клиенты содержат ошибку "s1g". Когда такой клиент
посылает запрос на сервер с версией <tt>SNAP_16_1e</tt> или выше, сервер
немедленно разрывает соединение и сообщает клиенту о проблеме. В
сообщении содержится информация о возможности получения новой версии CVSup.

<p>CVSup-клиенты также нуждаются в защите серверов со старыми версиями,
которые поставляют файлы с некорректными датами. Итак, дополнительная
проверка была добавлена для клиентов с версии <tt>SNAP_16_1e</tt>.
Если новый клиент соединится к CVSup-серверу, который содержит ошибку
"s1g", клиент укажет на ошибку и немедленно завершит работу.
В сообщении об ошибке содержится описание проблемы и просьба сообщить
владельцу этого сайта, что программное обеспечение его CVSup-сервера устарело.
!q supcompat
Могу ли я использовать CVSup клиента для получения изменений с SUP-сервера?

Нет. Хотя CVSup-клиент умеет пользоваться supfile'ами записанными для SUP, эти два пакета не совместимы.
!s Двунаправленное зеркалирование
!n bidirectional-cani
Можно ли использовать CVSup для зеркалирования изменений
в обеих направлениях между двумя CVS хранилищами?

К сожалению, CVSup не годится для решения этой задачи. CVSup
был разработан исключительно для однонаправленного зеркалирования.
Если Вы хотите использовать его в обеих направлениях, Вы можете
столкнуться с различными проблемами. Например, если конфликтные
изменения внесены в файл, как разрешить эту ситуацию? Возможно,
существует какое-то разрешение этой проблемы, но Вы должны найти
его самостоятельно.

<p>Тем не менее, модифицированная и улучшенная
версия CVSup доступна, это <A HREF="http://www.elegosoft.com/dcvs/">
DCVS (Distributed Concurrent Versions System), (Распределённая
Система Контроля Версий -- прим. переводчика)</A>, которая позволит
установить сеть из DCVS серверов (используя расширенную версию CVSup)
и каждый будет сохранять только специальные диапазоны номеров ревизий,
соответствующие определённым линиям разработки (CVS ветвям).
Подробности <A HREF="#bidirectional-tools">в следующем ответе</A>.

!n bidirectional-tools
Какие инструменты доступны для двунаправленного зеркалирования
CVS хранилищ?

Невозможно зеркалировать CVS хранилище в обоих направлениях
без специальных условий для защиты и сохранения элементов.
Этот проект называется <A HREF="http://www.elegosoft.com/dcvs/">
DCVS (Distributed Concurrent Versions System), (Распределённая
Система Контроля Версий -- прим. переводчика)</A>, он состоит
из модифицированных и расширенных версий CVS и CVSup, позволяющих
синхронизировать сеть DCVS серверов с определёнными линиями
разработки. DCVS доступен как в исходных текстах, так и в 
двоичном виде для разных платформ на сайте
<A HREF="http://www.elegosoft.com/">elego Software Solutions GmbH, Berlin</A>.

<p>DCVS можно получить используя
<A HREF="http://www.elegosoft.com/dcvs/cvsup-dcvs.php3">CVSup</A> или
прочитать
<A HREF="http://www.elegosoft.com/dcvs/doc/dcvs_overview.html">обзор
DCVS</A>.
