%
% Jay Krell
% jaykrell@cornell.edu
% October 18, 2006 in Windows cmd
% ported to Quake December 31, 2006 so it might be run at the right time in a build (ie: the first package, before m3core)
% Possibly also for a hypothetical Windows targeted non-Windows hosted build.
% 
% This is the second stage in producing Windows import .libs.
% Given Quake code snippets output by make-lib-1.cmd, produce
% .c and .def files and compile and link them. The .c files just
% contain empty functions with the right names and the Signatures --
% Signatures just being the right number of bytes of parameters, the
% right types are not needed.
%

%
%
% The .libs that come with CM3 5.2.6 do not work with Visual C++ prior to 5.0, nor with 8.0.
% The Visual C++ 7.1 and 8.0 Express Editions are missing many .libs.
% We are stuck with no /really simple/ solution, but several not too difficult solutions.
%
% We could detect the linker version and accept the 5.2.6 .libs.
%   We presently do no toolset version checking, though this isn't a bad option.
%   Toolset version checking in Quake, cmd, and nmake has been shown to be easy enough.
%
% We could delete the .libs if using Visual C++ 2.0 or 4.0.
%    Again, we don't do toolset version checking.
%
% We could delete the .libs unconditionally and users of Express Editions must
% install the free download Platform SDK.
%    This is not a bad option.
%
% We could detect the linker version and have like \cm3\lib\vc20, \cm3\lib\vc40, \cm3\lib\vc50, etc.
% Some of these directories would be copies of \cm3\lib, others would be generated by make-lib-2.
%
% We could require users (esp. of older toolsets) to run scripts\win\lib\make-lib-2.
%   This is ok. This is almost what we do.
%
% We could run make-lib-2 for folks automatically.
%   That is what we do. This is good.
%
% Future binary distributions should perhaps contain .libs built with the oldest supported toolset (perhaps
%  that is already the case). But this automatic way should be good.
%
%

%
% The kernel32.lib installed by CM3 5.2.6 is missing InterlockedCompareExchange
% that is needed by msvcrt.lib 8.0.
%
% The user32.lib installed by 5.2.6 causes the Visual C++ 4.0 linker to
% have an "internal error".
%
% The wsock32.lib installed by 5.2.6 causes the Visual C++ 4.0 linker to
% error regarding corrupt debugging information.
%
% There are more link errors, make everything.
%

local Files = {
    "advapi32",
    "comctl32",
    "comdlg32",
    "gdi32",
    "glu32",
    "kernel32",
    "netapi32",
    "odbc32",
    "odbccp32",
    "opengl32",
    "user32",
    "winspool",
    "wsock32",
}

%
% NOTE: USE_DLLTOOL does not quite work and USE_LD really does not work.
%
% dlltool's import .libs are broken such that consumption with link
% leads to no actual imports and a crash at runtime. They do work with ld however.
%
% ld is difficult/impossible to convince to generate the correct symbols wrt __stdcall.
%
% The import .libs don't likely matter for NT386GNU, and even for NT386 they rarely matter.
% The main thing is to delete import .libs from older CM3 distributions, and get
% import .libs from either Visual C++ or the Platform SDK or MingGWin or Cygwin or here.
% The main place they are not available is some Visual C++ Express Editions.
%
USE_LINK = TRUE
USE_DLLTOOL = FALSE
USE_LD = FALSE

local Stale = { }
local AnyStale = FALSE

foreach File in Files
    deriveds(File, [ ".obj", ".c", ".cpp", ".def", ".lib", ".dll", ".drv", ".exp", ".m3x" ])
end
deriveds("a", [ ".obj", ".c", ".cpp", ".def", ".lib", ".dll", ".drv", ".exp", ".m3x" ])
deriveds("", [".M3WEB"])
% Older Modula-3 toolsets, such as 5.1.3 from 2001, don't set M3_MODE.
% That is ok, don't /really/ care about it, it just let'a us
% implement "clean" correctly.
if not defined("M3_MODE")
    M3_MODE = ""
end
if equal(M3_MODE, "clean") % or not equal(TARGET, "NT386")
    % neuter the data rather than indent the whole rest of the file
    Files = { }
end

%
% Quake can't do math. We simulate it badly with hash tables and arrays.
%

local readonly Integers = [
"0","1","2","3","4","5","6","7","8","9","10","11","12","13","14","15","16","17","18","19","20"
]

local ReverseIntegers = [ ]

local UpTo = {"0": []}
local DownFrom = {"0": []}

local readonly Times4 = {
 "0": "0", "1": "4", "2": "8", "3":"12", "4":"16", "5":"20", "6":"24", "7":"28", "8":"32", "9":"36",
"10":"40","11":"44","12":"48","13":"52","14":"56","15":"60","16":"64","17":"68","18":"72","19":"76",
}

local Plus1 = { }
local Minus1 = { }
local Divide4 = { }

local proc InitMath() is
    local i = ""
    local j = ""
    foreach j in Integers
        if i
            Plus1{i} = j
            Minus1{j} = i

            u = []
            foreach k in UpTo{i}
                u += k
            end
            u  += i
            UpTo{j} = u
        end
        i = j
    end
    foreach i in Times4
        Divide4{Times4{i}} = i
    end
end

InitMath()

local proc SourceFilePath(a) is
    return ".." & SL & "src" & SL & a
end

%
% This should be built-in.
%
local proc FileExists(a) is
  return not stale (a, a)
end

local proc PickExists(a, b) is
    if FileExists(a)
        return a
    end
    return b
end

local proc ObjFile(a) is
    return PickExists(a & ".obj", a & ".o")
end

%
% These should be large strings that overflows buffers in the Modula-3 code.
%
local CFileContents = []
CFileContents += " #if defined(__cplusplus)" & CR
CFileContents += "extern \"C\" {" & CR
CFileContents += "#endif" & CR
CFileContents += "#pragma warning(disable:4100) /* unused parameter */" & CR
CFileContents += "typedef unsigned u;" & CR & CR

foreach File in Files

    local readonly QuakeFileName = File & ".quake"
    local readonly LibFilePath = File & ".lib"

    if stale(LibFilePath, SourceFilePath(QuakeFileName))

        AnyStale = TRUE

        local readonly DefFilePath = File & ".def"

        include(QuakeFileName)

        local Extension = ""
        local DefFileContents = ["EXPORTS" & CR]

        foreach FunctionName in Files{File}
            if equal(FunctionName, "Extension")
                Extension = Files{File}{"Extension"}
            else
                local Signature = Files{File}{FunctionName}
                if equal(Signature, "__cdecl")
                    DefFileContents += [" " & FunctionName & CR]
                    CFileContents += "void __cdecl " & FunctionName & "(void) { }" & CR
                else
                    if USE_DLLTOOL
                        DefFileContents += [" " & FunctionName & "@" & Signature & CR]
                    else
                        DefFileContents += [" " & FunctionName & CR]
                    end
                    local ArgsIn = ""
                    foreach i in UpTo{Divide4{Signature}}
                        if not equal(i, "0")
                            ArgsIn = ArgsIn & ","
                        end
                        ArgsIn = ArgsIn & "u a" & i
                    end
                    CFileContents += (
                        "void __stdcall " & FunctionName & "(" & ArgsIn & ") { }" & CR
                        )
                end
            end
        end

        > DefFilePath in
            write(DefFileContents)
        end

        %
        % .m3x files needed but not otherwise produced.
        %
        > File & ".m3x" in 
          write("")
        end

        Stale{File} = Extension
    end
end

if AnyStale

    CFileContents += ["#if defined(__cplusplus)" & CR]
    CFileContents += ["} /* extern \"C\" */" & CR]
    CFileContents += ["#endif" & CR]

    local readonly CFilePath = "a.c"

    > CFilePath in
        write(CFileContents)
    end

    exec(SYSTEM_CC, "-c", CFilePath)

    foreach File in Stale

        local readonly QuakeFileName = File & ".quake"
        local readonly LibFilePath = File & ".lib"

        local readonly ObjFilePath = ObjFile("a")
        local readonly DefFilePath = File & ".def"
        local readonly Extension = Stale{File}

        if USE_LINK
            exec(
                "link",
                "-nologo",
                ObjFilePath,
                "-dll",
                "-nodefaultlib",
                "-noentry",
                "-def:" & DefFilePath,
                "-out:" & File & "." & Extension,
                )
        end
        if USE_DLLTOOL
            exec(
                "dlltool",
                "--output-lib", LibFilePath,
                "--dllname", File & "." & Extension,
                "--input-def", DefFilePath,
                "--kill-at",
                ObjFilePath,
                )
        end
        if USE_LD
            exec(
                "ld",
                ObjFilePath,
                "-nostdlib",
                "--out-implib", LibFilePath,
                "-o", File & "." & Extension,
                DefFilePath,
                "--enable-stdcall-fixup",
                "--add-stdcall-alias",
                "--kill-at",
                )
        end

        LibdExport(File & ".lib")
    end
end

if not equal(M3_MODE, "clean")
    %
    % .M3WEB needed but not otherwise produced.
    %
    > ".M3WEB" in 
      write("")
    end
end
