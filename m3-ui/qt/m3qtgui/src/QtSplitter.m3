(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE QtSplitter;


FROM QtSize IMPORT QSize;
FROM QtByteArray IMPORT QByteArray;
FROM QtWidget IMPORT QWidget;
IMPORT QtSplitterRaw;
FROM QtNamespace IMPORT Orientation;


IMPORT WeakRef;
IMPORT Ctypes AS C;

PROCEDURE New_QSplitter0 (self: QSplitter; parent: QWidget; ): QSplitter =
  VAR
    result : ADDRESS;
    arg1tmp          := LOOPHOLE(parent.cxxObj, ADDRESS);
  BEGIN
    result := QtSplitterRaw.New_QSplitter0(arg1tmp);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QSplitter);

    RETURN self;
  END New_QSplitter0;

PROCEDURE New_QSplitter1 (self: QSplitter; ): QSplitter =
  VAR result: ADDRESS;
  BEGIN
    result := QtSplitterRaw.New_QSplitter1();

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QSplitter);

    RETURN self;
  END New_QSplitter1;

PROCEDURE New_QSplitter2
  (self: QSplitter; arg1: Orientation; parent: QWidget; ): QSplitter =
  VAR
    result : ADDRESS;
    arg2tmp          := LOOPHOLE(parent.cxxObj, ADDRESS);
  BEGIN
    result := QtSplitterRaw.New_QSplitter2(ORD(arg1), arg2tmp);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QSplitter);

    RETURN self;
  END New_QSplitter2;

PROCEDURE New_QSplitter3 (self: QSplitter; arg1: Orientation; ):
  QSplitter =
  VAR result: ADDRESS;
  BEGIN
    result := QtSplitterRaw.New_QSplitter3(ORD(arg1));

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QSplitter);

    RETURN self;
  END New_QSplitter3;

PROCEDURE Delete_QSplitter (self: QSplitter; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.Delete_QSplitter(selfAdr);
  END Delete_QSplitter;

PROCEDURE QSplitter_addWidget (self: QSplitter; widget: QWidget; ) =
  VAR
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(widget.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_addWidget(selfAdr, arg2tmp);
  END QSplitter_addWidget;

PROCEDURE QSplitter_insertWidget
  (self: QSplitter; index: INTEGER; widget: QWidget; ) =
  VAR
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg3tmp          := LOOPHOLE(widget.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_insertWidget(selfAdr, index, arg3tmp);
  END QSplitter_insertWidget;

PROCEDURE QSplitter_setOrientation (self: QSplitter; arg2: Orientation; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_setOrientation(selfAdr, ORD(arg2));
  END QSplitter_setOrientation;

PROCEDURE QSplitter_orientation (self: QSplitter; ): Orientation =
  VAR
    ret    : INTEGER;
    result : Orientation;
    selfAdr: ADDRESS     := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitter_orientation(selfAdr);
    result := VAL(ret, Orientation);
    RETURN result;
  END QSplitter_orientation;

PROCEDURE QSplitter_setChildrenCollapsible
  (self: QSplitter; arg2: BOOLEAN; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_setChildrenCollapsible(selfAdr, arg2);
  END QSplitter_setChildrenCollapsible;

PROCEDURE QSplitter_childrenCollapsible (self: QSplitter; ): BOOLEAN =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitter_childrenCollapsible(selfAdr);
  END QSplitter_childrenCollapsible;

PROCEDURE QSplitter_setCollapsible
  (self: QSplitter; index: INTEGER; arg3: BOOLEAN; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_setCollapsible(selfAdr, index, arg3);
  END QSplitter_setCollapsible;

PROCEDURE QSplitter_isCollapsible (self: QSplitter; index: INTEGER; ):
  BOOLEAN =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitter_isCollapsible(selfAdr, index);
  END QSplitter_isCollapsible;

PROCEDURE QSplitter_setOpaqueResize (self: QSplitter; opaque: BOOLEAN; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_setOpaqueResize(selfAdr, opaque);
  END QSplitter_setOpaqueResize;

PROCEDURE QSplitter_setOpaqueResize1 (self: QSplitter; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_setOpaqueResize1(selfAdr);
  END QSplitter_setOpaqueResize1;

PROCEDURE QSplitter_opaqueResize (self: QSplitter; ): BOOLEAN =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitter_opaqueResize(selfAdr);
  END QSplitter_opaqueResize;

PROCEDURE QSplitter_refresh (self: QSplitter; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_refresh(selfAdr);
  END QSplitter_refresh;

PROCEDURE QSplitter_sizeHint (self: QSplitter; ): QSize =
  VAR
    ret    : ADDRESS;
    result : QSize;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitter_sizeHint(selfAdr);

    result := NEW(QSize);
    result.cxxObj := ret;
    result.destroyCxx();

    RETURN result;
  END QSplitter_sizeHint;

PROCEDURE QSplitter_minimumSizeHint (self: QSplitter; ): QSize =
  VAR
    ret    : ADDRESS;
    result : QSize;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitter_minimumSizeHint(selfAdr);

    result := NEW(QSize);
    result.cxxObj := ret;
    result.destroyCxx();

    RETURN result;
  END QSplitter_minimumSizeHint;

PROCEDURE QSplitter_saveState (self: QSplitter; ): QByteArray =
  VAR
    ret    : ADDRESS;
    result : QByteArray;
    selfAdr: ADDRESS    := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitter_saveState(selfAdr);

    result := NEW(QByteArray);
    result.cxxObj := ret;
    result.destroyCxx();

    RETURN result;
  END QSplitter_saveState;

PROCEDURE QSplitter_restoreState (self: QSplitter; state: QByteArray; ):
  BOOLEAN =
  VAR
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(state.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitter_restoreState(selfAdr, arg2tmp);
  END QSplitter_restoreState;

PROCEDURE QSplitter_handleWidth (self: QSplitter; ): INTEGER =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitter_handleWidth(selfAdr);
  END QSplitter_handleWidth;

PROCEDURE QSplitter_setHandleWidth (self: QSplitter; arg2: INTEGER; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_setHandleWidth(selfAdr, arg2);
  END QSplitter_setHandleWidth;

PROCEDURE QSplitter_indexOf (self: QSplitter; w: QWidget; ): INTEGER =
  VAR
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(w.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitter_indexOf(selfAdr, arg2tmp);
  END QSplitter_indexOf;

PROCEDURE QSplitter_widget (self: QSplitter; index: INTEGER; ): QWidget =
  VAR
    ret    : ADDRESS;
    result : QWidget;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitter_widget(selfAdr, index);

    result := NEW(QWidget);
    result.cxxObj := ret;
    result.destroyCxx();

    RETURN result;
  END QSplitter_widget;

PROCEDURE QSplitter_count (self: QSplitter; ): INTEGER =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitter_count(selfAdr);
  END QSplitter_count;

PROCEDURE QSplitter_getRange
  (self: QSplitter; index: INTEGER; VAR arg3, arg4: INTEGER; ) =
  VAR
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg3tmp: C.int;
    arg4tmp: C.int;
  BEGIN
    arg3tmp := arg3;
    arg4tmp := arg4;
    QtSplitterRaw.QSplitter_getRange(selfAdr, index, arg3tmp, arg4tmp);
    arg3 := arg3tmp;
    arg4 := arg4tmp;
  END QSplitter_getRange;

PROCEDURE QSplitter_setStretchFactor
  (self: QSplitter; index, stretch: INTEGER; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitter_setStretchFactor(selfAdr, index, stretch);
  END QSplitter_setStretchFactor;

PROCEDURE Cleanup_QSplitter
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: QSplitter := ref;
  BEGIN
    Delete_QSplitter(obj);
  END Cleanup_QSplitter;

PROCEDURE Destroy_QSplitter (self: QSplitter) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_QSplitter);
  END Destroy_QSplitter;

REVEAL
  QSplitter = QSplitterPublic BRANDED OBJECT
              OVERRIDES
                init_0                 := New_QSplitter0;
                init_1                 := New_QSplitter1;
                init_2                 := New_QSplitter2;
                init_3                 := New_QSplitter3;
                addWidget              := QSplitter_addWidget;
                insertWidget           := QSplitter_insertWidget;
                setOrientation         := QSplitter_setOrientation;
                orientation            := QSplitter_orientation;
                setChildrenCollapsible := QSplitter_setChildrenCollapsible;
                childrenCollapsible    := QSplitter_childrenCollapsible;
                setCollapsible         := QSplitter_setCollapsible;
                isCollapsible          := QSplitter_isCollapsible;
                setOpaqueResize        := QSplitter_setOpaqueResize;
                setOpaqueResize1       := QSplitter_setOpaqueResize1;
                opaqueResize           := QSplitter_opaqueResize;
                refresh                := QSplitter_refresh;
                sizeHint               := QSplitter_sizeHint;
                minimumSizeHint        := QSplitter_minimumSizeHint;
                saveState              := QSplitter_saveState;
                restoreState           := QSplitter_restoreState;
                handleWidth            := QSplitter_handleWidth;
                setHandleWidth         := QSplitter_setHandleWidth;
                indexOf                := QSplitter_indexOf;
                widget                 := QSplitter_widget;
                count                  := QSplitter_count;
                getRange               := QSplitter_getRange;
                setStretchFactor       := QSplitter_setStretchFactor;
                destroyCxx             := Destroy_QSplitter;
              END;

PROCEDURE New_QSplitterHandle0
  (self: QSplitterHandle; o: Orientation; parent: QSplitter; ):
  QSplitterHandle =
  VAR
    result : ADDRESS;
    arg2tmp          := LOOPHOLE(parent.cxxObj, ADDRESS);
  BEGIN
    result := QtSplitterRaw.New_QSplitterHandle0(ORD(o), arg2tmp);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QSplitterHandle);

    RETURN self;
  END New_QSplitterHandle0;

PROCEDURE QSplitterHandle_setOrientation
  (self: QSplitterHandle; o: Orientation; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.QSplitterHandle_setOrientation(selfAdr, ORD(o));
  END QSplitterHandle_setOrientation;

PROCEDURE QSplitterHandle_orientation (self: QSplitterHandle; ):
  Orientation =
  VAR
    ret    : INTEGER;
    result : Orientation;
    selfAdr: ADDRESS     := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitterHandle_orientation(selfAdr);
    result := VAL(ret, Orientation);
    RETURN result;
  END QSplitterHandle_orientation;

PROCEDURE QSplitterHandle_opaqueResize (self: QSplitterHandle; ): BOOLEAN =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtSplitterRaw.QSplitterHandle_opaqueResize(selfAdr);
  END QSplitterHandle_opaqueResize;

PROCEDURE QSplitterHandle_splitter (self: QSplitterHandle; ): QSplitter =
  VAR
    ret    : ADDRESS;
    result : QSplitter;
    selfAdr: ADDRESS   := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitterHandle_splitter(selfAdr);

    result := NEW(QSplitter);
    result.cxxObj := ret;
    result.destroyCxx();

    RETURN result;
  END QSplitterHandle_splitter;

PROCEDURE QSplitterHandle_sizeHint (self: QSplitterHandle; ): QSize =
  VAR
    ret    : ADDRESS;
    result : QSize;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtSplitterRaw.QSplitterHandle_sizeHint(selfAdr);

    result := NEW(QSize);
    result.cxxObj := ret;
    result.destroyCxx();

    RETURN result;
  END QSplitterHandle_sizeHint;

PROCEDURE Delete_QSplitterHandle (self: QSplitterHandle; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtSplitterRaw.Delete_QSplitterHandle(selfAdr);
  END Delete_QSplitterHandle;

PROCEDURE Cleanup_QSplitterHandle
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: QSplitterHandle := ref;
  BEGIN
    Delete_QSplitterHandle(obj);
  END Cleanup_QSplitterHandle;

PROCEDURE Destroy_QSplitterHandle (self: QSplitterHandle) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_QSplitterHandle);
  END Destroy_QSplitterHandle;

REVEAL
  QSplitterHandle = QSplitterHandlePublic BRANDED OBJECT
                    OVERRIDES
                      init_0         := New_QSplitterHandle0;
                      setOrientation := QSplitterHandle_setOrientation;
                      orientation    := QSplitterHandle_orientation;
                      opaqueResize   := QSplitterHandle_opaqueResize;
                      splitter       := QSplitterHandle_splitter;
                      sizeHint       := QSplitterHandle_sizeHint;
                      destroyCxx     := Destroy_QSplitterHandle;
                    END;


BEGIN
END QtSplitter.
