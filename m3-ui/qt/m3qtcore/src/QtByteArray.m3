(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE QtByteArray;


IMPORT M3toC;
IMPORT Ctypes AS C;
IMPORT QtByteArrayRaw;
FROM QtNamespace IMPORT Initialization;


IMPORT WeakRef;

PROCEDURE New_QByteArray0 (self:QByteArray;): QByteArray =
VAR
result : ADDRESS;
BEGIN
result := QtByteArrayRaw.New_QByteArray0();

  self.cxxObj := result;
  EVAL WeakRef.FromRef(self,Cleanup_QByteArray);

RETURN self;
END New_QByteArray0;

PROCEDURE New_QByteArray1 (self:QByteArray; arg1: TEXT;
): QByteArray =
VAR
result : ADDRESS;
arg1tmp: C.char_star;
BEGIN
arg1tmp := M3toC.CopyTtoS(arg1);
result := QtByteArrayRaw.New_QByteArray1(arg1tmp);

  self.cxxObj := result;
  EVAL WeakRef.FromRef(self,Cleanup_QByteArray);



RETURN self;
END New_QByteArray1;

PROCEDURE New_QByteArray2 (self:QByteArray; arg1: TEXT;
size: INTEGER;
): QByteArray =
VAR
result : ADDRESS;
arg1tmp: C.char_star;
BEGIN
arg1tmp := M3toC.CopyTtoS(arg1);
result := QtByteArrayRaw.New_QByteArray2(arg1tmp, size);

  self.cxxObj := result;
  EVAL WeakRef.FromRef(self,Cleanup_QByteArray);



RETURN self;
END New_QByteArray2;

PROCEDURE New_QByteArray3 (self:QByteArray;size: INTEGER;
c: CHAR;
): QByteArray =
VAR
result : ADDRESS;
BEGIN
result := QtByteArrayRaw.New_QByteArray3(size, ORD(c));

  self.cxxObj := result;
  EVAL WeakRef.FromRef(self,Cleanup_QByteArray);

RETURN self;
END New_QByteArray3;

PROCEDURE New_QByteArray4 (self:QByteArray;size: INTEGER;
arg2: Initialization;
): QByteArray =
VAR
result : ADDRESS;
BEGIN
result := QtByteArrayRaw.New_QByteArray4(size, ORD(arg2));

  self.cxxObj := result;
  EVAL WeakRef.FromRef(self,Cleanup_QByteArray);

RETURN self;
END New_QByteArray4;

PROCEDURE New_QByteArray5 (self:QByteArray; arg1: QByteArray;
): QByteArray =
VAR
result : ADDRESS;
arg1tmp :=  LOOPHOLE(arg1.cxxObj,ADDRESS);
BEGIN
result := QtByteArrayRaw.New_QByteArray5(arg1tmp);

  self.cxxObj := result;
  EVAL WeakRef.FromRef(self,Cleanup_QByteArray);

RETURN self;
END New_QByteArray5;

PROCEDURE Delete_QByteArray ( self: QByteArray;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.Delete_QByteArray(selfAdr);
END Delete_QByteArray;

PROCEDURE QByteArray_size ( self: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_size(selfAdr);
END QByteArray_size;

PROCEDURE QByteArray_isEmpty ( self: QByteArray;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_isEmpty(selfAdr);
END QByteArray_isEmpty;

PROCEDURE QByteArray_resize ( self: QByteArray;
size: INTEGER;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_resize(selfAdr, size);
END QByteArray_resize;

PROCEDURE QByteArray_fill ( self: QByteArray;
c: CHAR;
size: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_fill(selfAdr, ORD(c), size);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_fill;

PROCEDURE QByteArray_fill1 ( self: QByteArray;
c: CHAR;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_fill1(selfAdr, ORD(c));

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_fill1;

PROCEDURE QByteArray_capacity ( self: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_capacity(selfAdr);
END QByteArray_capacity;

PROCEDURE QByteArray_reserve ( self: QByteArray;
size: INTEGER;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_reserve(selfAdr, size);
END QByteArray_reserve;

PROCEDURE QByteArray_squeeze ( self: QByteArray;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_squeeze(selfAdr);
END QByteArray_squeeze;

PROCEDURE QByteArray_data ( self: QByteArray;
): TEXT =
VAR
result : C.char_star;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
result := QtByteArrayRaw.QByteArray_data(selfAdr);

RETURN M3toC.CopyStoT(result);
END QByteArray_data;

PROCEDURE QByteArray_data1 ( self: QByteArray;
): TEXT =
VAR
result : C.char_star;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
result := QtByteArrayRaw.QByteArray_data1(selfAdr);

RETURN M3toC.CopyStoT(result);
END QByteArray_data1;

PROCEDURE QByteArray_constData ( self: QByteArray;
): TEXT =
VAR
result : C.char_star;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
result := QtByteArrayRaw.QByteArray_constData(selfAdr);

RETURN M3toC.CopyStoT(result);
END QByteArray_constData;

PROCEDURE QByteArray_detach ( self: QByteArray;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_detach(selfAdr);
END QByteArray_detach;

PROCEDURE QByteArray_isDetached ( self: QByteArray;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_isDetached(selfAdr);
END QByteArray_isDetached;

PROCEDURE QByteArray_clear ( self: QByteArray;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_clear(selfAdr);
END QByteArray_clear;

PROCEDURE QByteArray_count ( self: QByteArray;
c: CHAR;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_count(selfAdr, ORD(c));
END QByteArray_count;

PROCEDURE QByteArray_count1 ( self: QByteArray;
 a: TEXT;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp: C.char_star;
result: INTEGER;
BEGIN
arg2tmp := M3toC.CopyTtoS(a);
result := QtByteArrayRaw.QByteArray_count1(selfAdr, arg2tmp);


RETURN result;
END QByteArray_count1;

PROCEDURE QByteArray_count2 ( self, a: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(a.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_count2(selfAdr, arg2tmp);
END QByteArray_count2;

PROCEDURE QByteArray_left ( self: QByteArray;
len: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_left(selfAdr, len);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_left;

PROCEDURE QByteArray_right ( self: QByteArray;
len: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_right(selfAdr, len);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_right;

PROCEDURE QByteArray_mid ( self: QByteArray;
index, len: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_mid(selfAdr, index, len);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_mid;

PROCEDURE QByteArray_mid1 ( self: QByteArray;
index: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_mid1(selfAdr, index);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_mid1;

PROCEDURE QByteArray_startsWith ( self, a: QByteArray;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(a.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_startsWith(selfAdr, arg2tmp);
END QByteArray_startsWith;

PROCEDURE QByteArray_startsWith1 ( self: QByteArray;
c: CHAR;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_startsWith1(selfAdr, ORD(c));
END QByteArray_startsWith1;

PROCEDURE QByteArray_startsWith2 ( self: QByteArray;
 c: TEXT;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp: C.char_star;
result: BOOLEAN;
BEGIN
arg2tmp := M3toC.CopyTtoS(c);
result := QtByteArrayRaw.QByteArray_startsWith2(selfAdr, arg2tmp);


RETURN result;
END QByteArray_startsWith2;

PROCEDURE QByteArray_endsWith ( self, a: QByteArray;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(a.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_endsWith(selfAdr, arg2tmp);
END QByteArray_endsWith;

PROCEDURE QByteArray_endsWith1 ( self: QByteArray;
c: CHAR;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_endsWith1(selfAdr, ORD(c));
END QByteArray_endsWith1;

PROCEDURE QByteArray_endsWith2 ( self: QByteArray;
 c: TEXT;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp: C.char_star;
result: BOOLEAN;
BEGIN
arg2tmp := M3toC.CopyTtoS(c);
result := QtByteArrayRaw.QByteArray_endsWith2(selfAdr, arg2tmp);


RETURN result;
END QByteArray_endsWith2;

PROCEDURE QByteArray_truncate ( self: QByteArray;
pos: INTEGER;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_truncate(selfAdr, pos);
END QByteArray_truncate;

PROCEDURE QByteArray_chop ( self: QByteArray;
n: INTEGER;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_chop(selfAdr, n);
END QByteArray_chop;

PROCEDURE QByteArray_toLower ( self: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toLower(selfAdr);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toLower;

PROCEDURE QByteArray_toUpper ( self: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toUpper(selfAdr);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toUpper;

PROCEDURE QByteArray_trimmed ( self: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_trimmed(selfAdr);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_trimmed;

PROCEDURE QByteArray_simplified ( self: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_simplified(selfAdr);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_simplified;

PROCEDURE QByteArray_prepend ( self: QByteArray;
c: CHAR;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_prepend(selfAdr, ORD(c));

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_prepend;

PROCEDURE QByteArray_prepend1 ( self: QByteArray;
 s: TEXT;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp: C.char_star;
BEGIN
arg2tmp := M3toC.CopyTtoS(s);
ret := QtByteArrayRaw.QByteArray_prepend1(selfAdr, arg2tmp);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;



RETURN result;
END QByteArray_prepend1;

PROCEDURE QByteArray_prepend2 ( self: QByteArray;
 s: TEXT;
len: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp: C.char_star;
BEGIN
arg2tmp := M3toC.CopyTtoS(s);
ret := QtByteArrayRaw.QByteArray_prepend2(selfAdr, arg2tmp, len);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;



RETURN result;
END QByteArray_prepend2;

PROCEDURE QByteArray_prepend3 ( self, a: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(a.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_prepend3(selfAdr, arg2tmp);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_prepend3;

PROCEDURE QByteArray_remove ( self: QByteArray;
index, len: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_remove(selfAdr, index, len);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_remove;

PROCEDURE QByteArray_repeated ( self: QByteArray;
times: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_repeated(selfAdr, times);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_repeated;

PROCEDURE QByteArray_toShort ( self: QByteArray;
VAR ok: BOOLEAN;
base: INTEGER;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toShort(selfAdr, ok, base);
END QByteArray_toShort;

PROCEDURE QByteArray_toShort1 ( self: QByteArray;
VAR ok: BOOLEAN;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toShort1(selfAdr, ok);
END QByteArray_toShort1;

PROCEDURE QByteArray_toShort2 ( self: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toShort2(selfAdr);
END QByteArray_toShort2;

PROCEDURE QByteArray_toUShort ( self: QByteArray;
VAR ok: BOOLEAN;
base: INTEGER;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toUShort(selfAdr, ok, base);
END QByteArray_toUShort;

PROCEDURE QByteArray_toUShort1 ( self: QByteArray;
VAR ok: BOOLEAN;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toUShort1(selfAdr, ok);
END QByteArray_toUShort1;

PROCEDURE QByteArray_toUShort2 ( self: QByteArray;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toUShort2(selfAdr);
END QByteArray_toUShort2;

PROCEDURE QByteArray_toInt ( self: QByteArray;
VAR ok: BOOLEAN;
base: INTEGER;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toInt(selfAdr, ok, base);
END QByteArray_toInt;

PROCEDURE QByteArray_toInt1 ( self: QByteArray;
VAR ok: BOOLEAN;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toInt1(selfAdr, ok);
END QByteArray_toInt1;

PROCEDURE QByteArray_toInt2 ( self: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toInt2(selfAdr);
END QByteArray_toInt2;

PROCEDURE QByteArray_toUInt ( self: QByteArray;
VAR ok: BOOLEAN;
base: INTEGER;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toUInt(selfAdr, ok, base);
END QByteArray_toUInt;

PROCEDURE QByteArray_toUInt1 ( self: QByteArray;
VAR ok: BOOLEAN;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toUInt1(selfAdr, ok);
END QByteArray_toUInt1;

PROCEDURE QByteArray_toUInt2 ( self: QByteArray;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toUInt2(selfAdr);
END QByteArray_toUInt2;

PROCEDURE QByteArray_toLong ( self: QByteArray;
VAR ok: BOOLEAN;
base: INTEGER;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toLong(selfAdr, ok, base);
END QByteArray_toLong;

PROCEDURE QByteArray_toLong1 ( self: QByteArray;
VAR ok: BOOLEAN;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toLong1(selfAdr, ok);
END QByteArray_toLong1;

PROCEDURE QByteArray_toLong2 ( self: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toLong2(selfAdr);
END QByteArray_toLong2;

PROCEDURE QByteArray_toULong ( self: QByteArray;
VAR ok: BOOLEAN;
base: INTEGER;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toULong(selfAdr, ok, base);
END QByteArray_toULong;

PROCEDURE QByteArray_toULong1 ( self: QByteArray;
VAR ok: BOOLEAN;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toULong1(selfAdr, ok);
END QByteArray_toULong1;

PROCEDURE QByteArray_toULong2 ( self: QByteArray;
): CARDINAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toULong2(selfAdr);
END QByteArray_toULong2;

PROCEDURE QByteArray_toFloat ( self: QByteArray;
VAR ok: BOOLEAN;
): REAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toFloat(selfAdr, ok);
END QByteArray_toFloat;

PROCEDURE QByteArray_toFloat1 ( self: QByteArray;
): REAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toFloat1(selfAdr);
END QByteArray_toFloat1;

PROCEDURE QByteArray_toDouble ( self: QByteArray;
VAR ok: BOOLEAN;
): LONGREAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toDouble(selfAdr, ok);
END QByteArray_toDouble;

PROCEDURE QByteArray_toDouble1 ( self: QByteArray;
): LONGREAL =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_toDouble1(selfAdr);
END QByteArray_toDouble1;

PROCEDURE QByteArray_toBase64 ( self: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toBase64(selfAdr);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toBase64;

PROCEDURE QByteArray_toHex ( self: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toHex(selfAdr);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toHex;

PROCEDURE QByteArray_toPercentEncoding ( self, exclude, include: QByteArray;
percent: CHAR;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(exclude.cxxObj,ADDRESS);
arg3tmp :=  LOOPHOLE(include.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toPercentEncoding(selfAdr, arg2tmp, arg3tmp, ORD(percent));

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toPercentEncoding;

PROCEDURE QByteArray_toPercentEncoding1 ( self, exclude, include: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(exclude.cxxObj,ADDRESS);
arg3tmp :=  LOOPHOLE(include.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toPercentEncoding1(selfAdr, arg2tmp, arg3tmp);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toPercentEncoding1;

PROCEDURE QByteArray_toPercentEncoding2 ( self, exclude: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(exclude.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toPercentEncoding2(selfAdr, arg2tmp);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toPercentEncoding2;

PROCEDURE QByteArray_toPercentEncoding3 ( self: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.QByteArray_toPercentEncoding3(selfAdr);

IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
END;

RETURN result;
END QByteArray_toPercentEncoding3;

PROCEDURE FromRawData ( arg1: TEXT;
size: INTEGER;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
arg1tmp: C.char_star;
BEGIN
arg1tmp := M3toC.CopyTtoS(arg1);
ret := QtByteArrayRaw.FromRawData(arg1tmp, size);

(*IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE*)
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
(*END;*)



RETURN result;
END FromRawData;

PROCEDURE FromBase64 ( base64: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
arg1tmp :=  LOOPHOLE(base64.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.FromBase64(arg1tmp);

(*IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE*)
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
(*END;*)

RETURN result;
END FromBase64;

PROCEDURE FromHex ( hexEncoded: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
arg1tmp :=  LOOPHOLE(hexEncoded.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.FromHex(arg1tmp);

(*IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE*)
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
(*END;*)

RETURN result;
END FromHex;

PROCEDURE FromPercentEncoding ( pctEncoded: QByteArray;
percent: CHAR;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
arg1tmp :=  LOOPHOLE(pctEncoded.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.FromPercentEncoding(arg1tmp, ORD(percent));

(*IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE*)
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
(*END;*)

RETURN result;
END FromPercentEncoding;

PROCEDURE FromPercentEncoding1 ( pctEncoded: QByteArray;
): QByteArray =
VAR
ret:ADDRESS; result : QByteArray;
arg1tmp :=  LOOPHOLE(pctEncoded.cxxObj,ADDRESS);
BEGIN
ret := QtByteArrayRaw.FromPercentEncoding1(arg1tmp);

(*IF ISTYPE(result,QByteArray) AND ret = selfAdr THEN
  result := LOOPHOLE(self,QByteArray);
ELSE*)
  result := NEW(QByteArray);
  result.cxxObj := ret;
  result.destroyCxx();
(*END;*)

RETURN result;
END FromPercentEncoding1;

PROCEDURE QByteArray_push_back ( self: QByteArray;
c: CHAR;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_push_back(selfAdr, ORD(c));
END QByteArray_push_back;

PROCEDURE QByteArray_push_back1 ( self: QByteArray;
 c: TEXT;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp: C.char_star;
BEGIN
arg2tmp := M3toC.CopyTtoS(c);
QtByteArrayRaw.QByteArray_push_back1(selfAdr, arg2tmp);


END QByteArray_push_back1;

PROCEDURE QByteArray_push_back2 ( self, a: QByteArray;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(a.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_push_back2(selfAdr, arg2tmp);
END QByteArray_push_back2;

PROCEDURE QByteArray_push_front ( self: QByteArray;
c: CHAR;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_push_front(selfAdr, ORD(c));
END QByteArray_push_front;

PROCEDURE QByteArray_push_front1 ( self: QByteArray;
 c: TEXT;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp: C.char_star;
BEGIN
arg2tmp := M3toC.CopyTtoS(c);
QtByteArrayRaw.QByteArray_push_front1(selfAdr, arg2tmp);


END QByteArray_push_front1;

PROCEDURE QByteArray_push_front2 ( self, a: QByteArray;
) =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
arg2tmp :=  LOOPHOLE(a.cxxObj,ADDRESS);
BEGIN
QtByteArrayRaw.QByteArray_push_front2(selfAdr, arg2tmp);
END QByteArray_push_front2;

PROCEDURE QByteArray_count3 ( self: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_count3(selfAdr);
END QByteArray_count3;

PROCEDURE QByteArray_length ( self: QByteArray;
): INTEGER =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_length(selfAdr);
END QByteArray_length;

PROCEDURE QByteArray_isNull ( self: QByteArray;
): BOOLEAN =
VAR
selfAdr: ADDRESS := LOOPHOLE(self.cxxObj,ADDRESS);
BEGIN
RETURN QtByteArrayRaw.QByteArray_isNull(selfAdr);
END QByteArray_isNull;

PROCEDURE Cleanup_QByteArray(<*UNUSED*>READONLY self: WeakRef.T; ref: REFANY) =
VAR obj : QByteArray := ref;
BEGIN
  Delete_QByteArray(obj);
 END Cleanup_QByteArray;

PROCEDURE Destroy_QByteArray(self : QByteArray) =
BEGIN
  EVAL WeakRef.FromRef(self,Cleanup_QByteArray);
END Destroy_QByteArray;

REVEAL
QByteArray =
QByteArrayPublic BRANDED OBJECT
OVERRIDES
init_0 := New_QByteArray0;
init_1 := New_QByteArray1;
init_2 := New_QByteArray2;
init_3 := New_QByteArray3;
init_4 := New_QByteArray4;
init_5 := New_QByteArray5;
size := QByteArray_size;
isEmpty := QByteArray_isEmpty;
resize := QByteArray_resize;
fill := QByteArray_fill;
fill1 := QByteArray_fill1;
capacity := QByteArray_capacity;
reserve := QByteArray_reserve;
squeeze := QByteArray_squeeze;
data := QByteArray_data;
data1 := QByteArray_data1;
constData := QByteArray_constData;
detach := QByteArray_detach;
isDetached := QByteArray_isDetached;
clear := QByteArray_clear;
count := QByteArray_count;
count1 := QByteArray_count1;
count2 := QByteArray_count2;
left := QByteArray_left;
right := QByteArray_right;
mid := QByteArray_mid;
mid1 := QByteArray_mid1;
startsWith := QByteArray_startsWith;
startsWith1 := QByteArray_startsWith1;
startsWith2 := QByteArray_startsWith2;
endsWith := QByteArray_endsWith;
endsWith1 := QByteArray_endsWith1;
endsWith2 := QByteArray_endsWith2;
truncate := QByteArray_truncate;
chop := QByteArray_chop;
toLower := QByteArray_toLower;
toUpper := QByteArray_toUpper;
trimmed := QByteArray_trimmed;
simplified := QByteArray_simplified;
prepend := QByteArray_prepend;
prepend1 := QByteArray_prepend1;
prepend2 := QByteArray_prepend2;
prepend3 := QByteArray_prepend3;
remove := QByteArray_remove;
repeated := QByteArray_repeated;
toShort := QByteArray_toShort;
toShort1 := QByteArray_toShort1;
toShort2 := QByteArray_toShort2;
toUShort := QByteArray_toUShort;
toUShort1 := QByteArray_toUShort1;
toUShort2 := QByteArray_toUShort2;
toInt := QByteArray_toInt;
toInt1 := QByteArray_toInt1;
toInt2 := QByteArray_toInt2;
toUInt := QByteArray_toUInt;
toUInt1 := QByteArray_toUInt1;
toUInt2 := QByteArray_toUInt2;
toLong := QByteArray_toLong;
toLong1 := QByteArray_toLong1;
toLong2 := QByteArray_toLong2;
toULong := QByteArray_toULong;
toULong1 := QByteArray_toULong1;
toULong2 := QByteArray_toULong2;
toFloat := QByteArray_toFloat;
toFloat1 := QByteArray_toFloat1;
toDouble := QByteArray_toDouble;
toDouble1 := QByteArray_toDouble1;
toBase64 := QByteArray_toBase64;
toHex := QByteArray_toHex;
toPercentEncoding := QByteArray_toPercentEncoding;
toPercentEncoding1 := QByteArray_toPercentEncoding1;
toPercentEncoding2 := QByteArray_toPercentEncoding2;
toPercentEncoding3 := QByteArray_toPercentEncoding3;
push_back := QByteArray_push_back;
push_back1 := QByteArray_push_back1;
push_back2 := QByteArray_push_back2;
push_front := QByteArray_push_front;
push_front1 := QByteArray_push_front1;
push_front2 := QByteArray_push_front2;
count3 := QByteArray_count3;
length := QByteArray_length;
isNull := QByteArray_isNull;
destroyCxx := Destroy_QByteArray;
END;


BEGIN
END QtByteArray.
