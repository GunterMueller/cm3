(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE QtDynamic;


FROM QtObject IMPORT QObject;
IMPORT QtDynamicRaw;


IMPORT WeakRef;
IMPORT Ctypes AS C;
IMPORT M3toC;

PROCEDURE ConvertInt (args: ADDRESS; parmNo: INTEGER): INTEGER =
  TYPE
    arrT = UNTRACED REF ARRAY [0 .. 10] OF ADDRESS;
    refCInt = REF C.int;
  VAR ci: C.int;
  BEGIN
    (* the conversion to c int *)
    ci := LOOPHOLE(LOOPHOLE(args, arrT)[parmNo], refCInt)^;
    RETURN ci;
  END ConvertInt;

PROCEDURE ConvertObj (args: ADDRESS; parmNo: INTEGER): ADDRESS =
  TYPE arrT = UNTRACED REF ARRAY [0 .. 10] OF ADDRESS;
  BEGIN
    RETURN LOOPHOLE(args, arrT)[parmNo];
  END ConvertObj;


PROCEDURE Delete_AbstractDynamicSlot (self: AbstractDynamicSlot; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtDynamicRaw.Delete_AbstractDynamicSlot(selfAdr);
  END Delete_AbstractDynamicSlot;

PROCEDURE Cleanup_AbstractDynamicSlot
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: AbstractDynamicSlot := ref;
  BEGIN
    Delete_AbstractDynamicSlot(obj);
  END Cleanup_AbstractDynamicSlot;

PROCEDURE Destroy_AbstractDynamicSlot (self: AbstractDynamicSlot) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_AbstractDynamicSlot);
  END Destroy_AbstractDynamicSlot;

REVEAL
  AbstractDynamicSlot = AbstractDynamicSlotPublic BRANDED OBJECT
                        OVERRIDES
                          destroyCxx := Destroy_AbstractDynamicSlot;
                        END;

PROCEDURE AbstractDynamicQObject_qt_metacall
  (self: AbstractDynamicQObject; c, id: INTEGER; arguments: REF ADDRESS; ):
  INTEGER =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtDynamicRaw.AbstractDynamicQObject_qt_metacall(
             selfAdr, c, id, arguments);
  END AbstractDynamicQObject_qt_metacall;

PROCEDURE AbstractDynamicQObject_emitDynamicSignal
  (self: AbstractDynamicQObject; signal: TEXT; arguments: REF ADDRESS; ):
  BOOLEAN =
  VAR
    selfAdr: ADDRESS     := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp: C.char_star;
    result : BOOLEAN;
  BEGIN
    arg2tmp := M3toC.CopyTtoS(signal);
    result := QtDynamicRaw.AbstractDynamicQObject_emitDynamicSignal(
                selfAdr, arg2tmp, arguments);


    RETURN result;
  END AbstractDynamicQObject_emitDynamicSignal;

PROCEDURE AbstractDynamicQObject_connectDynamicSlot
  (self: AbstractDynamicQObject; obj: QObject; signal, slot: TEXT; ):
  BOOLEAN =
  VAR
    selfAdr: ADDRESS     := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp              := LOOPHOLE(obj.cxxObj, ADDRESS);
    arg3tmp: C.char_star;
    arg4tmp: C.char_star;
    result : BOOLEAN;
  BEGIN
    arg3tmp := M3toC.CopyTtoS(signal);
    arg4tmp := M3toC.CopyTtoS(slot);
    result := QtDynamicRaw.AbstractDynamicQObject_connectDynamicSlot(
                selfAdr, arg2tmp, arg3tmp, arg4tmp);




    RETURN result;
  END AbstractDynamicQObject_connectDynamicSlot;

PROCEDURE AbstractDynamicQObject_connectDynamicSignal
  (self: AbstractDynamicQObject; signal: TEXT; obj: QObject; slot: TEXT; ):
  BOOLEAN =
  VAR
    selfAdr: ADDRESS     := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp: C.char_star;
    arg3tmp              := LOOPHOLE(obj.cxxObj, ADDRESS);
    arg4tmp: C.char_star;
    result : BOOLEAN;
  BEGIN
    arg2tmp := M3toC.CopyTtoS(signal);
    arg4tmp := M3toC.CopyTtoS(slot);
    result := QtDynamicRaw.AbstractDynamicQObject_connectDynamicSignal(
                selfAdr, arg2tmp, arg3tmp, arg4tmp);




    RETURN result;
  END AbstractDynamicQObject_connectDynamicSignal;

PROCEDURE Delete_AbstractDynamicQObject (self: AbstractDynamicQObject; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtDynamicRaw.Delete_AbstractDynamicQObject(selfAdr);
  END Delete_AbstractDynamicQObject;

PROCEDURE Cleanup_AbstractDynamicQObject
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: AbstractDynamicQObject := ref;
  BEGIN
    Delete_AbstractDynamicQObject(obj);
  END Cleanup_AbstractDynamicQObject;

PROCEDURE Destroy_AbstractDynamicQObject (self: AbstractDynamicQObject) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_AbstractDynamicQObject);
  END Destroy_AbstractDynamicQObject;

REVEAL
  AbstractDynamicQObject =
    AbstractDynamicQObjectPublic BRANDED OBJECT
    OVERRIDES
      qt_metacall          := AbstractDynamicQObject_qt_metacall;
      emitDynamicSignal    := AbstractDynamicQObject_emitDynamicSignal;
      connectDynamicSlot   := AbstractDynamicQObject_connectDynamicSlot;
      connectDynamicSignal := AbstractDynamicQObject_connectDynamicSignal;
      destroyCxx           := Destroy_AbstractDynamicQObject;
    END;

PROCEDURE New_DynamicQObject0
  (self: DynamicQObject; fn: CallbackProc; obj: ADDRESS; ):
  DynamicQObject =
  VAR result: ADDRESS;
  BEGIN
    result := QtDynamicRaw.New_DynamicQObject0(fn, obj);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_DynamicQObject);

    RETURN self;
  END New_DynamicQObject0;

PROCEDURE DynamicQObject_createSlot (self: DynamicQObject; slot: TEXT; ):
  AbstractDynamicSlot =
  VAR
    ret    : ADDRESS;
    result : AbstractDynamicSlot;
    selfAdr: ADDRESS             := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp: C.char_star;
  BEGIN
    arg2tmp := M3toC.CopyTtoS(slot);
    ret := QtDynamicRaw.DynamicQObject_createSlot(selfAdr, arg2tmp);

    result := NEW(AbstractDynamicSlot);
    result.cxxObj := ret;
    result.destroyCxx();



    RETURN result;
  END DynamicQObject_createSlot;

PROCEDURE Delete_DynamicQObject (self: DynamicQObject; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtDynamicRaw.Delete_DynamicQObject(selfAdr);
  END Delete_DynamicQObject;

PROCEDURE Cleanup_DynamicQObject
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: DynamicQObject := ref;
  BEGIN
    Delete_DynamicQObject(obj);
  END Cleanup_DynamicQObject;

PROCEDURE Destroy_DynamicQObject (self: DynamicQObject) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_DynamicQObject);
  END Destroy_DynamicQObject;

REVEAL
  DynamicQObject = DynamicQObjectPublic BRANDED OBJECT
                   OVERRIDES
                     init_0     := New_DynamicQObject0;
                     createSlot := DynamicQObject_createSlot;
                     destroyCxx := Destroy_DynamicQObject;
                   END;

PROCEDURE New_Slot0
  (self: Slot; parent: DynamicQObject; fn: CallbackProc; obj: ADDRESS; ):
  Slot =
  VAR
    result : ADDRESS;
    arg1tmp          := LOOPHOLE(parent.cxxObj, ADDRESS);
  BEGIN
    result := QtDynamicRaw.New_Slot0(arg1tmp, fn, obj);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_Slot);

    RETURN self;
  END New_Slot0;

PROCEDURE Slot_call
  (self: Slot; sender: QObject; arguments: REF ADDRESS; ) =
  VAR
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(sender.cxxObj, ADDRESS);
  BEGIN
    QtDynamicRaw.Slot_call(selfAdr, arg2tmp, arguments);
  END Slot_call;

PROCEDURE Delete_Slot (self: Slot; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtDynamicRaw.Delete_Slot(selfAdr);
  END Delete_Slot;

PROCEDURE Cleanup_Slot
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: Slot := ref;
  BEGIN
    Delete_Slot(obj);
  END Cleanup_Slot;

PROCEDURE Destroy_Slot (self: Slot) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_Slot);
  END Destroy_Slot;

REVEAL
  Slot = SlotPublic BRANDED OBJECT
         OVERRIDES
           init_0     := New_Slot0;
           call       := Slot_call;
           destroyCxx := Destroy_Slot;
         END;


BEGIN
END QtDynamic.
