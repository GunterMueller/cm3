(*******************************************************************************
 * This file was automatically generated by SWIG (http://www.swig.org).
 * Version 2.0.11
 *
 * Do not make changes to this file unless you know what you are doing--modify
 * the SWIG interface file instead.
*******************************************************************************)

UNSAFE MODULE QtPoint;


IMPORT QtPointRaw;


IMPORT WeakRef;
IMPORT Ctypes AS C;

PROCEDURE New_QPoint0 (self: QPoint; ): QPoint =
  VAR result: ADDRESS;
  BEGIN
    result := QtPointRaw.New_QPoint0();

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QPoint);

    RETURN self;
  END New_QPoint0;

PROCEDURE New_QPoint1 (self: QPoint; xpos, ypos: INTEGER; ): QPoint =
  VAR result: ADDRESS;
  BEGIN
    result := QtPointRaw.New_QPoint1(xpos, ypos);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QPoint);

    RETURN self;
  END New_QPoint1;

PROCEDURE QPoint_isNull (self: QPoint; ): BOOLEAN =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPoint_isNull(selfAdr);
  END QPoint_isNull;

PROCEDURE QPoint_x (self: QPoint; ): INTEGER =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPoint_x(selfAdr);
  END QPoint_x;

PROCEDURE QPoint_y (self: QPoint; ): INTEGER =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPoint_y(selfAdr);
  END QPoint_y;

PROCEDURE QPoint_setX (self: QPoint; x: INTEGER; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtPointRaw.QPoint_setX(selfAdr, x);
  END QPoint_setX;

PROCEDURE QPoint_setY (self: QPoint; y: INTEGER; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtPointRaw.QPoint_setY(selfAdr, y);
  END QPoint_setY;

PROCEDURE QPoint_manhattanLength (self: QPoint; ): INTEGER =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPoint_manhattanLength(selfAdr);
  END QPoint_manhattanLength;

PROCEDURE QPoint_rx (self: QPoint; ): UNTRACED REF INTEGER =
  VAR
    ret    : UNTRACED REF C.int;
    result                      := NEW(UNTRACED REF INTEGER);
    selfAdr: ADDRESS            := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_rx(selfAdr);
    result^ := ret^;
    RETURN result;
  END QPoint_rx;

PROCEDURE QPoint_ry (self: QPoint; ): UNTRACED REF INTEGER =
  VAR
    ret    : UNTRACED REF C.int;
    result                      := NEW(UNTRACED REF INTEGER);
    selfAdr: ADDRESS            := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_ry(selfAdr);
    result^ := ret^;
    RETURN result;
  END QPoint_ry;

PROCEDURE QPoint_PlusEqual (self, p: QPoint; ): QPoint =
  VAR
    ret    : ADDRESS;
    result : QPoint;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(p.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_PlusEqual(selfAdr, arg2tmp);

    IF ISTYPE(result, QPoint) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPoint);
    ELSE
      result := NEW(QPoint);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPoint_PlusEqual;

PROCEDURE QPoint_MinusEqual (self, p: QPoint; ): QPoint =
  VAR
    ret    : ADDRESS;
    result : QPoint;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(p.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_MinusEqual(selfAdr, arg2tmp);

    IF ISTYPE(result, QPoint) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPoint);
    ELSE
      result := NEW(QPoint);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPoint_MinusEqual;

PROCEDURE QPoint_MultiplyEqual (self: QPoint; c: REAL; ): QPoint =
  VAR
    ret    : ADDRESS;
    result : QPoint;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_MultiplyEqual(selfAdr, c);

    IF ISTYPE(result, QPoint) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPoint);
    ELSE
      result := NEW(QPoint);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPoint_MultiplyEqual;

PROCEDURE QPoint_MultiplyEqual1 (self: QPoint; c: LONGREAL; ): QPoint =
  VAR
    ret    : ADDRESS;
    result : QPoint;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_MultiplyEqual1(selfAdr, c);

    IF ISTYPE(result, QPoint) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPoint);
    ELSE
      result := NEW(QPoint);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPoint_MultiplyEqual1;

PROCEDURE QPoint_MultiplyEqual2 (self: QPoint; c: INTEGER; ): QPoint =
  VAR
    ret    : ADDRESS;
    result : QPoint;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_MultiplyEqual2(selfAdr, c);

    IF ISTYPE(result, QPoint) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPoint);
    ELSE
      result := NEW(QPoint);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPoint_MultiplyEqual2;

PROCEDURE QPoint_DivideEqual (self: QPoint; c: LONGREAL; ): QPoint =
  VAR
    ret    : ADDRESS;
    result : QPoint;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPoint_DivideEqual(selfAdr, c);

    IF ISTYPE(result, QPoint) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPoint);
    ELSE
      result := NEW(QPoint);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPoint_DivideEqual;

PROCEDURE Delete_QPoint (self: QPoint; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtPointRaw.Delete_QPoint(selfAdr);
  END Delete_QPoint;

PROCEDURE Cleanup_QPoint
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: QPoint := ref;
  BEGIN
    Delete_QPoint(obj);
  END Cleanup_QPoint;

PROCEDURE Destroy_QPoint (self: QPoint) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_QPoint);
  END Destroy_QPoint;

REVEAL
  QPoint = QPointPublic BRANDED OBJECT
           OVERRIDES
             init_0          := New_QPoint0;
             init_1          := New_QPoint1;
             isNull          := QPoint_isNull;
             x               := QPoint_x;
             y               := QPoint_y;
             setX            := QPoint_setX;
             setY            := QPoint_setY;
             manhattanLength := QPoint_manhattanLength;
             rx              := QPoint_rx;
             ry              := QPoint_ry;
             PlusEqual       := QPoint_PlusEqual;
             MinusEqual      := QPoint_MinusEqual;
             MultiplyEqual   := QPoint_MultiplyEqual;
             MultiplyEqual1  := QPoint_MultiplyEqual1;
             MultiplyEqual2  := QPoint_MultiplyEqual2;
             DivideEqual     := QPoint_DivideEqual;
             destroyCxx      := Destroy_QPoint;
           END;

PROCEDURE New_QPointF0 (self: QPointF; ): QPointF =
  VAR result: ADDRESS;
  BEGIN
    result := QtPointRaw.New_QPointF0();

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QPointF);

    RETURN self;
  END New_QPointF0;

PROCEDURE New_QPointF1 (self: QPointF; p: QPoint; ): QPointF =
  VAR
    result : ADDRESS;
    arg1tmp          := LOOPHOLE(p.cxxObj, ADDRESS);
  BEGIN
    result := QtPointRaw.New_QPointF1(arg1tmp);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QPointF);

    RETURN self;
  END New_QPointF1;

PROCEDURE New_QPointF2 (self: QPointF; xpos, ypos: LONGREAL; ): QPointF =
  VAR result: ADDRESS;
  BEGIN
    result := QtPointRaw.New_QPointF2(xpos, ypos);

    self.cxxObj := result;
    EVAL WeakRef.FromRef(self, Cleanup_QPointF);

    RETURN self;
  END New_QPointF2;

PROCEDURE QPointF_manhattanLength (self: QPointF; ): LONGREAL =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPointF_manhattanLength(selfAdr);
  END QPointF_manhattanLength;

PROCEDURE QPointF_isNull (self: QPointF; ): BOOLEAN =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPointF_isNull(selfAdr);
  END QPointF_isNull;

PROCEDURE QPointF_x (self: QPointF; ): LONGREAL =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPointF_x(selfAdr);
  END QPointF_x;

PROCEDURE QPointF_y (self: QPointF; ): LONGREAL =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    RETURN QtPointRaw.QPointF_y(selfAdr);
  END QPointF_y;

PROCEDURE QPointF_setX (self: QPointF; x: LONGREAL; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtPointRaw.QPointF_setX(selfAdr, x);
  END QPointF_setX;

PROCEDURE QPointF_setY (self: QPointF; y: LONGREAL; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtPointRaw.QPointF_setY(selfAdr, y);
  END QPointF_setY;

PROCEDURE QPointF_rx (self: QPointF; ): UNTRACED REF LONGREAL =
  VAR
    ret    : UNTRACED REF C.double;
    result                         := NEW(UNTRACED REF LONGREAL);
    selfAdr: ADDRESS               := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPointF_rx(selfAdr);
    result^ := ret^;
    RETURN result;
  END QPointF_rx;

PROCEDURE QPointF_ry (self: QPointF; ): UNTRACED REF LONGREAL =
  VAR
    ret    : UNTRACED REF C.double;
    result                         := NEW(UNTRACED REF LONGREAL);
    selfAdr: ADDRESS               := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPointF_ry(selfAdr);
    result^ := ret^;
    RETURN result;
  END QPointF_ry;

PROCEDURE QPointF_PlusEqual (self, p: QPointF; ): QPointF =
  VAR
    ret    : ADDRESS;
    result : QPointF;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(p.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPointF_PlusEqual(selfAdr, arg2tmp);

    IF ISTYPE(result, QPointF) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPointF);
    ELSE
      result := NEW(QPointF);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPointF_PlusEqual;

PROCEDURE QPointF_MinusEqual (self, p: QPointF; ): QPointF =
  VAR
    ret    : ADDRESS;
    result : QPointF;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
    arg2tmp          := LOOPHOLE(p.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPointF_MinusEqual(selfAdr, arg2tmp);

    IF ISTYPE(result, QPointF) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPointF);
    ELSE
      result := NEW(QPointF);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPointF_MinusEqual;

PROCEDURE QPointF_MultiplyEqual (self: QPointF; c: LONGREAL; ): QPointF =
  VAR
    ret    : ADDRESS;
    result : QPointF;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPointF_MultiplyEqual(selfAdr, c);

    IF ISTYPE(result, QPointF) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPointF);
    ELSE
      result := NEW(QPointF);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPointF_MultiplyEqual;

PROCEDURE QPointF_DivideEqual (self: QPointF; c: LONGREAL; ): QPointF =
  VAR
    ret    : ADDRESS;
    result : QPointF;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPointF_DivideEqual(selfAdr, c);

    IF ISTYPE(result, QPointF) AND ret = selfAdr THEN
      result := LOOPHOLE(self, QPointF);
    ELSE
      result := NEW(QPointF);
      result.cxxObj := ret;
      result.destroyCxx();
    END;

    RETURN result;
  END QPointF_DivideEqual;

PROCEDURE QPointF_toPoint (self: QPointF; ): QPoint =
  VAR
    ret    : ADDRESS;
    result : QPoint;
    selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    ret := QtPointRaw.QPointF_toPoint(selfAdr);

    result := NEW(QPoint);
    result.cxxObj := ret;
    result.destroyCxx();

    RETURN result;
  END QPointF_toPoint;

PROCEDURE Delete_QPointF (self: QPointF; ) =
  VAR selfAdr: ADDRESS := LOOPHOLE(self.cxxObj, ADDRESS);
  BEGIN
    QtPointRaw.Delete_QPointF(selfAdr);
  END Delete_QPointF;

PROCEDURE Cleanup_QPointF
  (<* UNUSED *> READONLY self: WeakRef.T; ref: REFANY) =
  VAR obj: QPointF := ref;
  BEGIN
    Delete_QPointF(obj);
  END Cleanup_QPointF;

PROCEDURE Destroy_QPointF (self: QPointF) =
  BEGIN
    EVAL WeakRef.FromRef(self, Cleanup_QPointF);
  END Destroy_QPointF;

REVEAL
  QPointF = QPointFPublic BRANDED OBJECT
            OVERRIDES
              init_0          := New_QPointF0;
              init_1          := New_QPointF1;
              init_2          := New_QPointF2;
              manhattanLength := QPointF_manhattanLength;
              isNull          := QPointF_isNull;
              x               := QPointF_x;
              y               := QPointF_y;
              setX            := QPointF_setX;
              setY            := QPointF_setY;
              rx              := QPointF_rx;
              ry              := QPointF_ry;
              PlusEqual       := QPointF_PlusEqual;
              MinusEqual      := QPointF_MinusEqual;
              MultiplyEqual   := QPointF_MultiplyEqual;
              DivideEqual     := QPointF_DivideEqual;
              toPoint         := QPointF_toPoint;
              destroyCxx      := Destroy_QPointF;
            END;


BEGIN
END QtPoint.
